var global = (function() {

  var base64Decode = function(string) {
    return window.atob(string);
  };

  return {
    filesystem: {
      root: {
        "browser": {
          "__stat": {
            "dev": 16777217,
            "mode": 16877,
            "nlink": 19,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 1076893,
            "size": 646,
            "blocks": 0,
            "atime": "2013-04-27T01:10:42.000Z",
            "mtime": "2013-04-26T22:26:21.000Z",
            "ctime": "2013-04-26T22:26:21.000Z",
            "type": "directory"
          },
          "shred.bundle.js": {
            "__stat": {
              "dev": 16777217,
              "mode": 33188,
              "nlink": 1,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1077277,
              "size": 87172,
              "blocks": 176,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2012-11-13T16:45:48.000Z",
              "ctime": "2013-01-03T21:56:20.000Z",
              "type": "file"
            },
            "__ref": "834df2a902f4f1b69321d43c010dcb08"
          },
          "shred.bundle.min.js": {
            "__stat": {
              "dev": 16777217,
              "mode": 33188,
              "nlink": 1,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1077278,
              "size": 34920,
              "blocks": 72,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2012-11-13T16:45:48.000Z",
              "ctime": "2013-01-03T21:56:20.000Z",
              "type": "file"
            },
            "__ref": "9dfd6fc6391a1af2ed8b4f7ba2b99ed7"
          }
        },
        "examples": {
          "__stat": {
            "dev": 16777217,
            "mode": 16877,
            "nlink": 19,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 1076893,
            "size": 646,
            "blocks": 0,
            "atime": "2013-04-27T01:10:42.000Z",
            "mtime": "2013-04-26T22:26:21.000Z",
            "ctime": "2013-04-26T22:26:21.000Z",
            "type": "directory"
          },
          "examples.js": {
            "__stat": {
              "dev": 16777217,
              "mode": 33188,
              "nlink": 1,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1077291,
              "size": 6767,
              "blocks": 16,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2012-07-18T16:47:04.000Z",
              "ctime": "2013-01-03T21:56:20.000Z",
              "type": "file"
            },
            "__ref": "89f447aafb7eb2aab8a5865df4376f49"
          }
        },
        "lib": {
          "__stat": {
            "dev": 16777217,
            "mode": 16877,
            "nlink": 19,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 1076893,
            "size": 646,
            "blocks": 0,
            "atime": "2013-04-27T01:10:42.000Z",
            "mtime": "2013-04-26T22:26:21.000Z",
            "ctime": "2013-04-26T22:26:21.000Z",
            "type": "directory"
          },
          "shred.js": {
            "__stat": {
              "dev": 16777217,
              "mode": 33188,
              "nlink": 1,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1665054,
              "size": 2138,
              "blocks": 8,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-01-31T19:07:22.000Z",
              "ctime": "2013-03-09T17:16:18.000Z",
              "type": "file"
            },
            "__ref": "91ead0407d37ff5af5880eafdd045b2a"
          },
          "shred": {
            "__stat": {
              "dev": 16777217,
              "mode": 16877,
              "nlink": 19,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1076893,
              "size": 646,
              "blocks": 0,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-04-26T22:26:21.000Z",
              "ctime": "2013-04-26T22:26:21.000Z",
              "type": "directory"
            },
            "content.js": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1666373,
                "size": 6863,
                "blocks": 16,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-01-31T19:43:08.000Z",
                "ctime": "2013-03-09T17:16:18.000Z",
                "type": "file"
              },
              "__ref": "097818971e926c40ff8b34e3fa8ecd9f"
            },
            "mixins": {
              "__stat": {
                "dev": 16777217,
                "mode": 16877,
                "nlink": 19,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1076893,
                "size": 646,
                "blocks": 0,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:26:21.000Z",
                "ctime": "2013-04-26T22:26:21.000Z",
                "type": "directory"
              },
              "headers.js": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 1077297,
                  "size": 4130,
                  "blocks": 16,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2012-11-13T16:45:48.000Z",
                  "ctime": "2013-02-09T17:28:14.000Z",
                  "type": "file"
                },
                "__ref": "39ac48f00aad0db6221f17af0df5baa7"
              }
            },
            "parseUri.js": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1077298,
                "size": 1051,
                "blocks": 8,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2012-07-18T16:47:04.000Z",
                "ctime": "2013-02-09T17:28:14.000Z",
                "type": "file"
              },
              "__ref": "f7da3e52db2923e9c29cde066f306bce"
            },
            "request.js": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1664927,
                "size": 17584,
                "blocks": 40,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-01-31T18:59:37.000Z",
                "ctime": "2013-02-09T17:29:45.000Z",
                "type": "file"
              },
              "__ref": "0256ce4a492726f7974cafe8ac0c6b52"
            },
            "response.js": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1550063,
                "size": 6237,
                "blocks": 16,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-01-24T22:45:21.000Z",
                "ctime": "2013-02-09T17:28:14.000Z",
                "type": "file"
              },
              "__ref": "7fd3f9acfab25ddaad20c8acb5c9f50f"
            }
          }
        },
        "node_modules": {
          "__stat": {
            "dev": 16777217,
            "mode": 16877,
            "nlink": 19,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 1076893,
            "size": 646,
            "blocks": 0,
            "atime": "2013-04-27T01:10:42.000Z",
            "mtime": "2013-04-26T22:26:21.000Z",
            "ctime": "2013-04-26T22:26:21.000Z",
            "type": "directory"
          },
          "ax": {
            "__stat": {
              "dev": 16777217,
              "mode": 16877,
              "nlink": 19,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1076893,
              "size": 646,
              "blocks": 0,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-04-26T22:26:21.000Z",
              "ctime": "2013-04-26T22:26:21.000Z",
              "type": "directory"
            },
            "browser": {
              "__stat": {
                "dev": 16777217,
                "mode": 16877,
                "nlink": 19,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1076893,
                "size": 646,
                "blocks": 0,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:26:21.000Z",
                "ctime": "2013-04-26T22:26:21.000Z",
                "type": "directory"
              },
              "ax.js": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 1077320,
                  "size": 11627,
                  "blocks": 24,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2012-10-18T18:25:54.000Z",
                  "ctime": "2013-01-03T21:56:21.000Z",
                  "type": "file"
                },
                "__ref": "132989d40603a8a27e34fed726e9aa14"
              }
            },
            "examples": {
              "__stat": {
                "dev": 16777217,
                "mode": 16877,
                "nlink": 19,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1076893,
                "size": 646,
                "blocks": 0,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:26:21.000Z",
                "ctime": "2013-04-26T22:26:21.000Z",
                "type": "directory"
              },
              "javascripts": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 16877,
                  "nlink": 19,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 1076893,
                  "size": 646,
                  "blocks": 0,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2013-04-26T22:26:21.000Z",
                  "ctime": "2013-04-26T22:26:21.000Z",
                  "type": "directory"
                },
                "ax.js": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 1077324,
                    "size": 0,
                    "blocks": 0,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2012-08-14T17:49:47.000Z",
                    "ctime": "2013-01-03T21:56:21.000Z",
                    "type": "file"
                  },
                  "__ref": "d41d8cd98f00b204e9800998ecf8427e"
                },
                "lib": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 16877,
                    "nlink": 19,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 1076893,
                    "size": 646,
                    "blocks": 0,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2013-04-26T22:26:21.000Z",
                    "ctime": "2013-04-26T22:26:21.000Z",
                    "type": "directory"
                  },
                  "ax.js": {
                    "__stat": {
                      "dev": 16777217,
                      "mode": 33188,
                      "nlink": 1,
                      "uid": 501,
                      "gid": 20,
                      "rdev": 0,
                      "blksize": 4096,
                      "ino": 1077326,
                      "size": 11627,
                      "blocks": 24,
                      "atime": "2013-04-27T01:10:42.000Z",
                      "mtime": "2012-10-18T18:25:54.000Z",
                      "ctime": "2013-01-03T21:56:21.000Z",
                      "type": "file"
                    },
                    "__ref": "132989d40603a8a27e34fed726e9aa14"
                  }
                }
              },
              "simple.js": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 1077327,
                  "size": 463,
                  "blocks": 8,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2012-10-18T17:49:32.000Z",
                  "ctime": "2013-01-03T21:56:21.000Z",
                  "type": "file"
                },
                "__ref": "04be349b3c0f2856b0074f9dc4824189"
              }
            },
            "lib": {
              "__stat": {
                "dev": 16777217,
                "mode": 16877,
                "nlink": 19,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1076893,
                "size": 646,
                "blocks": 0,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:26:21.000Z",
                "ctime": "2013-04-26T22:26:21.000Z",
                "type": "directory"
              },
              "ax.js": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 1077329,
                  "size": 3112,
                  "blocks": 8,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2012-10-25T15:53:01.000Z",
                  "ctime": "2013-03-04T16:57:30.000Z",
                  "type": "file"
                },
                "__ref": "f54c237eca3ec015842d2946265847f7"
              }
            },
            "package.json": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1077330,
                "size": 3269,
                "blocks": 8,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2012-11-07T21:34:26.000Z",
                "ctime": "2013-01-25T16:48:57.000Z",
                "type": "file"
              },
              "__ref": "8a6e04352a288affc236f633ffeeaa5e"
            }
          },
          "buffer-browserify": {
            "__stat": {
              "dev": 16777217,
              "mode": 16877,
              "nlink": 19,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1076893,
              "size": 646,
              "blocks": 0,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-04-26T22:26:21.000Z",
              "ctime": "2013-04-26T22:26:21.000Z",
              "type": "directory"
            },
            "buffer_ieee754.js": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4892530,
                "size": 2107,
                "blocks": 8,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2012-07-15T23:11:02.000Z",
                "ctime": "2013-04-26T20:57:16.000Z",
                "type": "file"
              },
              "__ref": "f41fe98f55620bae34c8b5ce969028b8"
            },
            "index.js": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4892531,
                "size": 35564,
                "blocks": 72,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-02-27T20:53:51.000Z",
                "ctime": "2013-04-26T20:57:16.000Z",
                "type": "file"
              },
              "__ref": "dc10a398e1e1237d5a4d2512cd4115e7"
            },
            "node_modules": {
              "__stat": {
                "dev": 16777217,
                "mode": 16877,
                "nlink": 19,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1076893,
                "size": 646,
                "blocks": 0,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:26:21.000Z",
                "ctime": "2013-04-26T22:26:21.000Z",
                "type": "directory"
              },
              "base64-js": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 16877,
                  "nlink": 19,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 1076893,
                  "size": 646,
                  "blocks": 0,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2013-04-26T22:26:21.000Z",
                  "ctime": "2013-04-26T22:26:21.000Z",
                  "type": "directory"
                },
                "lib": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 16877,
                    "nlink": 19,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 1076893,
                    "size": 646,
                    "blocks": 0,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2013-04-26T22:26:21.000Z",
                    "ctime": "2013-04-26T22:26:21.000Z",
                    "type": "directory"
                  },
                  "b64.js": {
                    "__stat": {
                      "dev": 16777217,
                      "mode": 33188,
                      "nlink": 1,
                      "uid": 501,
                      "gid": 20,
                      "rdev": 0,
                      "blksize": 4096,
                      "ino": 4892570,
                      "size": 2736,
                      "blocks": 8,
                      "atime": "2013-04-27T01:10:42.000Z",
                      "mtime": "2011-11-26T22:06:28.000Z",
                      "ctime": "2013-04-26T20:57:16.000Z",
                      "type": "file"
                    },
                    "__ref": "3a6e76760acad26f4fda49be6424ea8f"
                  }
                },
                "package.json": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4892567,
                    "size": 1266,
                    "blocks": 8,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2013-04-26T20:57:16.000Z",
                    "ctime": "2013-04-26T20:57:16.000Z",
                    "type": "file"
                  },
                  "__ref": "2a1543839ac90d770378892878ea773a"
                }
              }
            },
            "package.json": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4892527,
                "size": 1323,
                "blocks": 8,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T20:57:16.000Z",
                "ctime": "2013-04-26T20:57:16.000Z",
                "type": "file"
              },
              "__ref": "cc3932b88baa5dd877931163f195d58e"
            }
          },
          "cookiejar": {
            "__stat": {
              "dev": 16777217,
              "mode": 16877,
              "nlink": 19,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1076893,
              "size": 646,
              "blocks": 0,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-04-26T22:26:21.000Z",
              "ctime": "2013-04-26T22:26:21.000Z",
              "type": "directory"
            },
            "cookiejar.js": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1077907,
                "size": 5746,
                "blocks": 16,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2011-05-24T11:41:07.000Z",
                "ctime": "2013-02-09T17:29:45.000Z",
                "type": "file"
              },
              "__ref": "e926a8d145979e541da928088365eecf"
            },
            "package.json": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1077908,
                "size": 2099,
                "blocks": 8,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2012-11-07T21:34:26.000Z",
                "ctime": "2013-01-25T16:48:57.000Z",
                "type": "file"
              },
              "__ref": "f0633c69e3137d9c641964c5b251e214"
            }
          },
          "sprintf": {
            "__stat": {
              "dev": 16777217,
              "mode": 16877,
              "nlink": 19,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1076893,
              "size": 646,
              "blocks": 0,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-04-26T22:26:21.000Z",
              "ctime": "2013-04-26T22:26:21.000Z",
              "type": "directory"
            },
            "lib": {
              "__stat": {
                "dev": 16777217,
                "mode": 16877,
                "nlink": 19,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1076893,
                "size": 646,
                "blocks": 0,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:26:21.000Z",
                "ctime": "2013-04-26T22:26:21.000Z",
                "type": "directory"
              },
              "sprintf.js": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 1078306,
                  "size": 6869,
                  "blocks": 16,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2010-11-23T10:22:19.000Z",
                  "ctime": "2013-02-09T17:29:45.000Z",
                  "type": "file"
                },
                "__ref": "972690d006842c98fda9e56ccf594a63"
              }
            },
            "package.json": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1078307,
                "size": 625,
                "blocks": 8,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2012-11-07T21:34:26.000Z",
                "ctime": "2013-02-09T17:28:14.000Z",
                "type": "file"
              },
              "__ref": "8ecc84d18f299b5f78e4c72981dbe73b"
            }
          },
          "testify": {
            "__stat": {
              "dev": 16777217,
              "mode": 16877,
              "nlink": 19,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1076893,
              "size": 646,
              "blocks": 0,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-04-26T22:26:21.000Z",
              "ctime": "2013-04-26T22:26:21.000Z",
              "type": "directory"
            },
            "node_modules": {
              "__stat": {
                "dev": 16777217,
                "mode": 16877,
                "nlink": 19,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1076893,
                "size": 646,
                "blocks": 0,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:26:21.000Z",
                "ctime": "2013-04-26T22:26:21.000Z",
                "type": "directory"
              },
              "colors": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 16877,
                  "nlink": 19,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 1076893,
                  "size": 646,
                  "blocks": 0,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2013-04-26T22:26:21.000Z",
                  "ctime": "2013-04-26T22:26:21.000Z",
                  "type": "directory"
                },
                "colors.js": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4896364,
                    "size": 7705,
                    "blocks": 16,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2011-12-09T12:35:20.000Z",
                    "ctime": "2013-04-26T22:09:39.000Z",
                    "type": "file"
                  },
                  "__ref": "a089014e00fc816889fd3a26e987bdbd"
                },
                "example.js": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4896370,
                    "size": 2039,
                    "blocks": 8,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2011-12-09T12:35:20.000Z",
                    "ctime": "2013-04-26T22:09:39.000Z",
                    "type": "file"
                  },
                  "__ref": "865b933cdca5bf49b1f012335b02ff93"
                },
                "package.json": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4896361,
                    "size": 1793,
                    "blocks": 8,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2013-04-26T22:09:39.000Z",
                    "ctime": "2013-04-26T22:09:39.000Z",
                    "type": "file"
                  },
                  "__ref": "74c8622078cff87f7a2ddc5b866312ff"
                },
                "test.js": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4896373,
                    "size": 1958,
                    "blocks": 8,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2011-12-09T12:35:20.000Z",
                    "ctime": "2013-04-26T22:09:39.000Z",
                    "type": "file"
                  },
                  "__ref": "c3451fe7035e99947143be3e88c3eaef"
                }
              },
              "minfinite": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 16877,
                  "nlink": 19,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 1076893,
                  "size": 646,
                  "blocks": 0,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2013-04-26T22:26:21.000Z",
                  "ctime": "2013-04-26T22:26:21.000Z",
                  "type": "directory"
                },
                "minfinite.js": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4896367,
                    "size": 2161,
                    "blocks": 8,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2013-03-04T18:11:25.000Z",
                    "ctime": "2013-04-26T22:09:39.000Z",
                    "type": "file"
                  },
                  "__ref": "d7c4041289e5445eec291db26b21409d"
                },
                "package.json": {
                  "__stat": {
                    "dev": 16777217,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4896363,
                    "size": 581,
                    "blocks": 8,
                    "atime": "2013-04-27T01:10:42.000Z",
                    "mtime": "2013-04-26T22:09:39.000Z",
                    "ctime": "2013-04-26T22:09:39.000Z",
                    "type": "file"
                  },
                  "__ref": "e241c1de18faf4151605d7b35b8b9eab"
                }
              }
            },
            "package.json": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4896330,
                "size": 2756,
                "blocks": 8,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:09:39.000Z",
                "ctime": "2013-04-26T22:09:39.000Z",
                "type": "file"
              },
              "__ref": "8c37014c53ded1aa3e3c6fea2b7b527f"
            },
            "src": {
              "__stat": {
                "dev": 16777217,
                "mode": 16877,
                "nlink": 19,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1076893,
                "size": 646,
                "blocks": 0,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:26:21.000Z",
                "ctime": "2013-04-26T22:26:21.000Z",
                "type": "directory"
              },
              "benchmark.coffee": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4896336,
                  "size": 1895,
                  "blocks": 8,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2013-04-20T16:26:57.000Z",
                  "ctime": "2013-04-26T22:09:39.000Z",
                  "type": "file"
                },
                "__ref": "e771513490ac1884ffed5cef377b37be"
              },
              "context.coffee": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4896337,
                  "size": 4331,
                  "blocks": 16,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2013-04-20T16:46:14.000Z",
                  "ctime": "2013-04-26T22:09:39.000Z",
                  "type": "file"
                },
                "__ref": "1f082de170804a1f8caa134abdafdb55"
              },
              "reporters.coffee": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4896338,
                  "size": 6394,
                  "blocks": 16,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2013-04-21T17:09:23.000Z",
                  "ctime": "2013-04-26T22:09:39.000Z",
                  "type": "file"
                },
                "__ref": "7abe6dc3c91fe653e9c4a2d096ee8684"
              },
              "test.coffee": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4896339,
                  "size": 1584,
                  "blocks": 8,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2013-04-20T17:00:49.000Z",
                  "ctime": "2013-04-26T22:09:39.000Z",
                  "type": "file"
                },
                "__ref": "62e49fef2333868ff4848cf4ec8f121d"
              },
              "testify.coffee": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4896340,
                  "size": 1906,
                  "blocks": 8,
                  "atime": "2013-04-27T01:10:42.000Z",
                  "mtime": "2013-04-21T16:54:10.000Z",
                  "ctime": "2013-04-26T22:09:39.000Z",
                  "type": "file"
                },
                "__ref": "1acd0107c78da6657c2d635a044b63b7"
              }
            },
            "statistics.js": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4896332,
                "size": 7260,
                "blocks": 16,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-02-15T02:25:38.000Z",
                "ctime": "2013-04-26T22:09:39.000Z",
                "type": "file"
              },
              "__ref": "d5618ac652297a3b9b8a6b6a4104f37b"
            }
          }
        },
        "package.json": {
          "__stat": {
            "dev": 16777217,
            "mode": 33188,
            "nlink": 1,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 4896131,
            "size": 1608,
            "blocks": 8,
            "atime": "2013-04-27T01:10:42.000Z",
            "mtime": "2013-04-26T22:08:46.000Z",
            "ctime": "2013-04-26T22:08:46.000Z",
            "type": "file"
          },
          "__ref": "fa53c363771d2457d1828de9260428b1"
        },
        "src": {
          "__stat": {
            "dev": 16777217,
            "mode": 16877,
            "nlink": 19,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 1076893,
            "size": 646,
            "blocks": 0,
            "atime": "2013-04-27T01:10:42.000Z",
            "mtime": "2013-04-26T22:26:21.000Z",
            "ctime": "2013-04-26T22:26:21.000Z",
            "type": "directory"
          },
          "shred.coffee": {
            "__stat": {
              "dev": 16777217,
              "mode": 33188,
              "nlink": 1,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 4903793,
              "size": 1781,
              "blocks": 8,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-04-27T00:27:28.000Z",
              "ctime": "2013-04-27T00:27:28.000Z",
              "type": "file"
            },
            "__ref": "472824fe00f2d2075a0fbd3267b79538"
          },
          "shred": {
            "__stat": {
              "dev": 16777217,
              "mode": 16877,
              "nlink": 19,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1076893,
              "size": 646,
              "blocks": 0,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-04-26T22:26:21.000Z",
              "ctime": "2013-04-26T22:26:21.000Z",
              "type": "directory"
            },
            "content.coffee": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4879764,
                "size": 5959,
                "blocks": 16,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T17:36:28.000Z",
                "ctime": "2013-04-26T17:36:28.000Z",
                "type": "file"
              },
              "__ref": "de6f3ec27408aa6c2dbef934db6778ac"
            },
            "mixins": {
              "__stat": {
                "dev": 16777217,
                "mode": 16877,
                "nlink": 19,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 1076893,
                "size": 646,
                "blocks": 0,
                "atime": "2013-04-27T01:10:42.000Z",
                "mtime": "2013-04-26T22:26:21.000Z",
                "ctime": "2013-04-26T22:26:21.000Z",
                "type": "directory"
              },
              "headers.coffee": {
                "__stat": {
                  "dev": 16777217,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4878640,
                  "size": 3678,
                  "blocks": 8,
                  "atime": "2013-04-27T01:10:43.000Z",
                  "mtime": "2013-04-26T16:36:24.000Z",
                  "ctime": "2013-04-26T16:36:24.000Z",
                  "type": "file"
                },
                "__ref": "e938fbd381641c5df05e3419364a31b8"
              }
            },
            "parseUri.coffee": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4878309,
                "size": 1013,
                "blocks": 8,
                "atime": "2013-04-27T01:10:43.000Z",
                "mtime": "2013-04-26T16:19:53.000Z",
                "ctime": "2013-04-26T16:19:53.000Z",
                "type": "file"
              },
              "__ref": "e8b753db709b5ef4915068e0925367dc"
            },
            "request.coffee": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4903904,
                "size": 15881,
                "blocks": 32,
                "atime": "2013-04-27T01:10:43.000Z",
                "mtime": "2013-04-27T00:30:39.000Z",
                "ctime": "2013-04-27T00:30:39.000Z",
                "type": "file"
              },
              "__ref": "43dfb23f47862a3f4f5b2ac8879a2729"
            },
            "response.coffee": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4903426,
                "size": 5064,
                "blocks": 16,
                "atime": "2013-04-27T01:10:43.000Z",
                "mtime": "2013-04-27T00:15:32.000Z",
                "ctime": "2013-04-27T00:15:32.000Z",
                "type": "file"
              },
              "__ref": "b025a4ec5f8e8625d8be4f61ef482b60"
            }
          }
        },
        "test": {
          "__stat": {
            "dev": 16777217,
            "mode": 16877,
            "nlink": 19,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 1076893,
            "size": 646,
            "blocks": 0,
            "atime": "2013-04-27T01:10:42.000Z",
            "mtime": "2013-04-26T22:26:21.000Z",
            "ctime": "2013-04-26T22:26:21.000Z",
            "type": "directory"
          },
          "browser": {
            "__stat": {
              "dev": 16777217,
              "mode": 16877,
              "nlink": 19,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 1076893,
              "size": 646,
              "blocks": 0,
              "atime": "2013-04-27T01:10:42.000Z",
              "mtime": "2013-04-26T22:26:21.000Z",
              "ctime": "2013-04-26T22:26:21.000Z",
              "type": "directory"
            },
            "application.coffee": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4901915,
                "size": 294,
                "blocks": 8,
                "atime": "2013-04-27T01:10:43.000Z",
                "mtime": "2013-04-26T23:32:06.000Z",
                "ctime": "2013-04-26T23:32:06.000Z",
                "type": "file"
              },
              "__ref": "aa29b8a06095dd170e247794b8ea185c"
            },
            "package.json": {
              "__stat": {
                "dev": 16777217,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4890159,
                "size": 272,
                "blocks": 8,
                "atime": "2013-04-27T01:10:43.000Z",
                "mtime": "2013-04-26T19:56:36.000Z",
                "ctime": "2013-04-26T19:56:36.000Z",
                "type": "file"
              },
              "__ref": "d139b7f6fb5124550603cac960ba5039"
            }
          },
          "content_test.coffee": {
            "__stat": {
              "dev": 16777217,
              "mode": 33188,
              "nlink": 1,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 4891072,
              "size": 3532,
              "blocks": 8,
              "atime": "2013-04-27T01:10:43.000Z",
              "mtime": "2013-04-26T20:16:16.000Z",
              "ctime": "2013-04-26T20:16:16.000Z",
              "type": "file"
            },
            "__ref": "7c6f94265ce22f5ba1d0be971c82b6a2"
          },
          "headers_test.coffee": {
            "__stat": {
              "dev": 16777217,
              "mode": 33188,
              "nlink": 1,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 4878614,
              "size": 1778,
              "blocks": 8,
              "atime": "2013-04-27T01:10:43.000Z",
              "mtime": "2013-04-26T16:34:49.000Z",
              "ctime": "2013-04-26T16:34:49.000Z",
              "type": "file"
            },
            "__ref": "70163b46f8555ff67c92083cf367db04"
          },
          "shred_test.coffee": {
            "__stat": {
              "dev": 16777217,
              "mode": 33188,
              "nlink": 1,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 4904892,
              "size": 8084,
              "blocks": 16,
              "atime": "2013-04-27T01:10:43.000Z",
              "mtime": "2013-04-27T01:10:40.000Z",
              "ctime": "2013-04-27T01:10:40.000Z",
              "type": "file"
            },
            "__ref": "e7b0a85973e60e50391916726b0eac62"
          },
          "tests.coffee": {
            "__stat": {
              "dev": 16777217,
              "mode": 33188,
              "nlink": 1,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 4883778,
              "size": 73,
              "blocks": 8,
              "atime": "2013-04-27T01:10:43.000Z",
              "mtime": "2013-04-26T19:18:56.000Z",
              "ctime": "2013-04-26T19:18:56.000Z",
              "type": "file"
            },
            "__ref": "8d54b30e151e0c43af3ec7bcd718de7b"
          }
        }
      },
      content: {
        "834df2a902f4f1b69321d43c010dcb08": "ODM0ZGYyYTkwMmY0ZjFiNjkzMjFkNDNjMDEwZGNiMDg=",
        "9dfd6fc6391a1af2ed8b4f7ba2b99ed7": "OWRmZDZmYzYzOTFhMWFmMmVkOGI0ZjdiYTJiOTllZDc=",
        "89f447aafb7eb2aab8a5865df4376f49": "ODlmNDQ3YWFmYjdlYjJhYWI4YTU4NjVkZjQzNzZmNDk=",
        "91ead0407d37ff5af5880eafdd045b2a": "OTFlYWQwNDA3ZDM3ZmY1YWY1ODgwZWFmZGQwNDViMmE=",
        "097818971e926c40ff8b34e3fa8ecd9f": "MDk3ODE4OTcxZTkyNmM0MGZmOGIzNGUzZmE4ZWNkOWY=",
        "39ac48f00aad0db6221f17af0df5baa7": "MzlhYzQ4ZjAwYWFkMGRiNjIyMWYxN2FmMGRmNWJhYTc=",
        "f7da3e52db2923e9c29cde066f306bce": "ZjdkYTNlNTJkYjI5MjNlOWMyOWNkZTA2NmYzMDZiY2U=",
        "0256ce4a492726f7974cafe8ac0c6b52": "MDI1NmNlNGE0OTI3MjZmNzk3NGNhZmU4YWMwYzZiNTI=",
        "7fd3f9acfab25ddaad20c8acb5c9f50f": "N2ZkM2Y5YWNmYWIyNWRkYWFkMjBjOGFjYjVjOWY1MGY=",
        "132989d40603a8a27e34fed726e9aa14": "MTMyOTg5ZDQwNjAzYThhMjdlMzRmZWQ3MjZlOWFhMTQ=",
        "d41d8cd98f00b204e9800998ecf8427e": "ZDQxZDhjZDk4ZjAwYjIwNGU5ODAwOTk4ZWNmODQyN2U=",
        "04be349b3c0f2856b0074f9dc4824189": "MDRiZTM0OWIzYzBmMjg1NmIwMDc0ZjlkYzQ4MjQxODk=",
        "f54c237eca3ec015842d2946265847f7": "ZjU0YzIzN2VjYTNlYzAxNTg0MmQyOTQ2MjY1ODQ3Zjc=",
        "8a6e04352a288affc236f633ffeeaa5e": "ewogICJuYW1lIjogImF4IiwKICAidmVyc2lvbiI6ICIwLjEuOCIsCiAgImRlc2NyaXB0aW9uIjogIkEgc2ltcGxlIGxvZ2dlciIsCiAgImtleXdvcmRzIjogWwogICAgImxvZyIsCiAgICAibG9nZ2VyIgogIF0sCiAgImxpY2Vuc2VzIjogWwogICAgewogICAgICAidHlwZSI6ICJNSVQiLAogICAgICAidXJsIjogImh0dHBzOi8vZ2l0aHViLmNvbS9zcGlyZS1pby9heC9ibG9iL21hc3Rlci9SZWFkTWUubWQiCiAgICB9CiAgXSwKICAiaG9tZXBhZ2UiOiAiaHR0cHM6Ly9naXRodWIuY29tL3NwaXJlLWlvL2F4IiwKICAiYnVncyI6IHsKICAgICJ1cmwiOiAiaHR0cHM6Ly9naXRodWIuY29tL3NwaXJlLWlvL2F4L2lzc3VlcyIKICB9LAogICJhdXRob3IiOiB7CiAgICAibmFtZSI6ICJEYW4gWW9kZXIiLAogICAgImVtYWlsIjogImR5b2RlckBzcGlyZS5pbyIKICB9LAogICJtYWludGFpbmVycyI6IFsKICAgIHsKICAgICAgIm5hbWUiOiAiRGFuIFlvZGVyIiwKICAgICAgImVtYWlsIjogImR5b2RlckBzcGlyZS5pbyIKICAgIH0sCiAgICB7CiAgICAgICJuYW1lIjogIkphc29uIENhbXBiZWxsIiwKICAgICAgImVtYWlsIjogImphc29uQHNwaXJlLmlvIgogICAgfQogIF0sCiAgImNvbnRyaWJ1dG9ycyI6IFsKICAgIHsKICAgICAgIm5hbWUiOiAiRGFuIFlvZGVyIiwKICAgICAgImVtYWlsIjogImR5b2RlckBzcGlyZS5pbyIKICAgIH0sCiAgICB7CiAgICAgICJuYW1lIjogIkphc29uIENhbXBiZWxsIiwKICAgICAgImVtYWlsIjogImphc29uQHNwaXJlLmlvIgogICAgfSwKICAgIHsKICAgICAgIm5hbWUiOiAiQWF2ZWcgTWl0dGFsIiwKICAgICAgImVtYWlsIjogImFtaXR0YWxAc3BpcmUuaW8iCiAgICB9LAogICAgewogICAgICAibmFtZSI6ICJOaWtoaWwgUmF0YW4iLAogICAgICAiZW1haWwiOiAibnJhdGFuQHNwaXJlLmlvIgogICAgfSwKICAgIHsKICAgICAgIm5hbWUiOiAiTWF0dGhldyBLaW5nIiwKICAgICAgImVtYWlsIjogIm1raW5nQHNwaXJlLmlvIgogICAgfQogIF0sCiAgIm1haW4iOiAiLi9saWIvYXguanMiLAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiZ2l0Oi8vZ2l0aHViLmNvbS9zcGlyZS1pby9heC5naXQiCiAgfSwKICAiZGlyZWN0b3JpZXMiOiB7CiAgICAibGliIjogIi4vbGliIiwKICAgICJleGFtcGxlcyI6ICIuL2V4YW1wbGVzIgogIH0sCiAgImRlcGVuZGVuY2llcyI6IHt9LAogICJkZXZEZXBlbmRlbmNpZXMiOiB7CiAgICAiZG9jY28iOiAiMC4zLjAiLAogICAgInZvd3MiOiAiMC42LjEiLAogICAgImV4cHJlc3MiOiAiMi41LjYiLAogICAgImJyb3dzZXJpZnkiOiAiMS45LjIiLAogICAgInVnbGlmeS1qcyI6ICIxLjIuNSIKICB9LAogICJlbmdpbmUiOiAibm9kZSA+PSAwLjQuMTAiLAogICJyZWFkbWUiOiAiIyMgQXg6IFNpbXBsZSBMb2dnaW5nIFNlcnZjZVxuXG5BeCBwcm92aWRlcyBhIHZlcnkgc2ltcGxlIG11bHRpLWxldmVsIGxvZ2dpbmcgaW50ZXJmYWNlLlxuXG4gICAgdmFyIEF4ID0gcmVxdWlyZShcImF4XCIpO1xuICAgIHZhciBsb2dnZXIgPSBuZXcgQXgoe2xldmVsOiBcImRlYnVnXCIgfSk7XG5cbiAgICBsb2dnZXIuaW5mbyhcIkdyZWV0aW5ncywgUHJvZmVzc29yIEZhbGtlbi5cIik7XG4gICAgbG9nZ2VyLndhcm4oXCJXYXJuaW5nLCBXaWxsIFJvYmluc29uIVwiKTtcbiAgICBsb2dnZXIuZXJyb3IoXCJJZiBJIG1heSBzYXkgc28sIHNpciwgSSBub3RpY2VkIGVhcmxpZXIgdGhlIGh5cGVyZHJpdmVcIiArXG4gICAgICBcIiBtb3RpdmF0b3IgaGFzIGJlZW4gZGFtYWdlZC4gSXQncyBpbXBvc3NpYmxlIHRvIGdvIHRvIGxpZ2h0c3BlZWQuXCIpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkluc3RydW1lbnRzIHJlZ2lzdGVyIG9ubHkgdGhvc2UgdGhpbmdzIHRoZXkncmUgZGVzaWduZWQgdG9cIiArXG4gICAgICBcIiByZWdpc3Rlci4gU3BhY2Ugc3RpbGwgY29udGFpbnMgaW5maW5pdGUgdW5rbm93bnMuXCIpO1xuXG5Zb3UgY2FuIGFsc28gcGFzcyBhIGBmaWxlYCBvcHRpb24gdG8gbG9nIHRvIGEgZmlsZSBpbnN0ZWFkIG9mIGBzdGRvdXRgIGFuZCBgc3RkZXJyYC5cblxuIyBMaWNlbnNlXG5cbihUaGUgTUlUIExpY2Vuc2UpXG5cbkNvcHlyaWdodCAoYykgMjAxMiBEYW4gWW9kZXJcblBvcnRpb25zIENvcHlyaWdodCAoYykgMjAxMSBCb3JkZXIgU3R5bG9cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4iLAogICJfaWQiOiAiYXhAMC4xLjgiLAogICJfZnJvbSI6ICJheEAwLjEuOCIKfQo=",
        "f41fe98f55620bae34c8b5ce969028b8": "ZjQxZmU5OGY1NTYyMGJhZTM0YzhiNWNlOTY5MDI4Yjg=",
        "dc10a398e1e1237d5a4d2512cd4115e7": "ZGMxMGEzOThlMWUxMjM3ZDVhNGQyNTEyY2Q0MTE1ZTc=",
        "3a6e76760acad26f4fda49be6424ea8f": "M2E2ZTc2NzYwYWNhZDI2ZjRmZGE0OWJlNjQyNGVhOGY=",
        "2a1543839ac90d770378892878ea773a": "ewogICJhdXRob3IiOiB7CiAgICAibmFtZSI6ICJULiBKYW1lc29uIExpdHRsZSIsCiAgICAiZW1haWwiOiAidC5qYW1lc29uLmxpdHRsZUBnbWFpbC5jb20iCiAgfSwKICAibmFtZSI6ICJiYXNlNjQtanMiLAogICJkZXNjcmlwdGlvbiI6ICJCYXNlNjQgZW5jb2RpbmcvZGVjb2RpbmcgaW4gcHVyZSBKUyIsCiAgInZlcnNpb24iOiAiMC4wLjIiLAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiZ2l0Oi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2RlZmxhdGUtanMuZ2l0IgogIH0sCiAgIm1haW4iOiAibGliL2I2NC5qcyIsCiAgInNjcmlwdHMiOiB7CiAgICAidGVzdCI6ICJjZCB0ZXN0OyBub2RlIHJ1bm5lci5qczsgY2QgLSIKICB9LAogICJlbmdpbmVzIjogewogICAgIm5vZGUiOiAiPj0gMC40IgogIH0sCiAgImRlcGVuZGVuY2llcyI6IHt9LAogICJkZXZEZXBlbmRlbmNpZXMiOiB7fSwKICAicmVhZG1lIjogIkludHJvXG49PT09PVxuXG5gYmFzZTY0LWpzYCBkb2VzIGJhc2ljIGJhc2U2NCBlbmNvZGluZy9kZWNvZGluZyBpbiBwdXJlIEpTLiBNYW55IGJyb3dzZXJzIGFscmVhZHkgaGF2ZSB0aGlzIGZ1bmN0aW9uYWxpdHksIGJ1dCBpdCBpcyBmb3IgdGV4dCBkYXRhLCBub3QgYWxsLXB1cnBvc2UgYmluYXJ5IGRhdGEuXG5cblNvbWV0aW1lcyBlbmNvZGluZy9kZWNvZGluZyBiaW5hcnkgZGF0YSBpbiB0aGUgYnJvd3NlciBpcyB1c2VmdWwsIGFuZCB0aGF0IGlzIHdoYXQgdGhpcyBtb2R1bGUgZG9lcy5cblxuQVBJXG49PT1cblxuYGJhc2U2NC1qc2AgaGFzIHR3byBleHBvc2VkIGZ1bmN0aW9ucywgYHRvQnl0ZUFycmF5YCBhbmQgYGZyb21CeXRlQXJyYXlgLCB3aGljaCBib3RoIHRha2UgYSBzaW5nbGUgYXJndW1lbnQuXG5cbiogdG9CeXRlQXJyYXktIFRha2VzIGEgYmFzZTY0IHN0cmluZyBhbmQgcmV0dXJucyBhIGJ5dGUgYXJyYXlcbiogZnJvbUJ5dGVBcnJheS0gVGFrZXMgYSBieXRlIGFycmF5IGFuZCByZXR1cm5zIGEgYmFzZTY0IHN0cmluZ1xuIiwKICAicmVhZG1lRmlsZW5hbWUiOiAiUkVBRE1FLm1kIiwKICAiX2lkIjogImJhc2U2NC1qc0AwLjAuMiIsCiAgImRpc3QiOiB7CiAgICAic2hhc3VtIjogImY1Y2U0NGIzZDc4NDE3NDY5ZmYyNjE4MGNiYzIwOTI1OWVmNWZjNDIiCiAgfSwKICAiX2Zyb20iOiAiYmFzZTY0LWpzQDAuMC4yIiwKICAiX3Jlc29sdmVkIjogImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2Jhc2U2NC1qcy8tL2Jhc2U2NC1qcy0wLjAuMi50Z3oiCn0K",
        "cc3932b88baa5dd877931163f195d58e": "ewogICJuYW1lIjogImJ1ZmZlci1icm93c2VyaWZ5IiwKICAidmVyc2lvbiI6ICIwLjAuNSIsCiAgImRlc2NyaXB0aW9uIjogImJ1ZmZlciBtb2R1bGUgY29tcGF0aWJpbGl0eSBmb3IgYnJvd3NlcmlmeSIsCiAgIm1haW4iOiAiaW5kZXguanMiLAogICJicm93c2VyaWZ5IjogImluZGV4LmpzIiwKICAiZGlyZWN0b3JpZXMiOiB7CiAgICAidGVzdCI6ICJ0ZXN0IgogIH0sCiAgImRlcGVuZGVuY2llcyI6IHsKICAgICJiYXNlNjQtanMiOiAiMC4wLjIiCiAgfSwKICAiZGV2RGVwZW5kZW5jaWVzIjogewogICAgInRhcCI6ICIwLjIueCIKICB9LAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiaHR0cDovL2dpdGh1Yi5jb20vdG9vdHMvYnVmZmVyLWJyb3dzZXJpZnkuZ2l0IgogIH0sCiAgImtleXdvcmRzIjogWwogICAgImJ1ZmZlciIsCiAgICAiYnJvd3NlcmlmeSIsCiAgICAiY29tcGF0aWJsZSIsCiAgICAibWVhdGxlc3MiLAogICAgImJyb3dzZXIiCiAgXSwKICAiYXV0aG9yIjogewogICAgIm5hbWUiOiAiUm9tYWluIEJlYXV4aXMiLAogICAgImVtYWlsIjogInRvb3RzQHJhc3RhZ2Vla3Mub3JnIgogIH0sCiAgInNjcmlwdHMiOiB7CiAgICAidGVzdCI6ICJub2RlIG5vZGVfbW9kdWxlcy90YXAvYmluL3RhcC5qcyB0ZXN0LyouanMiCiAgfSwKICAibGljZW5zZSI6ICJNSVQvWDExIiwKICAiZW5naW5lIjogewogICAgIm5vZGUiOiAiPj0wLjYiCiAgfSwKICAicmVhZG1lIjogImJ1ZmZlci1icm93c2VyaWZ5XG49PT09PT09PT09PT09PT1cblxuVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBbbm9kZS5qc10oaHR0cDovL25vZGVqcy5vcmcvKSxcbmJ1dCBmb3IgYnJvd3NlcnMuXG5cbldoZW4geW91IGByZXF1aXJlKCdidWZmZXInKWAgaW5cblticm93c2VyaWZ5XShodHRwOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9ub2RlLWJyb3dzZXJpZnkpLFxudGhpcyBtb2R1bGUgd2lsbCBiZSBsb2FkZWQuXG5cbkl0IHdpbGwgYWxzbyBiZSBsb2FkZWQgaWYgeW91IHVzZSB0aGUgZ2xvYmFsIGBCdWZmZXJgIHZhcmlhYmxlLlxuIiwKICAicmVhZG1lRmlsZW5hbWUiOiAiUkVBRE1FLm1kIiwKICAiX2lkIjogImJ1ZmZlci1icm93c2VyaWZ5QDAuMC41IiwKICAiZGlzdCI6IHsKICAgICJzaGFzdW0iOiAiOTgzNDQ5NDk2ZjM4MmVjNjFmNTcwOGZmOWYyZDMxY2Y0NDRjODg4YiIKICB9LAogICJfZnJvbSI6ICJidWZmZXItYnJvd3NlcmlmeUAiLAogICJfcmVzb2x2ZWQiOiAiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvYnVmZmVyLWJyb3dzZXJpZnkvLS9idWZmZXItYnJvd3NlcmlmeS0wLjAuNS50Z3oiCn0K",
        "e926a8d145979e541da928088365eecf": "ZTkyNmE4ZDE0NTk3OWU1NDFkYTkyODA4ODM2NWVlY2Y=",
        "f0633c69e3137d9c641964c5b251e214": "ewogICJuYW1lIjogImNvb2tpZWphciIsCiAgInZlcnNpb24iOiAiMS4zLjAiLAogICJhdXRob3IiOiB7CiAgICAibmFtZSI6ICJicmFkbGV5bWVjayIKICB9LAogICJtYWluIjogImNvb2tpZWphci5qcyIsCiAgImRlc2NyaXB0aW9uIjogInNpbXBsZSBwZXJzaXN0ZW50IGNvb2tpZWphciBzeXN0ZW0iLAogICJyZWFkbWUiOiAiI0Nvb2tpZUphclxuXG5TaW1wbGUgcm9idXN0IGNvb2tpZSBsaWJyYXJ5XG5cbiMjRXhwb3J0c1xuXG5cbiMjI0Nvb2tpZUFjY2Vzc0luZm8oZG9tYWluLHBhdGgsc2VjdXJlLHNjcmlwdClcbiAgICBjbGFzcyB0byBkZXRlcm1pbmUgbWF0Y2hpbmcgcXVhbGl0aWVzIG9mIGEgY29va2llXG5cbiMjIyMjUHJvcGVydGllc1xuKiBTdHJpbmcgZG9tYWluIC0gZG9tYWluIHRvIG1hdGNoXG4qIFN0cmluZyBwYXRoIC0gcGF0aCB0byBtYXRjaFxuKiBCb29sZWFuIHNlY3VyZSAtIGFjY2VzcyBpcyBzZWN1cmUgKHNzbCBnZW5lcmFsbHkpXG4qIEJvb2xlYW4gc2NyaXB0IC0gYWNjZXNzIGlzIGZyb20gYSBzY3JpcHRcblxuXG4jIyNDb29raWUoY29va2llc3RyX29yX2Nvb2tpZSlcbiAgICB0dXJucyBpbnB1dCBpbnRvIGEgQ29va2llIChzaW5nbGV0b24gaWYgZ2l2ZW4gYSBDb29raWUpXG5cbiMjIyMjUHJvcGVydGllc1xuKiBTdHJpbmcgbmFtZSAtIG5hbWUgb2YgdGhlIGNvb2tpZVxuKiBTdHJpbmcgdmFsdWUgLSBzdHJpbmcgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb29raWVcbiogU3RyaW5nIGRvbWFpbiAtIGRvbWFpbiB0byBtYXRjaCAob24gYSBjb29raWUgYSAnLicgYXQgdGhlIHN0YXJ0IG1lYW5zIGEgd2lsZGNhcmQgbWF0Y2hpbmcgYW55dGhpbmcgZW5kaW5nIGluIHRoZSByZXN0KVxuKiBTdHJpbmcgcGF0aCAtIGJhc2UgcGF0aCB0byBtYXRjaCAobWF0Y2hlcyBhbnkgcGF0aCBzdGFydGluZyB3aXRoIHRoaXMgJy8nIGlzIHJvb3QpXG4qIEJvb2xlYW4gbm9zY3JpcHQgLSBpZiBpdCBzaG91bGQgYmUga2VwdCBmcm9tIHNjcmlwdHNcbiogQm9vbGVhbiBzZWN1cmUgLSBzaG91bGQgaXQgb25seSBiZSB0cmFuc21pdHRlZCBvdmVyIHNlY3VyZSBtZWFuc1xuKiBOdW1iZXIgZXhwaXJhdGlvbl9kYXRlIC0gbnVtYmVyIG9mIG1pbGxpcyBzaW5jZSAxOTcwIGF0IHdoaWNoIHRoaXMgc2hvdWxkIGJlIHJlbW92ZWRcblxuIyMjIyNNZXRob2RzXG4qIFN0cmluZyB0b1N0cmluZygpIC0gdGhlIF9fc2V0LWNvb2tpZTpfXyBzdHJpbmcgZm9yIHRoaXMgY29va2llXG4qIFN0cmluZyB0b1ZhbHVlU3RyaW5nKCkgLSB0aGUgX19jb29raWU6X18gc3RyaW5nIGZvciB0aGlzIGNvb2tpZVxuKiBDb29raWUgcGFyc2UoY29va2llc3RyKSAtIHBhcnNlcyB0aGUgc3RyaW5nIG9udG8gdGhpcyBjb29raWUgb3IgYSBuZXcgb25lIGlmIGNhbGxlZCBkaXJlY3RseVxuKiBCb29sZWFuIG1hdGNoZXMoYWNjZXNzX2luZm8pIC0gcmV0dXJucyB0cnVlIGlmIHRoZSBhY2Nlc3NfaW5mbyBhbGxvd3MgcmV0cmlldmFsIG9mIHRoaXMgY29va2llXG4qIEJvb2xlYW4gY29sbGlkZXNXaXRoKGNvb2tpZSkgLSByZXR1cm5zIHRydWUgaWYgdGhlIGNvb2tpZXMgY2Fubm90IGV4aXN0IGluIHRoZSBzYW1lIHNwYWNlIChkb21haW4gYW5kIHBhdGggbWF0Y2gpXG5cblxuIyMjQ29va2llSmFyKClcbiAgICBjbGFzcyB0byBob2xkIG51bWVyb3VzIGNvb2tpZXMgZnJvbSBtdWx0aXBsZSBkb21haW5zIGNvcnJlY3RseVxuXG4jIyMjI01ldGhvZHNcbiogQ29va2llIHNldENvb2tpZShjb29raWUpIC0gYWRkIGEgY29va2llIHRvIHRoZSBqYXJcbiogQ29va2llW10gc2V0Q29va2llcyhjb29raWVzdHJfb3JfbGlzdCkgLSBhZGQgYSBsYXJnZSBudW1iZXIgb2YgY29va2llcyB0byB0aGUgamFyXG4qIENvb2tpZSBnZXRDb29raWUoY29va2llX25hbWUsYWNjZXNzX2luZm8pIC0gZ2V0IGEgY29va2llIHdpdGggdGhlIG5hbWUgYW5kIGFjY2Vzc19pbmZvIG1hdGNoaW5nXG4qIENvb2tpZVtdIGdldENvb2tpZXMoYWNjZXNzX2luZm8pIC0gZ3JhYiBhbGwgY29va2llcyBtYXRjaGluZyB0aGlzIGFjY2Vzc19pbmZvIiwKICAiX2lkIjogImNvb2tpZWphckAxLjMuMCIsCiAgIl9mcm9tIjogImNvb2tpZWphckAxLjMueCIKfQo=",
        "972690d006842c98fda9e56ccf594a63": "OTcyNjkwZDAwNjg0MmM5OGZkYTllNTZjY2Y1OTRhNjM=",
        "8ecc84d18f299b5f78e4c72981dbe73b": "ewogICJuYW1lIjogInNwcmludGYiLAogICJ2ZXJzaW9uIjogIjAuMS4xIiwKICAiZW5naW5lcyI6IHsKICAgICJub2RlIjogIj49MC4yLjQiCiAgfSwKICAiYXV0aG9yIjogewogICAgIm5hbWUiOiAiTW9yaXR6IFBldGVycyIKICB9LAogICJkaXJlY3RvcmllcyI6IHsKICAgICJsaWIiOiAiLi9saWIiCiAgfSwKICAiZGVzY3JpcHRpb24iOiAiU3ByaW50ZigpIGZvciBub2RlLmpzIiwKICAibWFpbiI6ICIuL2xpYi9zcHJpbnRmIiwKICAicmVhZG1lIjogIiMgc3ByaW50ZigpIGZvciBub2RlXG5cbiMjIEluc3RhbGxcblxuICAgIG5wbSBpbnN0YWxsIHNwcmludGZcblxuIyMgSG93IHRvXG5cbldvcmtzIGV4YWN0bHkgbGlrZSBodHRwOi8vd3d3LmRpdmVpbnRvamF2YXNjcmlwdC5jb20vcHJvamVjdHMvamF2YXNjcmlwdC1zcHJpbnRmLCBleGNlcHQgdGhhdCBpdCBleHBvcnRzIHRob3NlIHR3byBmdW5jdGlvbnM6XG5cbiAgICBzcHJpbnRmID0gcmVxdXJpZSgnc3ByaW50ZicpLnNwcmludGY7XG4gICAgdnNwcmludGYgPSByZXF1aXJlKCdzcHJpbnRmJykudnNwcmludGY7XG5cbkhhdmUgZnVuIVxuIiwKICAiX2lkIjogInNwcmludGZAMC4xLjEiLAogICJfZnJvbSI6ICJzcHJpbnRmQDAuMS4xIgp9Cg==",
        "a089014e00fc816889fd3a26e987bdbd": "YTA4OTAxNGUwMGZjODE2ODg5ZmQzYTI2ZTk4N2JkYmQ=",
        "865b933cdca5bf49b1f012335b02ff93": "ODY1YjkzM2NkY2E1YmY0OWIxZjAxMjMzNWIwMmZmOTM=",
        "74c8622078cff87f7a2ddc5b866312ff": "ewogICJuYW1lIjogImNvbG9ycyIsCiAgImRlc2NyaXB0aW9uIjogImdldCBjb2xvcnMgaW4geW91ciBub2RlLmpzIGNvbnNvbGUgbGlrZSB3aGF0IiwKICAidmVyc2lvbiI6ICIwLjYuMC0xIiwKICAiYXV0aG9yIjogewogICAgIm5hbWUiOiAiTWFyYWsgU3F1aXJlcyIKICB9LAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiaHR0cDovL2dpdGh1Yi5jb20vTWFyYWsvY29sb3JzLmpzLmdpdCIKICB9LAogICJlbmdpbmVzIjogewogICAgIm5vZGUiOiAiPj0wLjEuOTAiCiAgfSwKICAibWFpbiI6ICJjb2xvcnMiLAogICJyZWFkbWUiOiAiIyBjb2xvcnMuanMgLSBnZXQgY29sb3IgYW5kIHN0eWxlIGluIHlvdXIgbm9kZS5qcyBjb25zb2xlICggYW5kIGJyb3dzZXIgKSBsaWtlIHdoYXRcblxuPGltZyBzcmM9XCJodHRwOi8vaS5pbWd1ci5jb20vZ29KZE8ucG5nXCIgYm9yZGVyID0gXCIwXCIvPlxuXG5cbiMjIEluc3RhbGxhdGlvblxuXG4gICAgbnBtIGluc3RhbGwgY29sb3JzXG5cbiMjIGNvbG9ycyBhbmQgc3R5bGVzIVxuXG4tIGJvbGRcbi0gaXRhbGljXG4tIHVuZGVybGluZVxuLSBpbnZlcnNlXG4tIHllbGxvd1xuLSBjeWFuXG4tIHdoaXRlXG4tIG1hZ2VudGFcbi0gZ3JlZW5cbi0gcmVkXG4tIGdyZXlcbi0gYmx1ZVxuLSByYWluYm93XG4tIHplYnJhXG4tIHJhbmRvbVxuXG4jIyBVc2FnZVxuXG5gYGAganNcbnZhciBjb2xvcnMgPSByZXF1aXJlKCcuL2NvbG9ycycpO1xuXG5jb25zb2xlLmxvZygnaGVsbG8nLmdyZWVuKTsgLy8gb3V0cHV0cyBncmVlbiB0ZXh0XG5jb25zb2xlLmxvZygnaSBsaWtlIGNha2UgYW5kIHBpZXMnLnVuZGVybGluZS5yZWQpIC8vIG91dHB1dHMgcmVkIHVuZGVybGluZWQgdGV4dFxuY29uc29sZS5sb2coJ2ludmVyc2UgdGhlIGNvbG9yJy5pbnZlcnNlKTsgLy8gaW52ZXJzZXMgdGhlIGNvbG9yXG5jb25zb2xlLmxvZygnT01HIFJhaW5ib3dzIScucmFpbmJvdyk7IC8vIHJhaW5ib3cgKGlnbm9yZXMgc3BhY2VzKVxuYGBgXG5cbiMgQ3JlYXRpbmcgQ3VzdG9tIHRoZW1lc1xuXG5gYGBqc1xuXG52YXIgcmVxdWlyZSgnY29sb3JzJyk7XG5cbmNvbG9ycy5zZXRUaGVtZSh7XG4gIHNpbGx5OiAncmFpbmJvdycsXG4gIGlucHV0OiAnZ3JleScsXG4gIHZlcmJvc2U6ICdjeWFuJyxcbiAgcHJvbXB0OiAnZ3JleScsXG4gIGluZm86ICdncmVlbicsXG4gIGRhdGE6ICdncmV5JyxcbiAgaGVscDogJ2N5YW4nLFxuICB3YXJuOiAneWVsbG93JyxcbiAgZGVidWc6ICdibHVlJyxcbiAgZXJyb3I6ICdyZWQnXG59KTtcblxuLy8gb3V0cHV0cyByZWQgdGV4dFxuY29uc29sZS5sb2coXCJ0aGlzIGlzIGFuIGVycm9yXCIuZXJyb3IpO1xuXG4vLyBvdXRwdXRzIHllbGxvdyB0ZXh0XG5jb25zb2xlLmxvZyhcInRoaXMgaXMgYSB3YXJuaW5nXCIud2Fybik7XG5gYGBcblxuXG4jIyMgQ29udHJpYnV0b3JzIFxuXG5NYXJhayAoTWFyYWsgU3F1aXJlcylcbkFsZXhpcyBTZWxsaWVyIChjbG91ZGhlYWQpXG5tbWFsZWNraSAoTWFjaWVqIE1hxYJlY2tpKVxubmljb3JlZWQgKE5pY28gUmVlZClcbm1vcmdhbnJhbGxlbiAoTW9yZ2FuIEFsbGVuKVxuSnVzdGluQ2FtcGJlbGwgKEp1c3RpbiBDYW1wYmVsbClcbmRlZCAoRHVzdGluIERpYXopXG5cblxuIyMjIyAgLCBNYXJhayBTcXVpcmVzICwgSnVzdGluIENhbXBiZWxsLCBEdXN0aW4gRGlheiAoQGRlZClcbiIsCiAgInJlYWRtZUZpbGVuYW1lIjogIlJlYWRNZS5tZCIsCiAgIl9pZCI6ICJjb2xvcnNAMC42LjAtMSIsCiAgIl9mcm9tIjogImNvbG9yc0AwLjYueCIKfQo=",
        "c3451fe7035e99947143be3e88c3eaef": "YzM0NTFmZTcwMzVlOTk5NDcxNDNiZTNlODhjM2VhZWY=",
        "d7c4041289e5445eec291db26b21409d": "ZDdjNDA0MTI4OWU1NDQ1ZWVjMjkxZGIyNmIyMTQwOWQ=",
        "e241c1de18faf4151605d7b35b8b9eab": "ewogICJuYW1lIjogIm1pbmZpbml0ZSIsCiAgInZlcnNpb24iOiAiMC4xLjAiLAogICJkZXNjcmlwdGlvbiI6ICJNaW5pbWFsIEZTTSBjbGFzcyIsCiAgImF1dGhvciI6IHsKICAgICJuYW1lIjogIk1hdHRoZXcgS2luZyIsCiAgICAiZW1haWwiOiAiYXV0b21hdHRoZXdAZ21haWwuY29tIgogIH0sCiAgIm1haW4iOiAibWluZmluaXRlLmpzIiwKICAiZmlsZXMiOiBbCiAgICAibWluZmluaXRlLmpzIgogIF0sCiAgInNjcmlwdHMiOiB7fSwKICAicmVwb3NpdG9yeSI6IHsKICAgICJ0eXBlIjogImdpdCIsCiAgICAidXJsIjogImdpdEBnaXRodWIuY29tOmF1dG9tYXR0aGV3L21pbmZpbml0ZS5naXQiCiAgfSwKICAiaG9tZXBhZ2UiOiAiaHR0cHM6Ly9naXRodWIuY29tL2F1dG9tYXR0aGV3L21pbmZpbml0ZSIsCiAgImtleXdvcmRzIjogWwogICAgImZzbSIsCiAgICAic3RhdGUgbWFjaGluZSIKICBdLAogICJsaWNlbnNlIjogIk1JVCIsCiAgIl9pZCI6ICJtaW5maW5pdGVAMC4xLjAiLAogICJyZWFkbWUiOiAiRVJST1I6IE5vIFJFQURNRS5tZCBmaWxlIGZvdW5kISIsCiAgIl9mcm9tIjogIm1pbmZpbml0ZUAwLjEueCIKfQo=",
        "8c37014c53ded1aa3e3c6fea2b7b527f": "ewogICJuYW1lIjogInRlc3RpZnkiLAogICJ2ZXJzaW9uIjogIjAuMi4zIiwKICAiZGVzY3JpcHRpb24iOiAic2ltcGxlIGFzeW5jaHJvbm91cyB0ZXN0aW5nIHVzaW5nIGFzc2VydGlvbnMgb2YgeW91ciBjaG9pY2UiLAogICJtYWluIjogInNyYy90ZXN0aWZ5LmNvZmZlZSIsCiAgImJpbiI6IHsKICAgICJ0ZXN0aWZ5IjogImJpbi90ZXN0aWZ5IgogIH0sCiAgImZpbGVzIjogWwogICAgInNyYyIsCiAgICAiYmluLyIsCiAgICAiUkVBRE1FLm1kIiwKICAgICJzdGF0aXN0aWNzLmpzIgogIF0sCiAgImRlcGVuZGVuY2llcyI6IHsKICAgICJvcHRpbWlzdCI6ICIwLjMuNSIsCiAgICAibWljcm90aW1lIjogIjAuMy4zIiwKICAgICJjb2xvcnMiOiAiMC42LngiLAogICAgIm1pbmZpbml0ZSI6ICIwLjEueCIKICB9LAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiZ2l0QGdpdGh1Yi5jb206YXV0b21hdHRoZXcvdGVzdGlmeS5naXQiCiAgfSwKICAiYXV0aG9yIjogewogICAgIm5hbWUiOiAiTWF0dGhldyBLaW5nIiwKICAgICJlbWFpbCI6ICJhdXRvbWF0dGhld0BnbWFpbC5jb20iCiAgfSwKICAibGljZW5zZSI6ICJNSVQiLAogICJyZWFkbWUiOiAiIyBUZXN0aWZ5XG5cblNpbXBsZSBhc3luY2hyb25vdXMgdGVzdGluZywgdXNpbmcgdGhlIGFzc2VydGlvbnMgb2YgeW91ciBjaG9pY2UuXG5cbldyaXR0ZW4gKGFuZCBtb3N0IGVhc2lseSB1c2VkKSBpbiBDb2ZmZWVTY3JpcHQuXG5cblxuIyMgQmFzaWMgdXNhZ2VcblxuYGBgY29mZmVlXG5cblRlc3RpZnkudGVzdCBcImEgc3VpdGUgb2YgdGVzdHNcIiwgKGNvbnRleHQpIC0+XG5cbiAgIyBXaGVuIHlvdSBuZWVkIHRvIHRlc3QgdGhlIHJlc3VsdHMgb2YgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLFxuICAjIGdpdmUgY29udGV4dC50ZXN0KCkgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGFyZ3VtZW50LiAgWW91IGNhblxuICAjIHRoZW4gdXNlIHRoYXQgYXJndW1lbnQgYXMgYSBuZXcgY29udGV4dCBmb3IgbmVzdGluZyB0ZXN0cy5cbiAgY29udGV4dC50ZXN0IFwidGVzdGluZyBzb21ldGhpbmcgYXN5bmNocm9ub3VzXCIsIChjb250ZXh0KSAtPlxuXG4gICAgc29tZV9hc3luY19jYWxsIChlcnJvciwgcmVzdWx0MSkgLT5cblxuICAgICAgIyBJZiB5b3UgZ2l2ZSBjb250ZXh0LnRlc3QoKSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRzLFxuICAgICAgIyB0aGUgdGVzdCBpcyByZXF1aXJlZCB0byBiZSBzeW5jaHJvbm91cywgYW5kIGNvbnNpZGVyZWQgdG8gaGF2ZVxuICAgICAgIyBwYXNzZWQgaWYgdGhlIGZ1bmN0aW9uIHJ1bnMgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgIGNvbnRleHQudGVzdCBcInJlc3VsdCBtYWtlcyBtZSBoYXBweVwiLCAtPlxuICAgICAgICBhc3NlcnQuaWZFcnJvcihlcnJvcilcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdDEsIFwicGllXCIpXG5cbiAgICAgIGNvbnRleHQudGVzdCBcImEgbmVzdGVkIGFzeW5jaHJvbm91cyB0ZXN0XCIsIChjb250ZXh0KSAtPlxuXG4gICAgICAgIGFub3RoZXJfYXN5bmNfY2FsbCByZXN1bHQxLCAgKGVycm9yLCByZXN1bHQyKSAtPlxuXG4gICAgICAgICAgY29udGV4dC50ZXN0IFwicmVzdWx0IG1ha2VzIG1lIGRlZXBseSBoYXBweVwiLCAtPlxuICAgICAgICAgICAgYXNzZXJ0LmlmRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsIHJlc3VsdDIsIFtcImJhY29uXCIsIFwiY2hlZXNlXCIsIFwicGllXCJdXG5cbiAgICAgIGNvbnRleHQudGVzdCBcInNob3J0Y3V0IGZvciBwYXNzaW5nIGFuIGFzeW5jIHRlc3RcIiwgKGNvbnRleHQpIC0+XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sgLT5cbiAgICAgICAgICAjIHlvdSBjYW4gY2FsbCBjb250ZXh0LnBhc3MoKSBpbnN0ZWFkIG9mIHVzaW5nIGEgc3luY2hyb25vdXMgdGVzdFxuICAgICAgICAgIGNvbnRleHQucGFzcygpXG5cbiAgICAgIGNvbnRleHQudGVzdCBcInNob3J0Y3V0IGZvciBmYWlsaW5nIGFuIGFzeW5jIHRlc3RcIiwgKGNvbnRleHQpIC0+XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sgLT5cbiAgICAgICAgICBjb250ZXh0LmZhaWwoKVxuXG5gYGBcblxuUnVuIHlvdXIgdGVzdCBmaWxlcyB3aXRoIHRoZSBgY29mZmVlYCBleGVjdXRhYmxlLCBvciBieSByZXF1aXJpbmcgdGhlbS5cblxuICAgIGNvZmZlZSBwYXRoL3RvL3Rlc3QuY29mZmVlXG5cbiMjIEV4YW1wbGVzXG5cbltUZXN0aW5nIHRoZSBTaHJlZCBIVFRQIGNsaWVudF0oaHR0cHM6Ly9naXRodWIuY29tL2F1dG9tYXR0aGV3L3NocmVkL2Jsb2IvbWFzdGVyL3Rlc3Qvc2hyZWRfdGVzdC5jb2ZmZWUpXG5cbllvdSBjYW4gYWxzbyB1c2UgdGVzdCBuZXN0aW5nIHdpdGggZW50aXJlbHkgc3luY2hyb25vdXMgd29yaywgYXMgYSB3YXkgdG8gc3RydWN0dXJlIHRoZVxudGVzdCByZXN1bHRzOlxuXG5bU2hyZWQncyBoZWFkZXIgcHJvY2Vzc2luZyB0ZXN0XShodHRwczovL2dpdGh1Yi5jb20vYXV0b21hdHRoZXcvc2hyZWQvYmxvYi9tYXN0ZXIvdGVzdC9oZWFkZXJzX3Rlc3QuY29mZmVlKVxuXG5cblxuIiwKICAicmVhZG1lRmlsZW5hbWUiOiAiUkVBRE1FLm1kIiwKICAiX2lkIjogInRlc3RpZnlAMC4yLjMiLAogICJkaXN0IjogewogICAgInNoYXN1bSI6ICIwZDBjNzllYTM5ZjkxMGYyODNmODY3YmU3YTQyYzI2Y2Q5MmMyMTBjIgogIH0sCiAgIl9mcm9tIjogIi9Vc2Vycy9tYXR0aGV3L3Byb2plY3RzL29zcy90ZXN0aWZ5LyIKfQo=",
        "e771513490ac1884ffed5cef377b37be": "ZTc3MTUxMzQ5MGFjMTg4NGZmZWQ1Y2VmMzc3YjM3YmU=",
        "1f082de170804a1f8caa134abdafdb55": "MWYwODJkZTE3MDgwNGExZjhjYWExMzRhYmRhZmRiNTU=",
        "7abe6dc3c91fe653e9c4a2d096ee8684": "N2FiZTZkYzNjOTFmZTY1M2U5YzRhMmQwOTZlZTg2ODQ=",
        "62e49fef2333868ff4848cf4ec8f121d": "NjJlNDlmZWYyMzMzODY4ZmY0ODQ4Y2Y0ZWM4ZjEyMWQ=",
        "1acd0107c78da6657c2d635a044b63b7": "MWFjZDAxMDdjNzhkYTY2NTdjMmQ2MzVhMDQ0YjYzYjc=",
        "d5618ac652297a3b9b8a6b6a4104f37b": "ZDU2MThhYzY1MjI5N2EzYjliOGE2YjZhNDEwNGYzN2I=",
        "fa53c363771d2457d1828de9260428b1": "ewogICAibmFtZSI6ICJzaHJlZCIsCiAgICJ2ZXJzaW9uIjogIjAuOC44IiwKICAgImRlc2NyaXB0aW9uIjogIkEgc2ltcGxlIEhUVFAgY2xpZW50IGZvciBub2RlanMgYW5kIGJyb3dzZXJzLiAgU3VwcG9ydHMgZ3ppcCwgY29va2llcywgcmVkaXJlY3RzLCBhbmQgaHR0cHMuIiwKICAgImtleXdvcmRzIjpbCiAgICAgICJodHRwIiwKICAgICAgImNsaWVudCIKICAgXSwKICAgImxpY2Vuc2VzIjpbCiAgICAgIHsKICAgICAgICAgInR5cGUiOiAiTUlUIiwKICAgICAgICAgInVybCI6ICJodHRwczovL2dpdGh1Yi5jb20vYXV0b21hdHRoZXcvc2hyZWQvYmxvYi9tYXN0ZXIvTElDRU5TRSIKICAgICAgfQogICBdLAogICAiaG9tZXBhZ2UiOiAiaHR0cHM6Ly9naXRodWIuY29tL2F1dG9tYXR0aGV3L3NocmVkIiwKICAgImJ1Z3MiOiB7CiAgICAgICJ1cmwiOiAiaHR0cHM6Ly9naXRodWIuY29tL2F1dG9tYXR0aGV3L3NocmVkL2lzc3VlcyIKICAgfSwKICAgImF1dGhvciI6IHsKICAgICAgIm5hbWUiOiAiRGFuIFlvZGVyIiwKICAgICAgImVtYWlsIjogImRhbkBzcGlyZS5pbyIKICAgfSwKICAgIm1haW50YWluZXJzIjpbCiAgICAgIHsgIm5hbWUiOiAiRGFuIFlvZGVyIiwgImVtYWlsIjogImRhbkBzcGlyZS5pbyIgfSwKICAgICAgeyAibmFtZSI6ICJKYXNvbiBDYW1wYmVsbCIsICJlbWFpbCI6ICJqYXNvbkBzcGlyZS5pbyIgfSwKICAgICAgeyAibmFtZSI6ICJNYXR0aGV3IEtpbmciLCAiZW1haWwiOiAibWtpbmdAc3BpcmUuaW8iIH0sCiAgICAgIHsgIm5hbWUiOiAiTmljb2xhcyBMYUNhc3NlIiwgImVtYWlsIjogIm5pY29sYXNAc3BpcmUuaW8iIH0KICAgXSwKICAgImNvbnRyaWJ1dG9ycyI6WwogICAgICB7ICJuYW1lIjogIkRhbiBZb2RlciIsICJlbWFpbCI6ICJkeW9kZXJAc3BpcmUuaW8iIH0sCiAgICAgIHsgIm5hbWUiOiAiSmFzb24gQ2FtcGJlbGwiLCAiZW1haWwiOiAiamFzb25Ac3BpcmUuaW8iIH0sCiAgICAgIHsgIm5hbWUiOiAiTWF0dGhldyBLaW5nIiwgImVtYWlsIjogIm1raW5nQHNwaXJlLmlvIiB9LAogICAgICB7ICJuYW1lIjogIkFuZHkgQnVya2UiLCAiZW1haWwiOiAiYWJ1cmtlQGJpdGZsb29kLm9yZyIgfQogICBdLAogICAibWFpbiI6ICIuL2xpYi9zaHJlZC5qcyIsCiAgICJyZXBvc2l0b3J5IjogewogICAgICAidHlwZSI6ICJnaXQiLAogICAgICAidXJsIjogImdpdDovL2dpdGh1Yi5jb20vYXV0b21hdHRoZXcvc2hyZWQuZ2l0IgogICB9LAogICAiZmlsZXMiOiBbCiAgICAibGliIgogICBdLAogICAiZGVwZW5kZW5jaWVzIjogewogICAgICAic3ByaW50ZiI6ICIwLjEuMSIsCiAgICAgICJheCI6ICIwLjEuOCIsCiAgICAgICJjb29raWVqYXIiOiAiMS4zLngiLAogICAgICAiaWNvbnYtbGl0ZSI6ICI+PSAwLjEuMiIKICAgfSwKICAgImRldkRlcGVuZGVuY2llcyI6IHsKICAgICAgImV4cHJlc3MiOiAiMi41LjEwIiwKICAgICAgInRlc3RpZnkiOiAiMC4yLngiLAogICAgICAicmVwaHJhc2VyIjogIj49IDAuMS42IiwKICAgICAgImRvY2NvIjogIj49IDAuMy4wIgogICB9LAogICJzY3JpcHRzIjogewogICAgInRlc3QiOiAiY2FrZSB0ZXN0IgogIH0sCiAgICJlbmdpbmUiOiAibm9kZSA+PSAwLjgueCIKfQoK",
        "472824fe00f2d2075a0fbd3267b79538": "NDcyODI0ZmUwMGYyZDIwNzVhMGZiZDMyNjdiNzk1Mzg=",
        "de6f3ec27408aa6c2dbef934db6778ac": "ZGU2ZjNlYzI3NDA4YWE2YzJkYmVmOTM0ZGI2Nzc4YWM=",
        "e938fbd381641c5df05e3419364a31b8": "ZTkzOGZiZDM4MTY0MWM1ZGYwNWUzNDE5MzY0YTMxYjg=",
        "e8b753db709b5ef4915068e0925367dc": "ZThiNzUzZGI3MDliNWVmNDkxNTA2OGUwOTI1MzY3ZGM=",
        "43dfb23f47862a3f4f5b2ac8879a2729": "NDNkZmIyM2Y0Nzg2MmEzZjRmNWIyYWM4ODc5YTI3Mjk=",
        "b025a4ec5f8e8625d8be4f61ef482b60": "YjAyNWE0ZWM1ZjhlODYyNWQ4YmU0ZjYxZWY0ODJiNjA=",
        "aa29b8a06095dd170e247794b8ea185c": "YWEyOWI4YTA2MDk1ZGQxNzBlMjQ3Nzk0YjhlYTE4NWM=",
        "d139b7f6fb5124550603cac960ba5039": "ewogICJuYW1lIjogInNocmVkLWJyb3dzZXItdGVzdHMiLAogICJ2ZXJzaW9uIjogIjAuMS4wIiwKICAiZGVzY3JpcHRpb24iOiAiVGVzdGlmeSBpbiB0aGUgYnJvd3NlciIsCiAgIm1haW4iOiAiYXBwbGljYXRpb24uY29mZmVlIiwKICAicmVwb3NpdG9yeSI6ICIiLAogICJhdXRob3IiOiAiTWF0dGhldyBLaW5nIiwKICAibGljZW5zZSI6ICJNSVQiLAogICJkZXBlbmRlbmNpZXMiOiB7CiAgICAidGVzdGlmeSI6ICIwLjIueCIsCiAgICAic2hyZWQiOiAiMC44LngiCiAgfQp9Cgo=",
        "7c6f94265ce22f5ba1d0be971c82b6a2": "N2M2Zjk0MjY1Y2UyMmY1YmExZDBiZTk3MWM4MmI2YTI=",
        "70163b46f8555ff67c92083cf367db04": "NzAxNjNiNDZmODU1NWZmNjdjOTIwODNjZjM2N2RiMDQ=",
        "e7b0a85973e60e50391916726b0eac62": "ZTdiMGE4NTk3M2U2MGU1MDM5MTkxNjcyNmIwZWFjNjI=",
        "8d54b30e151e0c43af3ec7bcd718de7b": "OGQ1NGIzMGUxNTFlMGM0M2FmM2VjN2JjZDcxOGRlN2I=",
        "c4f9141dbd0d7a4e3dd3d1dc0a64c667": "YzRmOTE0MWRiZDBkN2E0ZTNkZDNkMWRjMGE2NGM2Njc=",
        "0426b7a6289080ce650637f0ac6e7e0c": "MDQyNmI3YTYyODkwODBjZTY1MDYzN2YwYWM2ZTdlMGM=",
        "a8aae685be6eeb8ec844ae9c4f5fd189": "YThhYWU2ODViZTZlZWI4ZWM4NDRhZTljNGY1ZmQxODk=",
        "b499eb63a89b9e6fb99ef1209a65ace6": "YjQ5OWViNjNhODliOWU2ZmI5OWVmMTIwOWE2NWFjZTY=",
        "4b089ad1310f754af3510dd2da9a1ff7": "NGIwODlhZDEzMTBmNzU0YWYzNTEwZGQyZGE5YTFmZjc=",
        "5d6e2c2d895132330e91af96bc1409c7": "NWQ2ZTJjMmQ4OTUxMzIzMzBlOTFhZjk2YmMxNDA5Yzc=",
        "8f99cc2b75044ae1f45cefc6948e42b3": "OGY5OWNjMmI3NTA0NGFlMWY0NWNlZmM2OTQ4ZTQyYjM=",
        "223f09f17e4aff9f2d05493c688f7934": "MjIzZjA5ZjE3ZTRhZmY5ZjJkMDU0OTNjNjg4Zjc5MzQ=",
        "7b51c3f0555ccb0c0f1fcd91d389ea1a": "N2I1MWMzZjA1NTVjY2IwYzBmMWZjZDkxZDM4OWVhMWE=",
        "54c69a095dc8e4a9173bd8284c4e8ad7": "NTRjNjlhMDk1ZGM4ZTRhOTE3M2JkODI4NGM0ZThhZDc=",
        "f0d5935f094eb3d9fb70c67795bd4caf": "ZjBkNTkzNWYwOTRlYjNkOWZiNzBjNjc3OTViZDRjYWY=",
        "4e0d787840f05b0c47b10d63b6f3898f": "NGUwZDc4Nzg0MGYwNWIwYzQ3YjEwZDYzYjZmMzg5OGY=",
        "12124e45d125f26e20242c0e81a80f19": "MTIxMjRlNDVkMTI1ZjI2ZTIwMjQyYzBlODFhODBmMTk=",
        "d0c9d6cc2490c964b789d43ae4803b7b": "ZDBjOWQ2Y2MyNDkwYzk2NGI3ODlkNDNhZTQ4MDNiN2I=",
        "ddeff58ff67e5d2d686891fc66ebb2b7": "ZGRlZmY1OGZmNjdlNWQyZDY4Njg5MWZjNjZlYmIyYjc="
      },
      native_modules: {
        "assert": "c4f9141dbd0d7a4e3dd3d1dc0a64c667",
        "child_process": "0426b7a6289080ce650637f0ac6e7e0c",
        "crypto": "a8aae685be6eeb8ec844ae9c4f5fd189",
        "events": "b499eb63a89b9e6fb99ef1209a65ace6",
        "fs": "4b089ad1310f754af3510dd2da9a1ff7",
        "http": "5d6e2c2d895132330e91af96bc1409c7",
        "https": "8f99cc2b75044ae1f45cefc6948e42b3",
        "module": "223f09f17e4aff9f2d05493c688f7934",
        "path": "7b51c3f0555ccb0c0f1fcd91d389ea1a",
        "querystring": "54c69a095dc8e4a9173bd8284c4e8ad7",
        "stream": "f0d5935f094eb3d9fb70c67795bd4caf",
        "sys": "4e0d787840f05b0c47b10d63b6f3898f",
        "tty": "12124e45d125f26e20242c0e81a80f19",
        "url": "d0c9d6cc2490c964b789d43ae4803b7b",
        "util": "ddeff58ff67e5d2d686891fc66ebb2b7"
      },
      module_functions: {
        "834df2a902f4f1b69321d43c010dcb08": // from: browser/shred.bundle.js
        function(exports, require, module, __filename, __dirname) {
          var require = function(file, cwd) {
            var resolved = require.resolve(file, cwd || '/');
            var mod = require.modules[resolved];
            if (!mod) throw new Error('Failed to resolve module ' + file + ', tried ' + resolved);
            var res = mod._cached ? mod._cached : mod();
            return res;
          }

          require.paths = [];
          require.modules = {};
          require.extensions = [".js", ".coffee"];

          require._core = {
            'assert': true,
            'events': true,
            'fs': true,
            'path': true,
            'vm': true
          };

          require.resolve = (function() {
            return function(x, cwd) {
              if (!cwd) cwd = '/';

              if (require._core[x]) return x;
              var path = require.modules.path();
              var y = cwd || '.';

              if (x.match(/^(?:\.\.?\/|\/)/)) {
                var m = loadAsFileSync(path.resolve(y, x)) || loadAsDirectorySync(path.resolve(y, x));
                if (m) return m;
              }

              var n = loadNodeModulesSync(x, y);
              if (n) return n;

              throw new Error("Cannot find module '" + x + "'");

              function loadAsFileSync(x) {
                if (require.modules[x]) {
                  return x;
                }

                for (var i = 0; i < require.extensions.length; i++) {
                  var ext = require.extensions[i];
                  if (require.modules[x + ext]) return x + ext;
                }
              }

              function loadAsDirectorySync(x) {
                x = x.replace(/\/+$/, '');
                var pkgfile = x + '/package.json';
                if (require.modules[pkgfile]) {
                  var pkg = require.modules[pkgfile]();
                  var b = pkg.browserify;
                  if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                  } else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                  } else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                  }
                }

                return loadAsFileSync(x + '/index');
              }

              function loadNodeModulesSync(x, start) {
                var dirs = nodeModulesPathsSync(start);
                for (var i = 0; i < dirs.length; i++) {
                  var dir = dirs[i];
                  var m = loadAsFileSync(dir + '/' + x);
                  if (m) return m;
                  var n = loadAsDirectorySync(dir + '/' + x);
                  if (n) return n;
                }

                var m = loadAsFileSync(x);
                if (m) return m;
              }

              function nodeModulesPathsSync(start) {
                var parts;
                if (start === '/') parts = [''];
                else parts = path.normalize(start).split('/');

                var dirs = [];
                for (var i = parts.length - 1; i >= 0; i--) {
                  if (parts[i] === 'node_modules') continue;
                  var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                  dirs.push(dir);
                }

                return dirs;
              }
            };
          })();

          require.alias = function(from, to) {
            var path = require.modules.path();
            var res = null;
            try {
              res = require.resolve(from + '/package.json', '/');
            } catch (err) {
              res = require.resolve(from, '/');
            }
            var basedir = path.dirname(res);

            var keys = (Object.keys || function(obj) {
              var res = [];
              for (var key in obj) res.push(key)
              return res;
            })(require.modules);

            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key.slice(0, basedir.length + 1) === basedir + '/') {
                var f = key.slice(basedir.length);
                require.modules[to + f] = require.modules[basedir + f];
              } else if (key === basedir) {
                require.modules[to] = require.modules[basedir];
              }
            }
          };

          require.define = function(filename, fn) {
            var dirname = require._core[filename] ? '' : require.modules.path().dirname(filename);

            var require_ = function(file) {
              return require(file, dirname)
            };
            require_.resolve = function(name) {
              return require.resolve(name, dirname);
            };
            require_.modules = require.modules;
            require_.define = require.define;
            var module_ = {
              exports: {}
            };

            require.modules[filename] = function() {
              require.modules[filename]._cached = module_.exports;
              fn.call(
              module_.exports,
              require_,
              module_,
              module_.exports,
              dirname,
              filename);
              require.modules[filename]._cached = module_.exports;
              return module_.exports;
            };
          };

          if (typeof process === 'undefined') process = {};

          if (!process.nextTick) process.nextTick = (function() {
            var queue = [];
            var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;

            if (canPost) {
              window.addEventListener('message', function(ev) {
                if (ev.source === window && ev.data === 'browserify-tick') {
                  ev.stopPropagation();
                  if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                  }
                }
              }, true);
            }

            return function(fn) {
              if (canPost) {
                queue.push(fn);
                window.postMessage('browserify-tick', '*');
              } else setTimeout(fn, 0);
            };
          })();

          if (!process.title) process.title = 'browser';

          if (!process.binding) process.binding = function(name) {
            if (name === 'evals') return require('vm')
            else throw new Error('No such module')
          };

          if (!process.cwd) process.cwd = function() {
            return '.'
          };

          require.define("path", function(require, module, exports, __dirname, __filename) {
            function filter(xs, fn) {
              var res = [];
              for (var i = 0; i < xs.length; i++) {
                if (fn(xs[i], i, xs)) res.push(xs[i]);
              }
              return res;
            }

            // resolves . and .. elements in a path array with directory names there
            // must be no slashes, empty elements, or device names (c:\) in the array
            // (so also no leading and trailing slashes - it does not distinguish
            // relative and absolute paths)
            function normalizeArray(parts, allowAboveRoot) {
              // if the path tries to go above the root, `up` ends up > 0
              var up = 0;
              for (var i = parts.length; i >= 0; i--) {
                var last = parts[i];
                if (last == '.') {
                  parts.splice(i, 1);
                } else if (last === '..') {
                  parts.splice(i, 1);
                  up++;
                } else if (up) {
                  parts.splice(i, 1);
                  up--;
                }
              }

              // if the path is allowed to go above the root, restore leading ..s
              if (allowAboveRoot) {
                for (; up--; up) {
                  parts.unshift('..');
                }
              }

              return parts;
            }

            // Regex to split a filename into [*, dir, basename, ext]
            // posix version
            var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

            // path.resolve([from ...], to)
            // posix version
            exports.resolve = function() {
              var resolvedPath = '',
                resolvedAbsolute = false;

              for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
                var path = (i >= 0) ? arguments[i] : process.cwd();

                // Skip empty and invalid entries
                if (typeof path !== 'string' || !path) {
                  continue;
                }

                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charAt(0) === '/';
              }

              // At this point the path should be resolved to a full absolute path, but
              // handle relative paths to be safe (might happen when process.cwd() fails)

              // Normalize the path
              resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
                return !!p;
              }), !resolvedAbsolute).join('/');

              return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
            };

            // path.normalize(path)
            // posix version
            exports.normalize = function(path) {
              var isAbsolute = path.charAt(0) === '/',
                trailingSlash = path.slice(-1) === '/';

              // Normalize the path
              path = normalizeArray(filter(path.split('/'), function(p) {
                return !!p;
              }), !isAbsolute).join('/');

              if (!path && !isAbsolute) {
                path = '.';
              }
              if (path && trailingSlash) {
                path += '/';
              }

              return (isAbsolute ? '/' : '') + path;
            };


            // posix version
            exports.join = function() {
              var paths = Array.prototype.slice.call(arguments, 0);
              return exports.normalize(filter(paths, function(p, index) {
                return p && typeof p === 'string';
              }).join('/'));
            };


            exports.dirname = function(path) {
              var dir = splitPathRe.exec(path)[1] || '';
              var isWindows = false;
              if (!dir) {
                // No dirname
                return '.';
              } else if (dir.length === 1 || (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
                // It is just a slash or a drive letter with a slash
                return dir;
              } else {
                // It is a full dirname, strip trailing slash
                return dir.substring(0, dir.length - 1);
              }
            };


            exports.basename = function(path, ext) {
              var f = splitPathRe.exec(path)[2] || '';
              // TODO: make this comparison case-insensitive on windows?
              if (ext && f.substr(-1 * ext.length) === ext) {
                f = f.substr(0, f.length - ext.length);
              }
              return f;
            };


            exports.extname = function(path) {
              return splitPathRe.exec(path)[3] || '';
            };

          });

          require.define("/shred.js", function(require, module, exports, __dirname, __filename) {
            // Shred is an HTTP client library intended to simplify the use of Node's
            // built-in HTTP library. In particular, we wanted to make it easier to interact
            // with HTTP-based APIs.
            // 
            // See the [examples](./examples.html) for more details.

            // Ax is a nice logging library we wrote. You can use any logger, providing it
            // has `info`, `warn`, `debug`, and `error` methods that take a string.
            var Ax = require("ax"),
              CookieJarLib = require("cookiejar"),
              CookieJar = CookieJarLib.CookieJar;

            // Shred takes some options, including a logger and request defaults.

            var Shred = function(options) {
              options = (options || {});
              this.agent = options.agent;
              this.defaults = options.defaults || {};
              this.log = options.logger || (new Ax({
                level: "info"
              }));
              this._sharedCookieJar = new CookieJar();
              this.logCurl = options.logCurl || false;
            };

            // Most of the real work is done in the request and reponse classes.

            Shred.Request = require("./shred/request");
            Shred.Response = require("./shred/response");

            // The `request` method kicks off a new request, instantiating a new `Request`
            // object and passing along whatever default options we were given.

            Shred.prototype = {
              request: function(options) {
                options.logger = this.log;
                options.logCurl = options.logCurl || this.logCurl;
                options.cookieJar = ('cookieJar' in options) ? options.cookieJar : this._sharedCookieJar; // let them set cookieJar = null
                options.agent = options.agent || this.agent;
                // fill in default options
                for (var key in this.defaults) {
                  if (this.defaults.hasOwnProperty(key) && !options[key]) {
                    options[key] = this.defaults[key]
                  }
                }
                return new Shred.Request(options);
              }
            };

            // Define a bunch of convenience methods so that you don't have to include
            // a `method` property in your request options.

            "get put post delete".split(" ").forEach(function(method) {
              Shred.prototype[method] = function(options) {
                options.method = method;
                return this.request(options);
              };
            });


            module.exports = Shred;

          });

          require.define("/node_modules/ax/package.json", function(require, module, exports, __dirname, __filename) {
            module.exports = {
              "main": "./lib/ax.js"
            }
          });

          require.define("/node_modules/ax/lib/ax.js", function(require, module, exports, __dirname, __filename) {
            var inspect = require("util").inspect,
              fs = require("fs");


            // this is a quick-and-dirty logger. there are other nicer loggers out there
            // but the ones i found were also somewhat involved. this one has a Ruby
            // logger type interface
            //
            // we can easily replace this, provide the info, debug, etc. methods are the
            // same. or, we can change Haiku to use a more standard node.js interface

            var format = function(level, message) {
              var debug = (level == "debug" || level == "error");
              if (!message) {
                return message.toString();
              }
              if (typeof(message) == "object") {
                if (message instanceof Error && debug) {
                  return message.stack;
                } else {
                  return inspect(message);
                }
              } else {
                return message.toString();
              }
            };

            var noOp = function(message) {
              return this;
            }
            var makeLogger = function(level, fn) {
              return function(message) {
                this.stream.write(this.format(level, message) + "\n");
                return this;
              }
            };

            var Logger = function(options) {
              var logger = this;
              var options = options || {};

              // Default options
              options.level = options.level || "info";
              options.timestamp = options.timestamp || true;
              options.prefix = options.prefix || "";
              logger.options = options;

              // Allows a prefix to be added to the message.
              //
              //    var logger = new Ax({ module: 'Haiku' })
              //    logger.warn('this is going to be awesome!');
              //    //=> Haiku: this is going to be awesome!
              //
              if (logger.options.module) {
                logger.options.prefix = logger.options.module;
              }

              // Write to stderr or a file
              if (logger.options.file) {
                logger.stream = fs.createWriteStream(logger.options.file, {
                  "flags": "a"
                });
              } else {
                if (process.title === "node") logger.stream = process.stderr;
                else if (process.title === "browser") logger.stream = function() {
                  // Work around weird console context issue: http://code.google.com/p/chromium/issues/detail?id=48662
                  return console[logger.options.level].apply(console, arguments);
                };
              }

              switch (logger.options.level) {
              case 'debug':
                ['debug', 'info', 'warn'].forEach(function(level) {
                  logger[level] = Logger.writer(level);
                });
              case 'info':
                ['info', 'warn'].forEach(function(level) {
                  logger[level] = Logger.writer(level);
                });
              case 'warn':
                logger.warn = Logger.writer('warn');
              }
            }

            // Used to define logger methods
            Logger.writer = function(level) {
              return function(message) {
                var logger = this;

                if (process.title === "node") logger.stream.write(logger.format(level, message) + '\n');
                else if (process.title === "browser") logger.stream(logger.format(level, message) + '\n');

              };
            }


            Logger.prototype = {
              info: function() {},
              debug: function() {},
              warn: function() {},
              error: Logger.writer('error'),
              format: function(level, message) {
                if (!message) return '';

                var logger = this,
                  prefix = logger.options.prefix,
                  timestamp = logger.options.timestamp ? " " + (new Date().toISOString()) : "";

                return (prefix + timestamp + ": " + message);
              }
            };

            module.exports = Logger;

          });

          require.define("util", function(require, module, exports, __dirname, __filename) {
            // todo

          });

          require.define("fs", function(require, module, exports, __dirname, __filename) {
            // nothing to see here... no file methods for the browser

          });

          require.define("/node_modules/cookiejar/package.json", function(require, module, exports, __dirname, __filename) {
            module.exports = {
              "main": "cookiejar.js"
            }
          });

          require.define("/node_modules/cookiejar/cookiejar.js", function(require, module, exports, __dirname, __filename) {
            exports.CookieAccessInfo = CookieAccessInfo = function CookieAccessInfo(domain, path, secure, script) {
              if (this instanceof CookieAccessInfo) {
                this.domain = domain || undefined;
                this.path = path || "/";
                this.secure = !! secure;
                this.script = !! script;
                return this;
              } else {
                return new CookieAccessInfo(domain, path, secure, script)
              }
            }

            exports.Cookie = Cookie = function Cookie(cookiestr) {
              if (cookiestr instanceof Cookie) {
                return cookiestr;
              } else {
                if (this instanceof Cookie) {
                  this.name = null;
                  this.value = null;
                  this.expiration_date = Infinity;
                  this.path = "/";
                  this.domain = null;
                  this.secure = false; //how to define?
                  this.noscript = false; //httponly
                  if (cookiestr) {
                    this.parse(cookiestr)
                  }
                  return this;
                }
                return new Cookie(cookiestr)
              }
            }

            Cookie.prototype.toString = function toString() {
              var str = [this.name + "=" + this.value];
              if (this.expiration_date !== Infinity) {
                str.push("expires=" + (new Date(this.expiration_date)).toGMTString());
              }
              if (this.domain) {
                str.push("domain=" + this.domain);
              }
              if (this.path) {
                str.push("path=" + this.path);
              }
              if (this.secure) {
                str.push("secure");
              }
              if (this.noscript) {
                str.push("httponly");
              }
              return str.join("; ");
            }

            Cookie.prototype.toValueString = function toValueString() {
              return this.name + "=" + this.value;
            }

            var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g
            Cookie.prototype.parse = function parse(str) {
              if (this instanceof Cookie) {
                var parts = str.split(";"),
                  pair = parts[0].match(/([^=]+)=((?:.|\n)*)/),
                  key = pair[1],
                  value = pair[2];
                this.name = key;
                this.value = value;

                for (var i = 1; i < parts.length; i++) {
                  pair = parts[i].match(/([^=]+)(?:=((?:.|\n)*))?/), key = pair[1].trim().toLowerCase(), value = pair[2];
                  switch (key) {
                  case "httponly":
                    this.noscript = true;
                    break;
                  case "expires":
                    this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                    break;
                  case "path":
                    this.path = value ? value.trim() : "";
                    break;
                  case "domain":
                    this.domain = value ? value.trim() : "";
                    break;
                  case "secure":
                    this.secure = true;
                    break
                  }
                }

                return this;
              }
              return new Cookie().parse(str)
            }

            Cookie.prototype.matches = function matches(access_info) {
              if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
                return false
              }
              return true;
            }

            Cookie.prototype.collidesWith = function collidesWith(access_info) {
              if ((this.path && !access_info.path) || (this.domain && !access_info.domain)) {
                return false
              }
              if (this.path && access_info.path.indexOf(this.path) !== 0) {
                return false;
              }
              if (this.domain === access_info.domain) {
                return true;
              } else if (this.domain && this.domain.charAt(0) === ".") {
                var wildcard = access_info.domain.indexOf(this.domain.slice(1))
                if (wildcard === -1 || wildcard !== access_info.domain.length - this.domain.length + 1) {
                  return false;
                }
              } else if (this.domain) {
                return false
              }
              return true;
            }

            exports.CookieJar = CookieJar = function CookieJar() {
              if (this instanceof CookieJar) {
                var cookies = {} //name: [Cookie]

                this.setCookie = function setCookie(cookie) {
                  cookie = Cookie(cookie);
                  //Delete the cookie if the set is past the current time
                  var remove = cookie.expiration_date <= Date.now();
                  if (cookie.name in cookies) {
                    var cookies_list = cookies[cookie.name];
                    for (var i = 0; i < cookies_list.length; i++) {
                      var collidable_cookie = cookies_list[i];
                      if (collidable_cookie.collidesWith(cookie)) {
                        if (remove) {
                          cookies_list.splice(i, 1);
                          if (cookies_list.length === 0) {
                            delete cookies[cookie.name]
                          }
                          return false;
                        } else {
                          return cookies_list[i] = cookie;
                        }
                      }
                    }
                    if (remove) {
                      return false;
                    }
                    cookies_list.push(cookie);
                    return cookie;
                  } else if (remove) {
                    return false;
                  } else {
                    return cookies[cookie.name] = [cookie];
                  }
                }
                //returns a cookie
                this.getCookie = function getCookie(cookie_name, access_info) {
                  var cookies_list = cookies[cookie_name];
                  for (var i = 0; i < cookies_list.length; i++) {
                    var cookie = cookies_list[i];
                    if (cookie.expiration_date <= Date.now()) {
                      if (cookies_list.length === 0) {
                        delete cookies[cookie.name]
                      }
                      continue;
                    }
                    if (cookie.matches(access_info)) {
                      return cookie;
                    }
                  }
                }
                //returns a list of cookies
                this.getCookies = function getCookies(access_info) {
                  var matches = [];
                  for (var cookie_name in cookies) {
                    var cookie = this.getCookie(cookie_name, access_info);
                    if (cookie) {
                      matches.push(cookie);
                    }
                  }
                  matches.toString = function toString() {
                    return matches.join(":");
                  }
                  matches.toValueString = function() {
                    return matches.map(function(c) {
                      return c.toValueString();
                    }).join(';');
                  }
                  return matches;
                }

                return this;
              }
              return new CookieJar()
            }


            //returns list of cookies that were set correctly
            CookieJar.prototype.setCookies = function setCookies(cookies) {
              cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
              var successful = []
              for (var i = 0; i < cookies.length; i++) {
                var cookie = Cookie(cookies[i]);
                if (this.setCookie(cookie)) {
                  successful.push(cookie);
                }
              }
              return successful;
            }

          });

          require.define("/shred/request.js", function(require, module, exports, __dirname, __filename) {
            // The request object encapsulates a request, creating a Node.js HTTP request and
            // then handling the response.

            var HTTP = require("http"),
              HTTPS = require("https"),
              parseUri = require("./parseUri"),
              Emitter = require('events').EventEmitter,
              sprintf = require("sprintf").sprintf,
              Response = require("./response"),
              HeaderMixins = require("./mixins/headers"),
              Content = require("./content");

            var STATUS_CODES = HTTP.STATUS_CODES || {
              100: 'Continue',
              101: 'Switching Protocols',
              102: 'Processing', // RFC 2518, obsoleted by RFC 4918
              200: 'OK',
              201: 'Created',
              202: 'Accepted',
              203: 'Non-Authoritative Information',
              204: 'No Content',
              205: 'Reset Content',
              206: 'Partial Content',
              207: 'Multi-Status', // RFC 4918
              300: 'Multiple Choices',
              301: 'Moved Permanently',
              302: 'Moved Temporarily',
              303: 'See Other',
              304: 'Not Modified',
              305: 'Use Proxy',
              307: 'Temporary Redirect',
              400: 'Bad Request',
              401: 'Unauthorized',
              402: 'Payment Required',
              403: 'Forbidden',
              404: 'Not Found',
              405: 'Method Not Allowed',
              406: 'Not Acceptable',
              407: 'Proxy Authentication Required',
              408: 'Request Time-out',
              409: 'Conflict',
              410: 'Gone',
              411: 'Length Required',
              412: 'Precondition Failed',
              413: 'Request Entity Too Large',
              414: 'Request-URI Too Large',
              415: 'Unsupported Media Type',
              416: 'Requested Range Not Satisfiable',
              417: 'Expectation Failed',
              418: 'I\'m a teapot', // RFC 2324
              422: 'Unprocessable Entity', // RFC 4918
              423: 'Locked', // RFC 4918
              424: 'Failed Dependency', // RFC 4918
              425: 'Unordered Collection', // RFC 4918
              426: 'Upgrade Required', // RFC 2817
              500: 'Internal Server Error',
              501: 'Not Implemented',
              502: 'Bad Gateway',
              503: 'Service Unavailable',
              504: 'Gateway Time-out',
              505: 'HTTP Version not supported',
              506: 'Variant Also Negotiates', // RFC 2295
              507: 'Insufficient Storage', // RFC 4918
              509: 'Bandwidth Limit Exceeded',
              510: 'Not Extended' // RFC 2774
            };

            // The Shred object itself constructs the `Request` object. You should rarely
            // need to do this directly.

            var Request = function(options) {
              this.log = options.logger;
              this.cookieJar = options.cookieJar;
              this.encoding = options.encoding;
              this.logCurl = options.logCurl;
              processOptions(this, options || {});
              createRequest(this);
            };

            // A `Request` has a number of properties, many of which help with details like
            // URL parsing or defaulting the port for the request.

            Object.defineProperties(Request.prototype, {

              // - **url**. You can set the `url` property with a valid URL string and all the
              //   URL-related properties (host, port, etc.) will be automatically set on the
              //   request object.

              url: {
                get: function() {
                  if (!this.scheme) {
                    return null;
                  }
                  return sprintf("%s://%s:%s%s",
                  this.scheme, this.host, this.port, (this.proxy ? "/" : this.path) + (this.query ? ("?" + this.query) : ""));
                },
                set: function(_url) {
                  _url = parseUri(_url);
                  this.scheme = _url.protocol;
                  this.host = _url.host;
                  this.port = _url.port;
                  this.path = _url.path;
                  this.query = _url.query;
                  return this;
                },
                enumerable: true
              },

              // - **headers**. Returns a hash representing the request headers. You can't set
              //   this directly, only get it. You can add or modify headers by using the
              //   `setHeader` or `setHeaders` method. This ensures that the headers are
              //   normalized - that is, you don't accidentally send `Content-Type` and
              //   `content-type` headers. Keep in mind that if you modify the returned hash,
              //   it will *not* modify the request headers.

              headers: {
                get: function() {
                  return this.getHeaders();
                },
                enumerable: true
              },

              // - **port**. Unless you set the `port` explicitly or include it in the URL, it
              //   will default based on the scheme.

              port: {
                get: function() {
                  if (!this._port) {
                    switch (this.scheme) {
                    case "https":
                      return this._port = 443;
                    case "http":
                    default:
                      return this._port = 80;
                    }
                  }
                  return this._port;
                },
                set: function(value) {
                  this._port = value;
                  return this;
                },
                enumerable: true
              },

              // - **method**. The request method - `get`, `put`, `post`, etc. that will be
              //   used to make the request. Defaults to `get`.

              method: {
                get: function() {
                  return this._method = (this._method || "GET");
                },
                set: function(value) {
                  this._method = value;
                  return this;
                },
                enumerable: true
              },

              // - **query**. Can be set either with a query string or a hash (object). Get
              //   will always return a properly escaped query string or null if there is no
              //   query component for the request.

              query: {
                get: function() {
                  return this._query;
                },
                set: function(value) {
                  var stringify = function(hash) {
                    var query = "";
                    for (var key in hash) {
                      query += encodeURIComponent(key) + '=' + encodeURIComponent(hash[key]) + '&';
                    }
                    // Remove the last '&'
                    query = query.slice(0, - 1);
                    return query;
                  }

                  if (value) {
                    if (typeof value === 'object') {
                      value = stringify(value);
                    }
                    this._query = value;
                  } else {
                    this._query = "";
                  }
                  return this;
                },
                enumerable: true
              },

              // - **parameters**. This will return the query parameters in the form of a hash
              //   (object).

              parameters: {
                get: function() {
                  return QueryString.parse(this._query || "");
                },
                enumerable: true
              },

              // - **content**. (Aliased as `body`.) Set this to add a content entity to the
              //   request. Attempts to use the `content-type` header to determine what to do
              //   with the content value. Get this to get back a [`Content`
              //   object](./content.html).

              body: {
                get: function() {
                  return this._body;
                },
                set: function(value) {
                  this._body = new Content({
                    data: value,
                    type: this.getHeader("Content-Type")
                  });
                  this.setHeader("Content-Type", this.content.type);
                  this.setHeader("Content-Length", this.content.length);
                  return this;
                },
                enumerable: true
              },

              // - **timeout**. Used to determine how long to wait for a response. Does not
              //   distinguish between connect timeouts versus request timeouts. Set either in
              //   milliseconds or with an object with temporal attributes (hours, minutes,
              //   seconds) and convert it into milliseconds. Get will always return
              //   milliseconds.

              timeout: {
                get: function() {
                  return this._timeout;
                }, // in milliseconds
                set: function(timeout) {
                  var request = this,
                    milliseconds = 0;;
                  if (!timeout) return this;
                  if (typeof timeout === "number") {
                    milliseconds = timeout;
                  } else {
                    milliseconds = (timeout.milliseconds || 0) + (1000 * ((timeout.seconds || 0) + (60 * ((timeout.minutes || 0) + (60 * (timeout.hours || 0))))));
                  }
                  this._timeout = milliseconds;
                  return this;
                },
                enumerable: true
              }
            });

            // Alias `body` property to `content`. Since the [content object](./content.html)
            // has a `body` attribute, it's preferable to use `content` since you can then
            // access the raw content data using `content.body`.

            Object.defineProperty(Request.prototype, "content",
            Object.getOwnPropertyDescriptor(Request.prototype, "body"));

            // The `Request` object can be pretty overwhelming to view using the built-in
            // Node.js inspect method. We want to make it a bit more manageable. This
            // probably goes [too far in the other
            // direction](https://github.com/spire-io/shred/issues/2).

            Request.prototype.inspect = function() {
              var request = this;
              var headers = this.format_headers();
              var summary = ["<Shred Request> ", request.method.toUpperCase(),
              request.url].join(" ")
              return [summary, "- Headers:", headers].join("\n");
            };

            Request.prototype.format_headers = function() {
              var array = []
              var headers = this._headers
              for (var key in headers) {
                if (headers.hasOwnProperty(key)) {
                  var value = headers[key]
                  array.push("\t" + key + ": " + value);
                }
              }
              return array.join("\n");
            };

            // Allow chainable 'on's:  shred.get({ ... }).on( ... ).  You can pass in a
            // single function, a pair (event, function), or a hash:
            // { event: function, event: function }
            Request.prototype.on = function(eventOrHash, listener) {
              var emitter = this.emitter;
              // Pass in a single argument as a function then make it the default response handler
              if (arguments.length === 1 && typeof(eventOrHash) === 'function') {
                emitter.on('response', eventOrHash);
              } else if (arguments.length === 1 && typeof(eventOrHash) === 'object') {
                for (var key in eventOrHash) {
                  if (eventOrHash.hasOwnProperty(key)) {
                    emitter.on(key, eventOrHash[key]);
                  }
                }
              } else {
                emitter.on(eventOrHash, listener);
              }
              return this;
            };

            // Add in the header methods. Again, these ensure we don't get the same header
            // multiple times with different case conventions.
            HeaderMixins.gettersAndSetters(Request);

            // `processOptions` is called from the constructor to handle all the work
            // associated with making sure we do our best to ensure we have a valid request.

            var processOptions = function(request, options) {

              request.log.debug("Processing request options ..");

              // We'll use `request.emitter` to manage the `on` event handlers.
              request.emitter = (new Emitter);

              request.agent = options.agent;

              // Set up the handlers ...
              if (options.on) {
                for (var key in options.on) {
                  if (options.on.hasOwnProperty(key)) {
                    request.emitter.on(key, options.on[key]);
                  }
                }
              }

              // Make sure we were give a URL or a host
              if (!options.url && !options.host) {
                request.emitter.emit("request_error",
                new Error("No url or url options (host, port, etc.)"));
                return;
              }

              // Allow for the [use of a proxy](http://www.jmarshall.com/easy/http/#proxies).

              if (options.url) {
                if (options.proxy) {
                  request.url = options.proxy;
                  request.path = options.url;
                } else {
                  request.url = options.url;
                }
              }

              // Set the remaining options.
              request.query = options.query || options.parameters || request.query;
              request.method = options.method;
              request.setHeader("user-agent", options.agent || "Shred");
              request.setHeaders(options.headers);

              if (request.cookieJar) {
                var cookies = request.cookieJar.getCookies(CookieAccessInfo(request.host, request.path));
                if (cookies.length) {
                  var cookieString = request.getHeader('cookie') || '';
                  for (var cookieIndex = 0; cookieIndex < cookies.length; ++cookieIndex) {
                    if (cookieString.length && cookieString[cookieString.length - 1] != ';') {
                      cookieString += ';';
                    }
                    cookieString += cookies[cookieIndex].name + '=' + cookies[cookieIndex].value + ';';
                  }
                  request.setHeader("cookie", cookieString);
                }
              }

              // The content entity can be set either using the `body` or `content` attributes.
              if (options.body || options.content) {
                request.content = options.body || options.content;
              }
              request.timeout = options.timeout;

            };

            // `createRequest` is also called by the constructor, after `processOptions`.
            // This actually makes the request and processes the response, so `createRequest`
            // is a bit of a misnomer.

            var createRequest = function(request) {
              var timeout;

              request.log.debug("Creating request ..");
              request.log.debug(request);

              var reqParams = {
                host: request.host,
                port: request.port,
                method: request.method,
                path: request.path + (request.query ? '?' + request.query : ""),
                headers: request.getHeaders(),
                // Node's HTTP/S modules will ignore this, but we are using the
                // browserify-http module in the browser for both HTTP and HTTPS, and this
                // is how you differentiate the two.
                scheme: request.scheme,
                // Use a provided agent.  'Undefined' is the default, which uses a global
                // agent.
                agent: request.agent
              };

              if (request.logCurl) {
                logCurl(request);
              }

              var http = request.scheme == "http" ? HTTP : HTTPS;

              // Set up the real request using the selected library. The request won't be
              // sent until we call `.end()`.
              request._raw = http.request(reqParams, function(response) {
                request.log.debug("Received response ..");

                // We haven't timed out and we have a response, so make sure we clear the
                // timeout so it doesn't fire while we're processing the response.
                clearTimeout(timeout);

                // Construct a Shred `Response` object from the response. This will stream
                // the response, thus the need for the callback. We can access the response
                // entity safely once we're in the callback.
                response = new Response(response, request, function(response) {

                  // Set up some event magic. The precedence is given first to
                  // status-specific handlers, then to responses for a given event, and then
                  // finally to the more general `response` handler. In the last case, we
                  // need to first make sure we're not dealing with a a redirect.
                  var emit = function(event) {
                    var emitter = request.emitter;
                    var textStatus = STATUS_CODES[response.status] ? STATUS_CODES[response.status].toLowerCase() : null;
                    if (emitter.listeners(response.status).length > 0 || emitter.listeners(textStatus).length > 0) {
                      emitter.emit(response.status, response);
                      emitter.emit(textStatus, response);
                    } else {
                      if (emitter.listeners(event).length > 0) {
                        emitter.emit(event, response);
                      } else if (!response.isRedirect) {
                        emitter.emit("response", response);
                        //console.warn("Request has no event listener for status code " + response.status);
                      }
                    }
                  };

                  // Next, check for a redirect. We simply repeat the request with the URL
                  // given in the `Location` header. We fire a `redirect` event.
                  if (response.isRedirect) {
                    request.log.debug("Redirecting to " + response.getHeader("Location"));
                    request.url = response.getHeader("Location");
                    emit("redirect");
                    createRequest(request);

                    // Okay, it's not a redirect. Is it an error of some kind?
                  } else if (response.isError) {
                    emit("error");
                  } else {
                    // It looks like we're good shape. Trigger the `success` event.
                    emit("success");
                  }
                });
              });

              // We're still setting up the request. Next, we're going to handle error cases
              // where we have no response. We don't emit an error event because that event
              // takes a response. We don't response handlers to have to check for a null
              // value. However, we [should introduce a different event
              // type](https://github.com/spire-io/shred/issues/3) for this type of error.
              request._raw.on("error", function(error) {
                request.emitter.emit("request_error", error);
              });

              request._raw.on("socket", function(socket) {
                request.emitter.emit("socket", socket);
              });

              // TCP timeouts should also trigger the "response_error" event.
              request._raw.on('socket', function() {
                request._raw.socket.on('timeout', function() {
                  // This should trigger the "error" event on the raw request, which will
                  // trigger the "response_error" on the shred request.
                  request._raw.abort();
                });
              });


              // We're almost there. Next, we need to write the request entity to the
              // underlying request object.
              if (request.content) {
                request.log.debug("Streaming body: '" + request.content.body.slice(0, 59) + "' ... ");
                request._raw.write(request.content.body);
              }

              // Finally, we need to set up the timeout. We do this last so that we don't
              // start the clock ticking until the last possible moment.
              if (request.timeout) {
                timeout = setTimeout(function() {
                  request.log.debug("Timeout fired, aborting request ...");
                  request._raw.abort();
                  request.emitter.emit("timeout", request);
                }, request.timeout);
              }

              // The `.end()` method will cause the request to fire. Technically, it might
              // have already sent the headers and body.
              request.log.debug("Sending request ...");
              request._raw.end();
            };

            // Logs the curl command for the request.
            var logCurl = function(req) {
              var headers = req.getHeaders();
              var headerString = "";

              for (var key in headers) {
                headerString += '-H "' + key + ": " + headers[key] + '" ';
              }

              var bodyString = ""

              if (req.content) {
                bodyString += "-d '" + req.content.body + "' ";
              }

              var query = req.query ? '?' + req.query : "";

              console.log("curl " + "-X " + req.method.toUpperCase() + " " + req.scheme + "://" + req.host + ":" + req.port + req.path + query + " " + headerString + bodyString);
            };


            module.exports = Request;

          });

          require.define("http", function(require, module, exports, __dirname, __filename) {
            // todo

          });

          require.define("https", function(require, module, exports, __dirname, __filename) {
            // todo

          });

          require.define("/shred/parseUri.js", function(require, module, exports, __dirname, __filename) {
            // parseUri 1.2.2
            // (c) Steven Levithan <stevenlevithan.com>
            // MIT License

            function parseUri(str) {
              var o = parseUri.options,
                m = o.parser[o.strictMode ? "strict" : "loose"].exec(str),
                uri = {},
                i = 14;

              while (i--) uri[o.key[i]] = m[i] || "";

              uri[o.q.name] = {};
              uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
                if ($1) uri[o.q.name][$1] = $2;
              });

              return uri;
            };

            parseUri.options = {
              strictMode: false,
              key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
              q: {
                name: "queryKey",
                parser: /(?:^|&)([^&=]*)=?([^&]*)/g
              },
              parser: {
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
              }
            };

            module.exports = parseUri;

          });

          require.define("events", function(require, module, exports, __dirname, __filename) {
            if (!process.EventEmitter) process.EventEmitter = function() {};

            var EventEmitter = exports.EventEmitter = process.EventEmitter;
            var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(xs) {
                return Object.toString.call(xs) === '[object Array]'
              };

            // By default EventEmitters will print a warning if more than
            // 10 listeners are added to it. This is a useful default which
            // helps finding memory leaks.
            //
            // Obviously not all Emitters should be limited to 10. This function allows
            // that to be increased. Set to zero for unlimited.
            var defaultMaxListeners = 10;
            EventEmitter.prototype.setMaxListeners = function(n) {
              if (!this._events) this._events = {};
              this._events.maxListeners = n;
            };


            EventEmitter.prototype.emit = function(type) {
              // If there is no 'error' event listener then throw.
              if (type === 'error') {
                if (!this._events || !this._events.error || (isArray(this._events.error) && !this._events.error.length)) {
                  if (arguments[1] instanceof Error) {
                    throw arguments[1]; // Unhandled 'error' event
                  } else {
                    throw new Error("Uncaught, unspecified 'error' event.");
                  }
                  return false;
                }
              }

              if (!this._events) return false;
              var handler = this._events[type];
              if (!handler) return false;

              if (typeof handler == 'function') {
                switch (arguments.length) {
                  // fast cases
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                  // slower
                default:
                  var args = Array.prototype.slice.call(arguments, 1);
                  handler.apply(this, args);
                }
                return true;

              } else if (isArray(handler)) {
                var args = Array.prototype.slice.call(arguments, 1);

                var listeners = handler.slice();
                for (var i = 0, l = listeners.length; i < l; i++) {
                  listeners[i].apply(this, args);
                }
                return true;

              } else {
                return false;
              }
            };

            // EventEmitter is defined in src/node_events.cc
            // EventEmitter.prototype.emit() is also defined there.
            EventEmitter.prototype.addListener = function(type, listener) {
              if ('function' !== typeof listener) {
                throw new Error('addListener only takes instances of Function');
              }

              if (!this._events) this._events = {};

              // To avoid recursion in the case that type == "newListeners"! Before
              // adding it to the listeners, first emit "newListeners".
              this.emit('newListener', type, listener);

              if (!this._events[type]) {
                // Optimize the case of one listener. Don't need the extra array object.
                this._events[type] = listener;
              } else if (isArray(this._events[type])) {

                // Check for listener leak
                if (!this._events[type].warned) {
                  var m;
                  if (this._events.maxListeners !== undefined) {
                    m = this._events.maxListeners;
                  } else {
                    m = defaultMaxListeners;
                  }

                  if (m && m > 0 && this._events[type].length > m) {
                    this._events[type].warned = true;
                    console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
                    console.trace();
                  }
                }

                // If we've already got an array, just append.
                this._events[type].push(listener);
              } else {
                // Adding the second element, need to change to array.
                this._events[type] = [this._events[type], listener];
              }

              return this;
            };

            EventEmitter.prototype.on = EventEmitter.prototype.addListener;

            EventEmitter.prototype.once = function(type, listener) {
              var self = this;
              self.on(type, function g() {
                self.removeListener(type, g);
                listener.apply(this, arguments);
              });

              return this;
            };

            EventEmitter.prototype.removeListener = function(type, listener) {
              if ('function' !== typeof listener) {
                throw new Error('removeListener only takes instances of Function');
              }

              // does not use listeners(), so no side effect of creating _events[type]
              if (!this._events || !this._events[type]) return this;

              var list = this._events[type];

              if (isArray(list)) {
                var i = list.indexOf(listener);
                if (i < 0) return this;
                list.splice(i, 1);
                if (list.length == 0) delete this._events[type];
              } else if (this._events[type] === listener) {
                delete this._events[type];
              }

              return this;
            };

            EventEmitter.prototype.removeAllListeners = function(type) {
              // does not use listeners(), so no side effect of creating _events[type]
              if (type && this._events && this._events[type]) this._events[type] = null;
              return this;
            };

            EventEmitter.prototype.listeners = function(type) {
              if (!this._events) this._events = {};
              if (!this._events[type]) this._events[type] = [];
              if (!isArray(this._events[type])) {
                this._events[type] = [this._events[type]];
              }
              return this._events[type];
            };

          });

          require.define("/node_modules/sprintf/package.json", function(require, module, exports, __dirname, __filename) {
            module.exports = {
              "main": "./lib/sprintf"
            }
          });

          require.define("/node_modules/sprintf/lib/sprintf.js", function(require, module, exports, __dirname, __filename) {
            /**
sprintf() for JavaScript 0.7-beta1
http://www.diveintojavascript.com/projects/javascript-sprintf

Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of sprintf() for JavaScript nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Changelog:
2010.11.07 - 0.7-beta1-node
  - converted it to a node.js compatible module

2010.09.06 - 0.7-beta1
  - features: vsprintf, support for named placeholders
  - enhancements: format cache, reduced global namespace pollution

2010.05.22 - 0.6:
 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
 Note:
 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
 who warned me about a bug in 0.5, I discovered that the last update was
 a regress. I appologize for that.

2010.05.09 - 0.5:
 - bug fix: 0 is now preceeded with a + sign
 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
 - switched from GPL to BSD license

2007.10.21 - 0.4:
 - unit test and patch (David Baird)

2007.09.17 - 0.3:
 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)

2007.09.11 - 0.2:
 - feature: added argument swapping

2007.04.03 - 0.1:
 - initial release
**/

            var sprintf = (function() {
              function get_type(variable) {
                return Object.prototype.toString.call(variable).slice(8, - 1).toLowerCase();
              }

              function str_repeat(input, multiplier) {
                for (var output = []; multiplier > 0; output[--multiplier] = input) { /* do nothing */
                }
                return output.join('');
              }

              var str_format = function() {
                if (!str_format.cache.hasOwnProperty(arguments[0])) {
                  str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
                }
                return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
              };

              str_format.format = function(parse_tree, argv) {
                var cursor = 1,
                  tree_length = parse_tree.length,
                  node_type = '',
                  arg, output = [],
                  i, k, match, pad, pad_character, pad_length;
                for (i = 0; i < tree_length; i++) {
                  node_type = get_type(parse_tree[i]);
                  if (node_type === 'string') {
                    output.push(parse_tree[i]);
                  } else if (node_type === 'array') {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                      arg = argv[cursor];
                      for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                          throw (sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                        }
                        arg = arg[match[2][k]];
                      }
                    } else if (match[1]) { // positional argument (explicit)
                      arg = argv[match[1]];
                    } else { // positional argument (implicit)
                      arg = argv[cursor++];
                    }

                    if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                      throw (sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                    }
                    switch (match[8]) {
                    case 'b':
                      arg = arg.toString(2);
                      break;
                    case 'c':
                      arg = String.fromCharCode(arg);
                      break;
                    case 'd':
                      arg = parseInt(arg, 10);
                      break;
                    case 'e':
                      arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                      break;
                    case 'f':
                      arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                      break;
                    case 'o':
                      arg = arg.toString(8);
                      break;
                    case 's':
                      arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg);
                      break;
                    case 'u':
                      arg = Math.abs(arg);
                      break;
                    case 'x':
                      arg = arg.toString(16);
                      break;
                    case 'X':
                      arg = arg.toString(16).toUpperCase();
                      break;
                    }
                    arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg);
                    pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                    output.push(match[5] ? arg + pad : pad + arg);
                  }
                }
                return output.join('');
              };

              str_format.cache = {};

              str_format.parse = function(fmt) {
                var _fmt = fmt,
                  match = [],
                  parse_tree = [],
                  arg_names = 0;
                while (_fmt) {
                  if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                  } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                  } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                      arg_names |= 1;
                      var field_list = [],
                        replacement_field = match[2],
                        field_match = [];
                      if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1]);
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                          if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                          } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                          } else {
                            throw ('[sprintf] huh?');
                          }
                        }
                      } else {
                        throw ('[sprintf] huh?');
                      }
                      match[2] = field_list;
                    } else {
                      arg_names |= 2;
                    }
                    if (arg_names === 3) {
                      throw ('[sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                  } else {
                    throw ('[sprintf] huh?');
                  }
                  _fmt = _fmt.substring(match[0].length);
                }
                return parse_tree;
              };

              return str_format;
            })();

            var vsprintf = function(fmt, argv) {
              argv.unshift(fmt);
              return sprintf.apply(null, argv);
            };

            exports.sprintf = sprintf;
            exports.vsprintf = vsprintf;
          });

          require.define("/shred/response.js", function(require, module, exports, __dirname, __filename) {
            // The `Response object` encapsulates a Node.js HTTP response.

            var Content = require("./content"),
              HeaderMixins = require("./mixins/headers"),
              CookieJarLib = require("cookiejar"),
              Cookie = CookieJarLib.Cookie;

            // Browser doesn't have zlib.
            var zlib = null;
            try {
              zlib = require('zlib');
            } catch (e) {
              console.warn("no zlib library");
            }

            // Iconv doesn't work in browser
            var Iconv = null;
            try {
              Iconv = require('iconv-lite');
            } catch (e) {
              console.warn("no iconv library");
            }

            // Construct a `Response` object. You should never have to do this directly. The
            // `Request` object handles this, getting the raw response object and passing it
            // in here, along with the request. The callback allows us to stream the response
            // and then use the callback to let the request know when it's ready.
            var Response = function(raw, request, callback) {
              var response = this;
              this._raw = raw;

              // The `._setHeaders` method is "private"; you can't otherwise set headers on
              // the response.
              this._setHeaders.call(this, raw.headers);

              // store any cookies
              if (request.cookieJar && this.getHeader('set-cookie')) {
                var cookieStrings = this.getHeader('set-cookie');
                var cookieObjs = [],
                  cookie;

                for (var i = 0; i < cookieStrings.length; i++) {
                  var cookieString = cookieStrings[i];
                  if (!cookieString) {
                    continue;
                  }

                  if (!cookieString.match(/domain\=/i)) {
                    cookieString += '; domain=' + request.host;
                  }

                  if (!cookieString.match(/path\=/i)) {
                    cookieString += '; path=' + request.path;
                  }

                  try {
                    cookie = new Cookie(cookieString);
                    if (cookie) {
                      cookieObjs.push(cookie);
                    }
                  } catch (e) {
                    console.warn("Tried to set bad cookie: " + cookieString);
                  }
                }

                request.cookieJar.setCookies(cookieObjs);
              }

              this.request = request;
              this.client = request.client;
              this.log = this.request.log;

              // Stream the response content entity and fire the callback when we're done.
              // Store the incoming data in a array of Buffers which we concatinate into one
              // buffer at the end.  We need to use buffers instead of strings here in order
              // to preserve binary data.
              var chunkBuffers = [];
              var dataLength = 0;
              raw.on("data", function(chunk) {
                chunkBuffers.push(chunk);
                dataLength += chunk.length;
              });
              raw.on("end", function() {
                var body;
                if (typeof Buffer === 'undefined') {
                  // Just concatinate into a string
                  body = chunkBuffers.join('');
                } else {
                  // Initialize new buffer and add the chunks one-at-a-time.
                  body = new Buffer(dataLength);
                  for (var i = 0, pos = 0; i < chunkBuffers.length; i++) {
                    chunkBuffers[i].copy(body, pos);
                    pos += chunkBuffers[i].length;
                  }
                }

                var setBodyAndFinish = function(body) {
                  response._body = new Content({
                    body: body,
                    type: response.getHeader("Content-Type")
                  });
                  callback(response);
                }

                if (zlib && response.getHeader("Content-Encoding") === 'gzip') {
                  zlib.gunzip(body, function(err, gunzippedBody) {
                    if (Iconv && response.request.encoding) {
                      body = Iconv.fromEncoding(gunzippedBody, response.request.encoding);
                    } else {
                      body = gunzippedBody.toString();
                    }
                    setBodyAndFinish(body);
                  })
                } else {
                  if (response.request.encoding) {
                    body = Iconv.fromEncoding(body, response.request.encoding);
                  }
                  setBodyAndFinish(body);
                }
              });
            };

            // The `Response` object can be pretty overwhelming to view using the built-in
            // Node.js inspect method. We want to make it a bit more manageable. This
            // probably goes [too far in the other
            // direction](https://github.com/spire-io/shred/issues/2).

            Response.prototype = {
              inspect: function() {
                var response = this;
                var headers = this.format_headers();
                var summary = ["<Shred Response> ", response.status].join(" ")
                return [summary, "- Headers:", headers].join("\n");
              },
              format_headers: function() {
                var array = []
                var headers = this._headers
                for (var key in headers) {
                  if (headers.hasOwnProperty(key)) {
                    var value = headers[key]
                    array.push("\t" + key + ": " + value);
                  }
                }
                return array.join("\n");
              }
            };

            // `Response` object properties, all of which are read-only:
            Object.defineProperties(Response.prototype, {

              // - **status**. The HTTP status code for the response. 
              status: {
                get: function() {
                  return this._raw.statusCode;
                },
                enumerable: true
              },

              // - **content**. The HTTP content entity, if any. Provided as a [content
              //   object](./content.html), which will attempt to convert the entity based upon
              //   the `content-type` header. The converted value is available as
              //   `content.data`. The original raw content entity is available as
              //   `content.body`.
              body: {
                get: function() {
                  return this._body;
                }
              },
              content: {
                get: function() {
                  return this.body;
                },
                enumerable: true
              },

              // - **isRedirect**. Is the response a redirect? These are responses with 3xx
              //   status and a `Location` header.
              isRedirect: {
                get: function() {
                  return (this.status > 299 && this.status < 400 && this.getHeader("Location"));
                },
                enumerable: true
              },

              // - **isError**. Is the response an error? These are responses with status of
              //   400 or greater.
              isError: {
                get: function() {
                  return (this.status === 0 || this.status > 399)
                },
                enumerable: true
              }
            });

            // Add in the [getters for accessing the normalized headers](./headers.js).
            HeaderMixins.getters(Response);
            HeaderMixins.privateSetters(Response);

            // Work around Mozilla bug #608735 [https://bugzil.la/608735], which causes
            // getAllResponseHeaders() to return {} if the response is a CORS request.
            // xhr.getHeader still works correctly.
            var getHeader = Response.prototype.getHeader;
            Response.prototype.getHeader = function(name) {
              return (getHeader.call(this, name) || (typeof this._raw.getHeader === 'function' && this._raw.getHeader(name)));
            };

            module.exports = Response;

          });

          require.define("/shred/content.js", function(require, module, exports, __dirname, __filename) {

            // The purpose of the `Content` object is to abstract away the data conversions
            // to and from raw content entities as strings. For example, you want to be able
            // to pass in a Javascript object and have it be automatically converted into a
            // JSON string if the `content-type` is set to a JSON-based media type.
            // Conversely, you want to be able to transparently get back a Javascript object
            // in the response if the `content-type` is a JSON-based media-type.

            // One limitation of the current implementation is that it [assumes the `charset` is UTF-8](https://github.com/spire-io/shred/issues/5).

            // The `Content` constructor takes an options object, which *must* have either a
            // `body` or `data` property and *may* have a `type` property indicating the
            // media type. If there is no `type` attribute, a default will be inferred.
            var Content = function(options) {
              this.body = options.body;
              this.data = options.data;
              this.type = options.type;
            };

            Content.prototype = {
              // Treat `toString()` as asking for the `content.body`. That is, the raw content entity.
              //
              //     toString: function() { return this.body; }
              //
              // Commented out, but I've forgotten why. :/
            };


            // `Content` objects have the following attributes:
            Object.defineProperties(Content.prototype, {

              // - **type**. Typically accessed as `content.type`, reflects the `content-type`
              //   header associated with the request or response. If not passed as an options
              //   to the constructor or set explicitly, it will infer the type the `data`
              //   attribute, if possible, and, failing that, will default to `text/plain`.
              type: {
                get: function() {
                  if (this._type) {
                    return this._type;
                  } else {
                    if (this._data) {
                      switch (typeof this._data) {
                      case "string":
                        return "text/plain";
                      case "object":
                        return "application/json";
                      }
                    }
                  }
                  return "text/plain";
                },
                set: function(value) {
                  this._type = value;
                  return this;
                },
                enumerable: true
              },

              // - **data**. Typically accessed as `content.data`, reflects the content entity
              //   converted into Javascript data. This can be a string, if the `type` is, say,
              //   `text/plain`, but can also be a Javascript object. The conversion applied is
              //   based on the `processor` attribute. The `data` attribute can also be set
              //   directly, in which case the conversion will be done the other way, to infer
              //   the `body` attribute.
              data: {
                get: function() {
                  if (this._body) {
                    return this.processor.parser(this._body);
                  } else {
                    return this._data;
                  }
                },
                set: function(data) {
                  if (this._body && data) Errors.setDataWithBody(this);
                  this._data = data;
                  return this;
                },
                enumerable: true
              },

              // - **body**. Typically accessed as `content.body`, reflects the content entity
              //   as a UTF-8 string. It is the mirror of the `data` attribute. If you set the
              //   `data` attribute, the `body` attribute will be inferred and vice-versa. If
              //   you attempt to set both, an exception is raised.
              body: {
                get: function() {
                  if (this._data) {
                    return this.processor.stringify(this._data);
                  } else {
                    return this.processor.stringify(this._body);
                  }
                },
                set: function(body) {
                  if (this._data && body) Errors.setBodyWithData(this);
                  this._body = body;
                  return this;
                },
                enumerable: true
              },

              // - **processor**. The functions that will be used to convert to/from `data` and
              //   `body` attributes. You can add processors. The two that are built-in are for
              //   `text/plain`, which is basically an identity transformation and
              //   `application/json` and other JSON-based media types (including custom media
              //   types with `+json`). You can add your own processors. See below.
              processor: {
                get: function() {
                  var processor = Content.processors[this.type];
                  if (processor) {
                    return processor;
                  } else {
                    // Return the first processor that matches any part of the
                    // content type. ex: application/vnd.foobar.baz+json will match json.
                    var main = this.type.split(";")[0];
                    var parts = main.split(/\+|\//);
                    for (var i = 0, l = parts.length; i < l; i++) {
                      processor = Content.processors[parts[i]]
                    }
                    return processor || {
                      parser: identity,
                      stringify: toString
                    };
                  }
                },
                enumerable: true
              },

              // - **length**. Typically accessed as `content.length`, returns the length in
              //   bytes of the raw content entity.
              length: {
                get: function() {
                  if (typeof Buffer !== 'undefined') {
                    return Buffer.byteLength(this.body);
                  }
                  return this.body.length;
                }
              }
            });

            Content.processors = {};

            // The `registerProcessor` function allows you to add your own processors to
            // convert content entities. Each processor consists of a Javascript object with
            // two properties:
            // - **parser**. The function used to parse a raw content entity and convert it
            //   into a Javascript data type.
            // - **stringify**. The function used to convert a Javascript data type into a
            //   raw content entity.
            Content.registerProcessor = function(types, processor) {

              // You can pass an array of types that will trigger this processor, or just one.
              // We determine the array via duck-typing here.
              if (types.forEach) {
                types.forEach(function(type) {
                  Content.processors[type] = processor;
                });
              } else {
                // If you didn't pass an array, we just use what you pass in.
                Content.processors[types] = processor;
              }
            };

            // Register the identity processor, which is used for text-based media types.
            var identity = function(x) {
              return x;
            }, toString = function(x) {
              return x.toString();
            }
            Content.registerProcessor(
            ["text/html", "text/plain", "text"], {
              parser: identity,
              stringify: toString
            });

            // Register the JSON processor, which is used for JSON-based media types.
            Content.registerProcessor(
            ["application/json; charset=utf-8", "application/json", "json"], {
              parser: function(string) {
                return JSON.parse(string);
              },
              stringify: function(data) {
                return JSON.stringify(data);
              }
            });

            // Error functions are defined separately here in an attempt to make the code
            // easier to read.
            var Errors = {
              setDataWithBody: function(object) {
                throw new Error("Attempt to set data attribute of a content object " + "when the body attributes was already set.");
              },
              setBodyWithData: function(object) {
                throw new Error("Attempt to set body attribute of a content object " + "when the data attributes was already set.");
              }
            }
            module.exports = Content;

          });

          require.define("/shred/mixins/headers.js", function(require, module, exports, __dirname, __filename) {
            // The header mixins allow you to add HTTP header support to any object. This
            // might seem pointless: why not simply use a hash? The main reason is that, per
            // the [HTTP spec](http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2),
            // headers are case-insensitive. So, for example, `content-type` is the same as
            // `CONTENT-TYPE` which is the same as `Content-Type`. Since there is no way to
            // overload the index operator in Javascript, using a hash to represent the
            // headers means it's possible to have two conflicting values for a single
            // header.
            // 
            // The solution to this is to provide explicit methods to set or get headers.
            // This also has the benefit of allowing us to introduce additional variations,
            // including snake case, which we automatically convert to what Matthew King has
            // dubbed "corset case" - the hyphen-separated names with initial caps:
            // `Content-Type`. We use corset-case just in case we're dealing with servers
            // that haven't properly implemented the spec.

            // Convert headers to corset-case. **Example:** `CONTENT-TYPE` will be converted
            // to `Content-Type`.

            var corsetCase = function(string) {
              return string.toLowerCase().replace("_", "-").replace(/(^|-)(\w)/g,

              function(s) {
                return s.toUpperCase();
              });
            };

            // We suspect that `initializeHeaders` was once more complicated ...
            var initializeHeaders = function(object) {
              return {};
            };

            // Access the `_headers` property using lazy initialization. **Warning:** If you
            // mix this into an object that is using the `_headers` property already, you're
            // going to have trouble.
            var $H = function(object) {
              return object._headers || (object._headers = initializeHeaders(object));
            };

            // Hide the implementations as private functions, separate from how we expose them.

            // The "real" `getHeader` function: get the header after normalizing the name.
            var getHeader = function(object, name) {
              return $H(object)[corsetCase(name)];
            };

            // The "real" `getHeader` function: get one or more headers, or all of them
            // if you don't ask for any specifics. 
            var getHeaders = function(object, names) {
              var keys = (names && names.length > 0) ? names : Object.keys($H(object));
              var hash = keys.reduce(function(hash, key) {
                hash[key] = getHeader(object, key);
                return hash;
              }, {});
              // Freeze the resulting hash so you don't mistakenly think you're modifying
              // the real headers.
              Object.freeze(hash);
              return hash;
            };

            // The "real" `setHeader` function: set a header, after normalizing the name.
            var setHeader = function(object, name, value) {
              $H(object)[corsetCase(name)] = value;
              return object;
            };

            // The "real" `setHeaders` function: set multiple headers based on a hash.
            var setHeaders = function(object, hash) {
              for (var key in hash) {
                setHeader(object, key, hash[key]);
              };
              return this;
            };

            // Here's where we actually bind the functionality to an object. These mixins work by
            // exposing mixin functions. Each function mixes in a specific batch of features.
            module.exports = {

              // Add getters.
              getters: function(constructor) {
                constructor.prototype.getHeader = function(name) {
                  return getHeader(this, name);
                };
                constructor.prototype.getHeaders = function() {
                  return getHeaders(this, arguments);
                };
              },
              // Add setters but as "private" methods.
              privateSetters: function(constructor) {
                constructor.prototype._setHeader = function(key, value) {
                  return setHeader(this, key, value);
                };
                constructor.prototype._setHeaders = function(hash) {
                  return setHeaders(this, hash);
                };
              },
              // Add setters.
              setters: function(constructor) {
                constructor.prototype.setHeader = function(key, value) {
                  return setHeader(this, key, value);
                };
                constructor.prototype.setHeaders = function(hash) {
                  return setHeaders(this, hash);
                };
              },
              // Add both getters and setters.
              gettersAndSetters: function(constructor) {
                constructor.prototype.getHeader = function(name) {
                  return getHeader(this, name);
                };
                constructor.prototype.getHeaders = function() {
                  return getHeaders(this, arguments);
                };
                constructor.prototype.setHeader = function(key, value) {
                  return setHeader(this, key, value);
                };
                constructor.prototype.setHeaders = function(hash) {
                  return setHeaders(this, hash);
                };
              },
            };

          });

          require.define("/node_modules/iconv-lite/package.json", function(require, module, exports, __dirname, __filename) {
            module.exports = {}
          });

          require.define("/node_modules/iconv-lite/index.js", function(require, module, exports, __dirname, __filename) {
            // Module exports
            var iconv = module.exports = {
              toEncoding: function(str, encoding) {
                return iconv.getCodec(encoding).toEncoding(str);
              },
              fromEncoding: function(buf, encoding) {
                return iconv.getCodec(encoding).fromEncoding(buf);
              },

              defaultCharUnicode: '�',
              defaultCharSingleByte: '?',

              // Get correct codec for given encoding.
              getCodec: function(encoding) {
                var enc = encoding || "utf8";
                var codecOptions = undefined;
                while (1) {
                  if (getType(enc) === "String") enc = enc.replace(/[- ]/g, "").toLowerCase();
                  var codec = iconv.encodings[enc];
                  var type = getType(codec);
                  if (type === "String") {
                    // Link to other encoding.
                    codecOptions = {
                      originalEncoding: enc
                    };
                    enc = codec;
                  } else if (type === "Object" && codec.type != undefined) {
                    // Options for other encoding.
                    codecOptions = codec;
                    enc = codec.type;
                  } else if (type === "Function")
                  // Codec itself.
                  return codec(codecOptions);
                  else throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
                }
              },

              // Define basic encodings
              encodings: {
                internal: function(options) {
                  return {
                    toEncoding: function(str) {
                      return new Buffer(ensureString(str), options.originalEncoding);
                    },
                    fromEncoding: function(buf) {
                      return ensureBuffer(buf).toString(options.originalEncoding);
                    }
                  };
                },
                utf8: "internal",
                ucs2: "internal",
                binary: "internal",
                ascii: "internal",
                base64: "internal",

                // Codepage single-byte encodings.
                singlebyte: function(options) {
                  // Prepare chars if needed
                  if (!options.chars || (options.chars.length !== 128 && options.chars.length !== 256)) throw new Error("Encoding '" + options.type + "' has incorrect 'chars' (must be of len 128 or 256)");

                  if (options.chars.length === 128) options.chars = asciiString + options.chars;

                  if (!options.charsBuf) {
                    options.charsBuf = new Buffer(options.chars, 'ucs2');
                  }

                  if (!options.revCharsBuf) {
                    options.revCharsBuf = new Buffer(65536);
                    var defChar = iconv.defaultCharSingleByte.charCodeAt(0);
                    for (var i = 0; i < options.revCharsBuf.length; i++)
                    options.revCharsBuf[i] = defChar;
                    for (var i = 0; i < options.chars.length; i++)
                    options.revCharsBuf[options.chars.charCodeAt(i)] = i;
                  }

                  return {
                    toEncoding: function(str) {
                      str = ensureString(str);

                      var buf = new Buffer(str.length);
                      var revCharsBuf = options.revCharsBuf;
                      for (var i = 0; i < str.length; i++)
                      buf[i] = revCharsBuf[str.charCodeAt(i)];

                      return buf;
                    },
                    fromEncoding: function(buf) {
                      buf = ensureBuffer(buf);

                      // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
                      var charsBuf = options.charsBuf;
                      var newBuf = new Buffer(buf.length * 2);
                      var idx1 = 0,
                        idx2 = 0;
                      for (var i = 0, _len = buf.length; i < _len; i++) {
                        idx1 = buf[i] * 2;
                        idx2 = i * 2;
                        newBuf[idx2] = charsBuf[idx1];
                        newBuf[idx2 + 1] = charsBuf[idx1 + 1];
                      }
                      return newBuf.toString('ucs2');
                    }
                  };
                },

                // Codepage double-byte encodings.
                table: function(options) {
                  var table = options.table,
                    key, revCharsTable = options.revCharsTable;
                  if (!table) {
                    throw new Error("Encoding '" + options.type + "' has incorect 'table' option");
                  }
                  if (!revCharsTable) {
                    revCharsTable = options.revCharsTable = {};
                    for (key in table) {
                      revCharsTable[table[key]] = parseInt(key);
                    }
                  }

                  return {
                    toEncoding: function(str) {
                      str = ensureString(str);
                      var strLen = str.length;
                      var bufLen = strLen;
                      for (var i = 0; i < strLen; i++)
                      if (str.charCodeAt(i) >> 7) bufLen++;

                      var newBuf = new Buffer(bufLen),
                        gbkcode, unicode,
                        defaultChar = revCharsTable[iconv.defaultCharUnicode.charCodeAt(0)];

                      for (var i = 0, j = 0; i < strLen; i++) {
                        unicode = str.charCodeAt(i);
                        if (unicode >> 7) {
                          gbkcode = revCharsTable[unicode] || defaultChar;
                          newBuf[j++] = gbkcode >> 8; //high byte;
                          newBuf[j++] = gbkcode & 0xFF; //low byte
                        } else { //ascii
                          newBuf[j++] = unicode;
                        }
                      }
                      return newBuf;
                    },
                    fromEncoding: function(buf) {
                      buf = ensureBuffer(buf);
                      var bufLen = buf.length,
                        strLen = 0;
                      for (var i = 0; i < bufLen; i++) {
                        strLen++;
                        if (buf[i] & 0x80) //the high bit is 1, so this byte is gbkcode's high byte.skip next byte
                        i++;
                      }
                      var newBuf = new Buffer(strLen * 2),
                        unicode, gbkcode,
                        defaultChar = iconv.defaultCharUnicode.charCodeAt(0);

                      for (var i = 0, j = 0; i < bufLen; i++, j += 2) {
                        gbkcode = buf[i];
                        if (gbkcode & 0x80) {
                          gbkcode = (gbkcode << 8) + buf[++i];
                          unicode = table[gbkcode] || defaultChar;
                        } else {
                          unicode = gbkcode;
                        }
                        newBuf[j] = unicode & 0xFF; //low byte
                        newBuf[j + 1] = unicode >> 8; //high byte
                      }
                      return newBuf.toString('ucs2');
                    }
                  }
                }
              }
            };

            // Add aliases to convert functions
            iconv.encode = iconv.toEncoding;
            iconv.decode = iconv.fromEncoding;

            // Load other encodings from files in /encodings dir.
            var encodingsDir = __dirname + "/encodings/",
              fs = require('fs');
            fs.readdirSync(encodingsDir).forEach(function(file) {
              if (fs.statSync(encodingsDir + file).isDirectory()) return;
              var encodings = require(encodingsDir + file)
              for (var key in encodings)
              iconv.encodings[key] = encodings[key]
            });

            // Utilities
            var asciiString = '\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f' + ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f';

            var ensureBuffer = function(buf) {
              buf = buf || new Buffer(0);
              return (buf instanceof Buffer) ? buf : new Buffer(buf.toString(), "utf8");
            }

            var ensureString = function(str) {
              str = str || "";
              return (str instanceof String) ? str : str.toString((str instanceof Buffer) ? 'utf8' : undefined);
            }

            var getType = function(obj) {
              return Object.prototype.toString.call(obj).slice(8, - 1);
            }


          });

          require.define("/node_modules/http-browserify/package.json", function(require, module, exports, __dirname, __filename) {
            module.exports = {
              "main": "index.js",
              "browserify": "browser.js"
            }
          });

          require.define("/node_modules/http-browserify/browser.js", function(require, module, exports, __dirname, __filename) {
            var http = module.exports;
            var EventEmitter = require('events').EventEmitter;
            var Request = require('./lib/request');

            http.request = function(params, cb) {
              if (!params) params = {};
              if (!params.host) params.host = window.location.host.split(':')[0];
              if (!params.port) params.port = window.location.port;

              var req = new Request(new xhrHttp, params);
              if (cb) req.on('response', cb);
              return req;
            };

            http.get = function(params, cb) {
              params.method = 'GET';
              var req = http.request(params, cb);
              req.end();
              return req;
            };

            var xhrHttp = (function() {
              if (typeof window === 'undefined') {
                throw new Error('no window object present');
              } else if (window.XMLHttpRequest) {
                return window.XMLHttpRequest;
              } else if (window.ActiveXObject) {
                var axs = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP'];
                for (var i = 0; i < axs.length; i++) {
                  try {
                    var ax = new(window.ActiveXObject)(axs[i]);
                    return function() {
                      if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                      } else {
                        return new(window.ActiveXObject)(axs[i]);
                      }
                    };
                  } catch (e) {}
                }
                throw new Error('ajax not supported in this browser')
              } else {
                throw new Error('ajax not supported in this browser');
              }
            })();

            http.STATUS_CODES = {
              100: 'Continue',
              101: 'Switching Protocols',
              102: 'Processing', // RFC 2518, obsoleted by RFC 4918
              200: 'OK',
              201: 'Created',
              202: 'Accepted',
              203: 'Non-Authoritative Information',
              204: 'No Content',
              205: 'Reset Content',
              206: 'Partial Content',
              207: 'Multi-Status', // RFC 4918
              300: 'Multiple Choices',
              301: 'Moved Permanently',
              302: 'Moved Temporarily',
              303: 'See Other',
              304: 'Not Modified',
              305: 'Use Proxy',
              307: 'Temporary Redirect',
              400: 'Bad Request',
              401: 'Unauthorized',
              402: 'Payment Required',
              403: 'Forbidden',
              404: 'Not Found',
              405: 'Method Not Allowed',
              406: 'Not Acceptable',
              407: 'Proxy Authentication Required',
              408: 'Request Time-out',
              409: 'Conflict',
              410: 'Gone',
              411: 'Length Required',
              412: 'Precondition Failed',
              413: 'Request Entity Too Large',
              414: 'Request-URI Too Large',
              415: 'Unsupported Media Type',
              416: 'Requested Range Not Satisfiable',
              417: 'Expectation Failed',
              418: 'I\'m a teapot', // RFC 2324
              422: 'Unprocessable Entity', // RFC 4918
              423: 'Locked', // RFC 4918
              424: 'Failed Dependency', // RFC 4918
              425: 'Unordered Collection', // RFC 4918
              426: 'Upgrade Required', // RFC 2817
              500: 'Internal Server Error',
              501: 'Not Implemented',
              502: 'Bad Gateway',
              503: 'Service Unavailable',
              504: 'Gateway Time-out',
              505: 'HTTP Version not supported',
              506: 'Variant Also Negotiates', // RFC 2295
              507: 'Insufficient Storage', // RFC 4918
              509: 'Bandwidth Limit Exceeded',
              510: 'Not Extended' // RFC 2774
            };

          });

          require.define("/node_modules/http-browserify/lib/request.js", function(require, module, exports, __dirname, __filename) {
            var EventEmitter = require('events').EventEmitter;
            var Response = require('./response');
            var isSafeHeader = require('./isSafeHeader');

            var Request = module.exports = function(xhr, params) {
              var self = this;
              self.xhr = xhr;
              self.body = '';

              var uri = params.host + ':' + params.port + (params.path || '/');

              xhr.open(
              params.method || 'GET', (params.scheme || 'http') + '://' + uri,
              true);

              if (params.headers) {
                Object.keys(params.headers).forEach(function(key) {
                  if (!isSafeHeader(key)) return;
                  var value = params.headers[key];
                  if (Array.isArray(value)) {
                    value.forEach(function(v) {
                      xhr.setRequestHeader(key, v);
                    });
                  } else xhr.setRequestHeader(key, value)
                });
              }

              var res = new Response(xhr);
              res.on('ready', function() {
                self.emit('response', res);
              });

              xhr.onreadystatechange = function() {
                res.handle(xhr);
              };
            };

            Request.prototype = new EventEmitter;

            Request.prototype.setHeader = function(key, value) {
              if ((Array.isArray && Array.isArray(value)) || value instanceof Array) {
                for (var i = 0; i < value.length; i++) {
                  this.xhr.setRequestHeader(key, value[i]);
                }
              } else {
                this.xhr.setRequestHeader(key, value);
              }
            };

            Request.prototype.write = function(s) {
              this.body += s;
            };

            Request.prototype.end = function(s) {
              if (s !== undefined) this.write(s);
              this.xhr.send(this.body);
            };

          });

          require.define("/node_modules/http-browserify/lib/response.js", function(require, module, exports, __dirname, __filename) {
            var EventEmitter = require('events').EventEmitter;
            var isSafeHeader = require('./isSafeHeader');

            var Response = module.exports = function(xhr) {
              this.xhr = xhr;
              this.offset = 0;
            };

            Response.prototype = new EventEmitter;

            var capable = {
              streaming: true,
              status2: true
            };

            function parseHeaders(xhr) {
              var lines = xhr.getAllResponseHeaders().split(/\r?\n/);
              var headers = {};
              for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                if (line === '') continue;

                var m = line.match(/^([^:]+):\s*(.*)/);
                if (m) {
                  var key = m[1].toLowerCase(),
                    value = m[2];

                  if (headers[key] !== undefined) {
                    if ((Array.isArray && Array.isArray(headers[key])) || headers[key] instanceof Array) {
                      headers[key].push(value);
                    } else {
                      headers[key] = [headers[key], value];
                    }
                  } else {
                    headers[key] = value;
                  }
                } else {
                  headers[line] = true;
                }
              }
              return headers;
            }

            Response.prototype.getHeader = function(key) {
              var header = this.headers ? this.headers[key.toLowerCase()] : null;
              if (header) return header;

              // Work around Mozilla bug #608735 [https://bugzil.la/608735], which causes
              // getAllResponseHeaders() to return {} if the response is a CORS request.
              // xhr.getHeader still works correctly.
              if (isSafeHeader(key)) {
                return this.xhr.getResponseHeader(key);
              }
              return null;
            };

            Response.prototype.handle = function() {
              var xhr = this.xhr;
              if (xhr.readyState === 2 && capable.status2) {
                try {
                  this.statusCode = xhr.status;
                  this.headers = parseHeaders(xhr);
                } catch (err) {
                  capable.status2 = false;
                }

                if (capable.status2) {
                  this.emit('ready');
                }
              } else if (capable.streaming && xhr.readyState === 3) {
                try {
                  if (!this.statusCode) {
                    this.statusCode = xhr.status;
                    this.headers = parseHeaders(xhr);
                    this.emit('ready');
                  }
                } catch (err) {}

                try {
                  this.write();
                } catch (err) {
                  capable.streaming = false;
                }
              } else if (xhr.readyState === 4) {
                if (!this.statusCode) {
                  this.statusCode = xhr.status;
                  this.emit('ready');
                }
                this.write();

                if (xhr.error) {
                  this.emit('error', xhr.responseText);
                } else this.emit('end');
              }
            };

            Response.prototype.write = function() {
              var xhr = this.xhr;
              if (xhr.responseText.length > this.offset) {
                this.emit('data', xhr.responseText.slice(this.offset));
                this.offset = xhr.responseText.length;
              }
            };

          });

          require.define("/node_modules/http-browserify/lib/isSafeHeader.js", function(require, module, exports, __dirname, __filename) {
            // Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
            var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "content-transfer-encoding", "date", "expect", "host", "keep-alive", "origin", "referer", "set-cookie", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];

            module.exports = function(headerName) {
              if (!headerName) return false;
              return (unsafeHeaders.indexOf(headerName.toLowerCase()) === -1)
            };

          });

          require.alias("http-browserify", "/node_modules/http");

          require.alias("http-browserify", "/node_modules/https");

        },

        "9dfd6fc6391a1af2ed8b4f7ba2b99ed7": // from: browser/shred.bundle.min.js
        function(exports, require, module, __filename, __dirname) {
          var require = function(e, t) {
            var n = require.resolve(e, t || "/"),
              r = require.modules[n];
            if (!r) throw new Error("Failed to resolve module " + e + ", tried " + n);
            var i = r._cached ? r._cached : r();
            return i
          };
          require.paths = [], require.modules = {}, require.extensions = [".js", ".coffee"], require._core = {
            assert: !0,
            events: !0,
            fs: !0,
            path: !0,
            vm: !0
          }, require.resolve = function() {
            return function(e, t) {
              function o(e) {
                if (require.modules[e]) return e;
                for (var t = 0; t < require.extensions.length; t++) {
                  var n = require.extensions[t];
                  if (require.modules[e + n]) return e + n
                }
              }
              function u(e) {
                e = e.replace(/\/+$/, "");
                var t = e + "/package.json";
                if (require.modules[t]) {
                  var r = require.modules[t](),
                    i = r.browserify;
                  if (typeof i == "object" && i.main) {
                    var s = o(n.resolve(e, i.main));
                    if (s) return s
                  } else if (typeof i == "string") {
                    var s = o(n.resolve(e, i));
                    if (s) return s
                  } else if (r.main) {
                    var s = o(n.resolve(e, r.main));
                    if (s) return s
                  }
                }
                return o(e + "/index")
              }
              function a(e, t) {
                var n = f(t);
                for (var r = 0; r < n.length; r++) {
                  var i = n[r],
                    s = o(i + "/" + e);
                  if (s) return s;
                  var a = u(i + "/" + e);
                  if (a) return a
                }
                var s = o(e);
                if (s) return s
              }
              function f(e) {
                var t;
                e === "/" ? t = [""] : t = n.normalize(e).split("/");
                var r = [];
                for (var i = t.length - 1; i >= 0; i--) {
                  if (t[i] === "node_modules") continue;
                  var s = t.slice(0, i + 1).join("/") + "/node_modules";
                  r.push(s)
                }
                return r
              }
              t || (t = "/");
              if (require._core[e]) return e;
              var n = require.modules.path(),
                r = t || ".";
              if (e.match(/^(?:\.\.?\/|\/)/)) {
                var i = o(n.resolve(r, e)) || u(n.resolve(r, e));
                if (i) return i
              }
              var s = a(e, r);
              if (s) return s;
              throw new Error("Cannot find module '" + e + "'")
            }
          }(), require.alias = function(e, t) {
            var n = require.modules.path(),
              r = null;
            try {
              r = require.resolve(e + "/package.json", "/")
            } catch (i) {
              r = require.resolve(e, "/")
            }
            var s = n.dirname(r),
              o = (Object.keys || function(e) {
                var t = [];
                for (var n in e) t.push(n);
                return t
              })(require.modules);
            for (var u = 0; u < o.length; u++) {
              var a = o[u];
              if (a.slice(0, s.length + 1) === s + "/") {
                var f = a.slice(s.length);
                require.modules[t + f] = require.modules[s + f]
              } else a === s && (require.modules[t] = require.modules[s])
            }
          }, require.define = function(e, t) {
            var n = require._core[e] ? "" : require.modules.path().dirname(e),
              r = function(e) {
                return require(e, n)
              };
            r.resolve = function(e) {
              return require.resolve(e, n)
            }, r.modules = require.modules, r.define = require.define;
            var i = {
              exports: {}
            };
            require.modules[e] = function() {
              return require.modules[e]._cached = i.exports, t.call(i.exports, r, i, i.exports, n, e), require.modules[e]._cached = i.exports, i.exports
            }
          }, typeof process == "undefined" && (process = {}), process.nextTick || (process.nextTick = function() {
            var e = [],
              t = typeof window != "undefined" && window.postMessage && window.addEventListener;
            return t && window.addEventListener("message", function(t) {
              if (t.source === window && t.data === "browserify-tick") {
                t.stopPropagation();
                if (e.length > 0) {
                  var n = e.shift();
                  n()
                }
              }
            }, !0),
            function(n) {
              t ? (e.push(n), window.postMessage("browserify-tick", "*")) : setTimeout(n, 0)
            }
          }()), process.title || (process.title = "browser"), process.binding || (process.binding = function(e) {
            if (e === "evals") return require("vm");
            throw new Error("No such module")
          }), process.cwd || (process.cwd = function() {
            return "."
          }), require.define("path", function(e, t, n, r, i) {
            function s(e, t) {
              var n = [];
              for (var r = 0; r < e.length; r++) t(e[r], r, e) && n.push(e[r]);
              return n
            }
            function o(e, t) {
              var n = 0;
              for (var r = e.length; r >= 0; r--) {
                var i = e[r];
                i == "." ? e.splice(r, 1) : i === ".." ? (e.splice(r, 1), n++) : n && (e.splice(r, 1), n--)
              }
              if (t) for (; n--; n) e.unshift("..");
              return e
            }
            var u = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;
            n.resolve = function() {
              var e = "",
                t = !1;
              for (var n = arguments.length; n >= -1 && !t; n--) {
                var r = n >= 0 ? arguments[n] : process.cwd();
                if (typeof r != "string" || !r) continue;
                e = r + "/" + e, t = r.charAt(0) === "/"
              }
              return e = o(s(e.split("/"), function(e) {
                return !!e
              }), !t).join("/"), (t ? "/" : "") + e || "."
            }, n.normalize = function(e) {
              var t = e.charAt(0) === "/",
                n = e.slice(-1) === "/";
              return e = o(s(e.split("/"), function(e) {
                return !!e
              }), !t).join("/"), !e && !t && (e = "."), e && n && (e += "/"), (t ? "/" : "") + e
            }, n.join = function() {
              var e = Array.prototype.slice.call(arguments, 0);
              return n.normalize(s(e, function(e, t) {
                return e && typeof e == "string"
              }).join("/"))
            }, n.dirname = function(e) {
              var t = u.exec(e)[1] || "",
                n = !1;
              return t ? t.length === 1 || n && t.length <= 3 && t.charAt(1) === ":" ? t : t.substring(0, t.length - 1) : "."
            }, n.basename = function(e, t) {
              var n = u.exec(e)[2] || "";
              return t && n.substr(-1 * t.length) === t && (n = n.substr(0, n.length - t.length)), n
            }, n.extname = function(e) {
              return u.exec(e)[3] || ""
            }
          }), require.define("/shred.js", function(e, t, n, r, i) {
            var s = e("ax"),
              o = e("cookiejar"),
              u = o.CookieJar,
              a = function(e) {
                e = e || {}, this.agent = e.agent, this.defaults = e.defaults || {}, this.log = e.logger || new s({
                  level: "info"
                }), this._sharedCookieJar = new u, this.logCurl = e.logCurl || !1
              };
            a.Request = e("./shred/request"), a.Response = e("./shred/response"), a.prototype = {
              request: function(e) {
                e.logger = this.log, e.logCurl = e.logCurl || this.logCurl, e.cookieJar = "cookieJar" in e ? e.cookieJar : this._sharedCookieJar, e.agent = e.agent || this.agent;
                for (var t in this.defaults) this.defaults.hasOwnProperty(t) && !e[t] && (e[t] = this.defaults[t]);
                return new a.Request(e)
              }
            }, "get put post delete".split(" ").forEach(function(e) {
              a.prototype[e] = function(t) {
                return t.method = e, this.request(t)
              }
            }), t.exports = a
          }), require.define("/node_modules/ax/package.json", function(e, t, n, r, i) {
            t.exports = {
              main: "./lib/ax.js"
            }
          }), require.define("/node_modules/ax/lib/ax.js", function(e, t, n, r, i) {
            var s = e("util").inspect,
              o = e("fs"),
              u = function(e, t) {
                var n = e == "debug" || e == "error";
                return t ? typeof t == "object" ? t instanceof Error && n ? t.stack : s(t) : t.toString() : t.toString()
              }, a = function(e) {
                return this
              }, f = function(e, t) {
                return function(t) {
                  return this.stream.write(this.format(e, t) + "\n"), this
                }
              }, l = function(e) {
                var t = this,
                  e = e || {};
                e.level = e.level || "info", e.timestamp = e.timestamp || !0, e.prefix = e.prefix || "", t.options = e, t.options.module && (t.options.prefix = t.options.module), t.options.file ? t.stream = o.createWriteStream(t.options.file, {
                  flags: "a"
                }) : process.title === "node" ? t.stream = process.stderr : process.title === "browser" && (t.stream = function() {
                  return console[t.options.level].apply(console, arguments)
                });
                switch (t.options.level) {
                case "debug":
                  ["debug", "info", "warn"].forEach(function(e) {
                    t[e] = l.writer(e)
                  });
                case "info":
                  ["info", "warn"].forEach(function(e) {
                    t[e] = l.writer(e)
                  });
                case "warn":
                  t.warn = l.writer("warn")
                }
              };
            l.writer = function(e) {
              return function(t) {
                var n = this;
                process.title === "node" ? n.stream.write(n.format(e, t) + "\n") : process.title === "browser" && n.stream(n.format(e, t) + "\n")
              }
            }, l.prototype = {
              info: function() {},
              debug: function() {},
              warn: function() {},
              error: l.writer("error"),
              format: function(e, t) {
                if (!t) return "";
                var n = this,
                  r = n.options.prefix,
                  i = n.options.timestamp ? " " + (new Date).toISOString() : "";
                return r + i + ": " + t
              }
            }, t.exports = l
          }), require.define("util", function(e, t, n, r, i) {}), require.define("fs", function(e, t, n, r, i) {}), require.define("/node_modules/cookiejar/package.json", function(e, t, n, r, i) {
            t.exports = {
              main: "cookiejar.js"
            }
          }), require.define("/node_modules/cookiejar/cookiejar.js", function(e, t, n, r, i) {
            n.CookieAccessInfo = CookieAccessInfo = function o(e, t, n, r) {
              return this instanceof o ? (this.domain = e || undefined, this.path = t || "/", this.secure = !! n, this.script = !! r, this) : new o(e, t, n, r)
            }, n.Cookie = Cookie = function u(e) {
              return e instanceof u ? e : this instanceof u ? (this.name = null, this.value = null, this.expiration_date = Infinity, this.path = "/", this.domain = null, this.secure = !1, this.noscript = !1, e && this.parse(e), this) : new u(e)
            }, Cookie.prototype.toString = function a() {
              var e = [this.name + "=" + this.value];
              return this.expiration_date !== Infinity && e.push("expires=" + (new Date(this.expiration_date)).toGMTString()), this.domain && e.push("domain=" + this.domain), this.path && e.push("path=" + this.path), this.secure && e.push("secure"), this.noscript && e.push("httponly"), e.join("; ")
            }, Cookie.prototype.toValueString = function() {
              return this.name + "=" + this.value
            };
            var s = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
            Cookie.prototype.parse = function(t) {
              if (this instanceof Cookie) {
                var n = t.split(";"),
                  r = n[0].match(/([^=]+)=((?:.|\n)*)/),
                  i = r[1],
                  s = r[2];
                this.name = i, this.value = s;
                for (var o = 1; o < n.length; o++) {
                  r = n[o].match(/([^=]+)(?:=((?:.|\n)*))?/), i = r[1].trim().toLowerCase(), s = r[2];
                  switch (i) {
                  case "httponly":
                    this.noscript = !0;
                    break;
                  case "expires":
                    this.expiration_date = s ? Number(Date.parse(s)) : Infinity;
                    break;
                  case "path":
                    this.path = s ? s.trim() : "";
                    break;
                  case "domain":
                    this.domain = s ? s.trim() : "";
                    break;
                  case "secure":
                    this.secure = !0
                  }
                }
                return this
              }
              return (new Cookie).parse(t)
            }, Cookie.prototype.matches = function(t) {
              return this.noscript && t.script || this.secure && !t.secure || !this.collidesWith(t) ? !1 : !0
            }, Cookie.prototype.collidesWith = function(t) {
              if (this.path && !t.path || this.domain && !t.domain) return !1;
              if (this.path && t.path.indexOf(this.path) !== 0) return !1;
              if (this.domain === t.domain) return !0;
              if (this.domain && this.domain.charAt(0) === ".") {
                var n = t.domain.indexOf(this.domain.slice(1));
                if (n === -1 || n !== t.domain.length - this.domain.length + 1) return !1
              } else if (this.domain) return !1;
              return !0
            }, n.CookieJar = CookieJar = function f() {
              if (this instanceof f) {
                var e = {};
                return this.setCookie = function(n) {
                  n = Cookie(n);
                  var r = n.expiration_date <= Date.now();
                  if (n.name in e) {
                    var i = e[n.name];
                    for (var s = 0; s < i.length; s++) {
                      var o = i[s];
                      if (o.collidesWith(n)) return r ? (i.splice(s, 1), i.length === 0 && delete e[n.name], !1) : i[s] = n
                    }
                    return r ? !1 : (i.push(n), n)
                  }
                  return r ? !1 : e[n.name] = [n]
                }, this.getCookie = function(n, r) {
                  var i = e[n];
                  for (var s = 0; s < i.length; s++) {
                    var o = i[s];
                    if (o.expiration_date <= Date.now()) {
                      i.length === 0 && delete e[o.name];
                      continue
                    }
                    if (o.matches(r)) return o
                  }
                }, this.getCookies = function(n) {
                  var r = [];
                  for (var i in e) {
                    var s = this.getCookie(i, n);
                    s && r.push(s)
                  }
                  return r.toString = function o() {
                    return r.join(":")
                  }, r.toValueString = function() {
                    return r.map(function(e) {
                      return e.toValueString()
                    }).join(";")
                  }, r
                }, this
              }
              return new f
            }, CookieJar.prototype.setCookies = function(t) {
              t = Array.isArray(t) ? t : t.split(s);
              var n = [];
              for (var r = 0; r < t.length; r++) {
                var i = Cookie(t[r]);
                this.setCookie(i) && n.push(i)
              }
              return n
            }
          }), require.define("/shred/request.js", function(e, t, n, r, i) {
            var s = e("http"),
              o = e("https"),
              u = e("./parseUri"),
              a = e("events").EventEmitter,
              f = e("sprintf").sprintf,
              l = e("./response"),
              c = e("./mixins/headers"),
              h = e("./content"),
              p = s.STATUS_CODES || {
                100: "Continue",
                101: "Switching Protocols",
                102: "Processing",
                200: "OK",
                201: "Created",
                202: "Accepted",
                203: "Non-Authoritative Information",
                204: "No Content",
                205: "Reset Content",
                206: "Partial Content",
                207: "Multi-Status",
                300: "Multiple Choices",
                301: "Moved Permanently",
                302: "Moved Temporarily",
                303: "See Other",
                304: "Not Modified",
                305: "Use Proxy",
                307: "Temporary Redirect",
                400: "Bad Request",
                401: "Unauthorized",
                402: "Payment Required",
                403: "Forbidden",
                404: "Not Found",
                405: "Method Not Allowed",
                406: "Not Acceptable",
                407: "Proxy Authentication Required",
                408: "Request Time-out",
                409: "Conflict",
                410: "Gone",
                411: "Length Required",
                412: "Precondition Failed",
                413: "Request Entity Too Large",
                414: "Request-URI Too Large",
                415: "Unsupported Media Type",
                416: "Requested Range Not Satisfiable",
                417: "Expectation Failed",
                418: "I'm a teapot",
                422: "Unprocessable Entity",
                423: "Locked",
                424: "Failed Dependency",
                425: "Unordered Collection",
                426: "Upgrade Required",
                500: "Internal Server Error",
                501: "Not Implemented",
                502: "Bad Gateway",
                503: "Service Unavailable",
                504: "Gateway Time-out",
                505: "HTTP Version not supported",
                506: "Variant Also Negotiates",
                507: "Insufficient Storage",
                509: "Bandwidth Limit Exceeded",
                510: "Not Extended"
              }, d = function(e) {
                this.log = e.logger, this.cookieJar = e.cookieJar, this.encoding = e.encoding, this.logCurl = e.logCurl, v(this, e || {}), m(this)
              };
            Object.defineProperties(d.prototype, {
              url: {
                get: function() {
                  return this.scheme ? f("%s://%s:%s%s", this.scheme, this.host, this.port, (this.proxy ? "/" : this.path) + (this.query ? "?" + this.query : "")) : null
                },
                set: function(e) {
                  return e = u(e), this.scheme = e.protocol, this.host = e.host, this.port = e.port, this.path = e.path, this.query = e.query, this
                },
                enumerable: !0
              },
              headers: {
                get: function() {
                  return this.getHeaders()
                },
                enumerable: !0
              },
              port: {
                get: function() {
                  if (!this._port) switch (this.scheme) {
                  case "https":
                    return this._port = 443;
                  case "http":
                  default:
                    return this._port = 80
                  }
                  return this._port
                },
                set: function(e) {
                  return this._port = e, this
                },
                enumerable: !0
              },
              method: {
                get: function() {
                  return this._method = this._method || "GET"
                },
                set: function(e) {
                  return this._method = e, this
                },
                enumerable: !0
              },
              query: {
                get: function() {
                  return this._query
                },
                set: function(e) {
                  var t = function(e) {
                    var t = "";
                    for (var n in e) t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n]) + "&";
                    return t = t.slice(0, - 1), t
                  };
                  return e ? (typeof e == "object" && (e = t(e)), this._query = e) : this._query = "", this
                },
                enumerable: !0
              },
              parameters: {
                get: function() {
                  return QueryString.parse(this._query || "")
                },
                enumerable: !0
              },
              body: {
                get: function() {
                  return this._body
                },
                set: function(e) {
                  return this._body = new h({
                    data: e,
                    type: this.getHeader("Content-Type")
                  }), this.setHeader("Content-Type", this.content.type), this.setHeader("Content-Length", this.content.length), this
                },
                enumerable: !0
              },
              timeout: {
                get: function() {
                  return this._timeout
                },
                set: function(e) {
                  var t = this,
                    n = 0;
                  return e ? (typeof e == "number" ? n = e : n = (e.milliseconds || 0) + 1e3 * ((e.seconds || 0) + 60 * ((e.minutes || 0) + 60 * (e.hours || 0))), this._timeout = n, this) : this
                },
                enumerable: !0
              }
            }), Object.defineProperty(d.prototype, "content", Object.getOwnPropertyDescriptor(d.prototype, "body")), d.prototype.inspect = function() {
              var e = this,
                t = this.format_headers(),
                n = ["<Shred Request> ", e.method.toUpperCase(), e.url].join(" ");
              return [n, "- Headers:", t].join("\n")
            }, d.prototype.format_headers = function() {
              var e = [],
                t = this._headers;
              for (var n in t) if (t.hasOwnProperty(n)) {
                var r = t[n];
                e.push("	" + n + ": " + r)
              }
              return e.join("\n")
            }, d.prototype.on = function(e, t) {
              var n = this.emitter;
              if (arguments.length === 1 && typeof e == "function") n.on("response", e);
              else if (arguments.length === 1 && typeof e == "object") for (var r in e) e.hasOwnProperty(r) && n.on(r, e[r]);
              else n.on(e, t);
              return this
            }, c.gettersAndSetters(d);
            var v = function(e, t) {
              e.log.debug("Processing request options .."), e.emitter = new a, e.agent = t.agent;
              if (t.on) for (var n in t.on) t.on.hasOwnProperty(n) && e.emitter.on(n, t.on[n]);
              if (!t.url && !t.host) {
                e.emitter.emit("request_error", new Error("No url or url options (host, port, etc.)"));
                return
              }
              t.url && (t.proxy ? (e.url = t.proxy, e.path = t.url) : e.url = t.url), e.query = t.query || t.parameters || e.query, e.method = t.method, e.setHeader("user-agent", t.agent || "Shred"), e.setHeaders(t.headers);
              if (e.cookieJar) {
                var r = e.cookieJar.getCookies(CookieAccessInfo(e.host, e.path));
                if (r.length) {
                  var i = e.getHeader("cookie") || "";
                  for (var s = 0; s < r.length; ++s) i.length && i[i.length - 1] != ";" && (i += ";"), i += r[s].name + "=" + r[s].value + ";";
                  e.setHeader("cookie", i)
                }
              }
              if (t.body || t.content) e.content = t.body || t.content;
              e.timeout = t.timeout
            }, m = function(e) {
              var t;
              e.log.debug("Creating request .."), e.log.debug(e);
              var n = {
                host: e.host,
                port: e.port,
                method: e.method,
                path: e.path + (e.query ? "?" + e.query : ""),
                headers: e.getHeaders(),
                scheme: e.scheme,
                agent: e.agent
              };
              e.logCurl && g(e);
              var r = e.scheme == "http" ? s : o;
              e._raw = r.request(n, function(n) {
                e.log.debug("Received response .."), clearTimeout(t), n = new l(n, e, function(t) {
                  var n = function(n) {
                    var r = e.emitter,
                      i = p[t.status] ? p[t.status].toLowerCase() : null;
                    r.listeners(t.status).length > 0 || r.listeners(i).length > 0 ? (r.emit(t.status, t), r.emit(i, t)) : r.listeners(n).length > 0 ? r.emit(n, t) : t.isRedirect || r.emit("response", t)
                  };
                  t.isRedirect ? (e.log.debug("Redirecting to " + t.getHeader("Location")), e.url = t.getHeader("Location"), n("redirect"), m(e)) : t.isError ? n("error") : n("success")
                })
              }), e._raw.on("error", function(t) {
                e.emitter.emit("request_error", t)
              }), e._raw.on("socket", function(t) {
                e.emitter.emit("socket", t)
              }), e._raw.on("socket", function() {
                e._raw.socket.on("timeout", function() {
                  e._raw.abort()
                })
              }), e.content && (e.log.debug("Streaming body: '" + e.content.body.slice(0, 59) + "' ... "), e._raw.write(e.content.body)), e.timeout && (t = setTimeout(function() {
                e.log.debug("Timeout fired, aborting request ..."), e._raw.abort(), e.emitter.emit("timeout", e)
              }, e.timeout)), e.log.debug("Sending request ..."), e._raw.end()
            }, g = function(e) {
              var t = e.getHeaders(),
                n = "";
              for (var r in t) n += '-H "' + r + ": " + t[r] + '" ';
              var i = "";
              e.content && (i += "-d '" + e.content.body + " ");
              var s = e.query ? "?" + e.query : "";
              console.log("curl -X " + e.method.toUpperCase() + " " + e.scheme + "://" + e.host + ":" + e.port + e.path + s + " " + n + i)
            };
            t.exports = d
          }), require.define("http", function(e, t, n, r, i) {}), require.define("https", function(e, t, n, r, i) {}), require.define("/shred/parseUri.js", function(e, t, n, r, i) {
            function s(e) {
              var t = s.options,
                n = t.parser[t.strictMode ? "strict" : "loose"].exec(e),
                r = {}, i = 14;
              while (i--) r[t.key[i]] = n[i] || "";
              return r[t.q.name] = {}, r[t.key[12]].replace(t.q.parser, function(e, n, i) {
                n && (r[t.q.name][n] = i)
              }), r
            }
            s.options = {
              strictMode: !1,
              key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
              q: {
                name: "queryKey",
                parser: /(?:^|&)([^&=]*)=?([^&]*)/g
              },
              parser: {
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
              }
            }, t.exports = s
          }), require.define("events", function(e, t, n, r, i) {
            process.EventEmitter || (process.EventEmitter = function() {});
            var s = n.EventEmitter = process.EventEmitter,
              o = typeof Array.isArray == "function" ? Array.isArray : function(e) {
                return Object.toString.call(e) === "[object Array]"
              }, u = 10;
            s.prototype.setMaxListeners = function(e) {
              this._events || (this._events = {}), this._events.maxListeners = e
            }, s.prototype.emit = function(e) {
              if (e === "error") if (!this._events || !this._events.error || o(this._events.error) && !this._events.error.length) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
              if (!this._events) return !1;
              var t = this._events[e];
              if (!t) return !1;
              if (typeof t == "function") {
                switch (arguments.length) {
                case 1:
                  t.call(this);
                  break;
                case 2:
                  t.call(this, arguments[1]);
                  break;
                case 3:
                  t.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  var n = Array.prototype.slice.call(arguments, 1);
                  t.apply(this, n)
                }
                return !0
              }
              if (o(t)) {
                var n = Array.prototype.slice.call(arguments, 1),
                  r = t.slice();
                for (var i = 0, s = r.length; i < s; i++) r[i].apply(this, n);
                return !0
              }
              return !1
            }, s.prototype.addListener = function(e, t) {
              if ("function" != typeof t) throw new Error("addListener only takes instances of Function");
              this._events || (this._events = {}), this.emit("newListener", e, t);
              if (!this._events[e]) this._events[e] = t;
              else if (o(this._events[e])) {
                if (!this._events[e].warned) {
                  var n;
                  this._events.maxListeners !== undefined ? n = this._events.maxListeners : n = u, n && n > 0 && this._events[e].length > n && (this._events[e].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[e].length), console.trace())
                }
                this._events[e].push(t)
              } else this._events[e] = [this._events[e], t];
              return this
            }, s.prototype.on = s.prototype.addListener, s.prototype.once = function(e, t) {
              var n = this;
              return n.on(e, function r() {
                n.removeListener(e, r), t.apply(this, arguments)
              }), this
            }, s.prototype.removeListener = function(e, t) {
              if ("function" != typeof t) throw new Error("removeListener only takes instances of Function");
              if (!this._events || !this._events[e]) return this;
              var n = this._events[e];
              if (o(n)) {
                var r = n.indexOf(t);
                if (r < 0) return this;
                n.splice(r, 1), n.length == 0 && delete this._events[e]
              } else this._events[e] === t && delete this._events[e];
              return this
            }, s.prototype.removeAllListeners = function(e) {
              return e && this._events && this._events[e] && (this._events[e] = null), this
            }, s.prototype.listeners = function(e) {
              return this._events || (this._events = {}), this._events[e] || (this._events[e] = []), o(this._events[e]) || (this._events[e] = [this._events[e]]), this._events[e]
            }
          }), require.define("/node_modules/sprintf/package.json", function(e, t, n, r, i) {
            t.exports = {
              main: "./lib/sprintf"
            }
          }), require.define("/node_modules/sprintf/lib/sprintf.js", function(e, t, n, r, i) {
            var s = function() {
              function e(e) {
                return Object.prototype.toString.call(e).slice(8, - 1).toLowerCase()
              }
              function t(e, t) {
                for (var n = []; t > 0; n[--t] = e);
                return n.join("")
              }
              var n = function() {
                return n.cache.hasOwnProperty(arguments[0]) || (n.cache[arguments[0]] = n.parse(arguments[0])), n.format.call(null, n.cache[arguments[0]], arguments)
              };
              return n.format = function(n, r) {
                var i = 1,
                  o = n.length,
                  u = "",
                  a, f = [],
                  l, c, h, p, d, v;
                for (l = 0; l < o; l++) {
                  u = e(n[l]);
                  if (u === "string") f.push(n[l]);
                  else if (u === "array") {
                    h = n[l];
                    if (h[2]) {
                      a = r[i];
                      for (c = 0; c < h[2].length; c++) {
                        if (!a.hasOwnProperty(h[2][c])) throw s('[sprintf] property "%s" does not exist', h[2][c]);
                        a = a[h[2][c]]
                      }
                    } else h[1] ? a = r[h[1]] : a = r[i++];
                    if (/[^s]/.test(h[8]) && e(a) != "number") throw s("[sprintf] expecting number but found %s", e(a));
                    switch (h[8]) {
                    case "b":
                      a = a.toString(2);
                      break;
                    case "c":
                      a = String.fromCharCode(a);
                      break;
                    case "d":
                      a = parseInt(a, 10);
                      break;
                    case "e":
                      a = h[7] ? a.toExponential(h[7]) : a.toExponential();
                      break;
                    case "f":
                      a = h[7] ? parseFloat(a).toFixed(h[7]) : parseFloat(a);
                      break;
                    case "o":
                      a = a.toString(8);
                      break;
                    case "s":
                      a = (a = String(a)) && h[7] ? a.substring(0, h[7]) : a;
                      break;
                    case "u":
                      a = Math.abs(a);
                      break;
                    case "x":
                      a = a.toString(16);
                      break;
                    case "X":
                      a = a.toString(16).toUpperCase()
                    }
                    a = /[def]/.test(h[8]) && h[3] && a >= 0 ? "+" + a : a, d = h[4] ? h[4] == "0" ? "0" : h[4].charAt(1) : " ", v = h[6] - String(a).length, p = h[6] ? t(d, v) : "", f.push(h[5] ? a + p : p + a)
                  }
                }
                return f.join("")
              }, n.cache = {}, n.parse = function(e) {
                var t = e,
                  n = [],
                  r = [],
                  i = 0;
                while (t) {
                  if ((n = /^[^\x25]+/.exec(t)) !== null) r.push(n[0]);
                  else if ((n = /^\x25{2}/.exec(t)) !== null) r.push("%");
                  else {
                    if ((n = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(t)) === null) throw "[sprintf] huh?";
                    if (n[2]) {
                      i |= 1;
                      var s = [],
                        o = n[2],
                        u = [];
                      if ((u = /^([a-z_][a-z_\d]*)/i.exec(o)) === null) throw "[sprintf] huh?";
                      s.push(u[1]);
                      while ((o = o.substring(u[0].length)) !== "") if ((u = /^\.([a-z_][a-z_\d]*)/i.exec(o)) !== null) s.push(u[1]);
                      else {
                        if ((u = /^\[(\d+)\]/.exec(o)) === null) throw "[sprintf] huh?";
                        s.push(u[1])
                      }
                      n[2] = s
                    } else i |= 2;
                    if (i === 3) throw "[sprintf] mixing positional and named placeholders is not (yet) supported";
                    r.push(n)
                  }
                  t = t.substring(n[0].length)
                }
                return r
              }, n
            }(),
              o = function(e, t) {
                return t.unshift(e), s.apply(null, t)
              };
            n.sprintf = s, n.vsprintf = o
          }), require.define("/shred/response.js", function(e, t, n, r, i) {
            var s = e("./content"),
              o = e("./mixins/headers"),
              u = e("cookiejar"),
              a = u.Cookie,
              f = null;
            try {
              f = e("zlib")
            } catch (l) {
              console.warn("no zlib library")
            }
            var c = null;
            try {
              c = e("iconv-lite")
            } catch (l) {
              console.warn("no iconv library")
            }
            var h = function(e, t, n) {
              var r = this;
              this._raw = e, this._setHeaders.call(this, e.headers);
              if (t.cookieJar && this.getHeader("set-cookie")) {
                var i = this.getHeader("set-cookie"),
                  o = [],
                  u;
                for (var l = 0; l < i.length; l++) {
                  var h = i[l];
                  if (!h) continue;
                  h.match(/domain\=/i) || (h += "; domain=" + t.host), h.match(/path\=/i) || (h += "; path=" + t.path);
                  try {
                    u = new a(h), u && o.push(u)
                  } catch (p) {
                    console.warn("Tried to set bad cookie: " + h)
                  }
                }
                t.cookieJar.setCookies(o)
              }
              this.request = t, this.client = t.client, this.log = this.request.log;
              var d = [],
                v = 0;
              e.on("data", function(e) {
                d.push(e), v += e.length
              }), e.on("end", function() {
                var e;
                if (typeof Buffer == "undefined") e = d.join("");
                else {
                  e = new Buffer(v);
                  for (var t = 0, i = 0; t < d.length; t++) d[t].copy(e, i), i += d[t].length
                }
                var o = function(e) {
                  r._body = new s({
                    body: e,
                    type: r.getHeader("Content-Type")
                  }), n(r)
                };
                f && r.getHeader("Content-Encoding") === "gzip" ? f.gunzip(e, function(t, n) {
                  c && r.request.encoding ? e = c.fromEncoding(n, r.request.encoding) : e = n.toString(), o(e)
                }) : (r.request.encoding && (e = c.fromEncoding(e, r.request.encoding)), o(e))
              })
            };
            h.prototype = {
              inspect: function() {
                var e = this,
                  t = this.format_headers(),
                  n = ["<Shred Response> ", e.status].join(" ");
                return [n, "- Headers:", t].join("\n")
              },
              format_headers: function() {
                var e = [],
                  t = this._headers;
                for (var n in t) if (t.hasOwnProperty(n)) {
                  var r = t[n];
                  e.push("	" + n + ": " + r)
                }
                return e.join("\n")
              }
            }, Object.defineProperties(h.prototype, {
              status: {
                get: function() {
                  return this._raw.statusCode
                },
                enumerable: !0
              },
              body: {
                get: function() {
                  return this._body
                }
              },
              content: {
                get: function() {
                  return this.body
                },
                enumerable: !0
              },
              isRedirect: {
                get: function() {
                  return this.status > 299 && this.status < 400 && this.getHeader("Location")
                },
                enumerable: !0
              },
              isError: {
                get: function() {
                  return this.status === 0 || this.status > 399
                },
                enumerable: !0
              }
            }), o.getters(h), o.privateSetters(h);
            var p = h.prototype.getHeader;
            h.prototype.getHeader = function(e) {
              return p.call(this, e) || typeof this._raw.getHeader == "function" && this._raw.getHeader(e)
            }, t.exports = h
          }), require.define("/shred/content.js", function(e, t, n, r, i) {
            var s = function(e) {
              this.body = e.body, this.data = e.data, this.type = e.type
            };
            s.prototype = {}, Object.defineProperties(s.prototype, {
              type: {
                get: function() {
                  if (this._type) return this._type;
                  if (this._data) switch (typeof this._data) {
                  case "string":
                    return "text/plain";
                  case "object":
                    return "application/json"
                  }
                  return "text/plain"
                },
                set: function(e) {
                  return this._type = e, this
                },
                enumerable: !0
              },
              data: {
                get: function() {
                  return this._body ? this.processor.parser(this._body) : this._data
                },
                set: function(e) {
                  return this._body && e && a.setDataWithBody(this), this._data = e, this
                },
                enumerable: !0
              },
              body: {
                get: function() {
                  return this._data ? this.processor.stringify(this._data) : this.processor.stringify(this._body)
                },
                set: function(e) {
                  return this._data && e && a.setBodyWithData(this), this._body = e, this
                },
                enumerable: !0
              },
              processor: {
                get: function() {
                  var e = s.processors[this.type];
                  if (e) return e;
                  var t = this.type.split(";")[0],
                    n = t.split(/\+|\//);
                  for (var r = 0, i = n.length; r < i; r++) e = s.processors[n[r]];
                  return e || {
                    parser: o,
                    stringify: u
                  }
                },
                enumerable: !0
              },
              length: {
                get: function() {
                  return typeof Buffer != "undefined" ? Buffer.byteLength(this.body) : this.body.length
                }
              }
            }), s.processors = {}, s.registerProcessor = function(e, t) {
              e.forEach ? e.forEach(function(e) {
                s.processors[e] = t
              }) : s.processors[e] = t
            };
            var o = function(e) {
              return e
            }, u = function(e) {
              return e.toString()
            };
            s.registerProcessor(["text/html", "text/plain", "text"], {
              parser: o,
              stringify: u
            }), s.registerProcessor(["application/json; charset=utf-8", "application/json", "json"], {
              parser: function(e) {
                return JSON.parse(e)
              },
              stringify: function(e) {
                return JSON.stringify(e)
              }
            });
            var a = {
              setDataWithBody: function(e) {
                throw new Error("Attempt to set data attribute of a content object when the body attributes was already set.")
              },
              setBodyWithData: function(e) {
                throw new Error("Attempt to set body attribute of a content object when the data attributes was already set.")
              }
            };
            t.exports = s
          }), require.define("/shred/mixins/headers.js", function(e, t, n, r, i) {
            var s = function(e) {
              return e.toLowerCase().replace("_", "-").replace(/(^|-)(\w)/g, function(e) {
                return e.toUpperCase()
              })
            }, o = function(e) {
              return {}
            }, u = function(e) {
              return e._headers || (e._headers = o(e))
            }, a = function(e, t) {
              return u(e)[s(t)]
            }, f = function(e, t) {
              var n = t && t.length > 0 ? t : Object.keys(u(e)),
                r = n.reduce(function(t, n) {
                  return t[n] = a(e, n), t
                }, {});
              return Object.freeze(r), r
            }, l = function(e, t, n) {
              return u(e)[s(t)] = n, e
            }, c = function(e, t) {
              for (var n in t) l(e, n, t[n]);
              return this
            };
            t.exports = {
              getters: function(e) {
                e.prototype.getHeader = function(e) {
                  return a(this, e)
                }, e.prototype.getHeaders = function() {
                  return f(this, arguments)
                }
              },
              privateSetters: function(e) {
                e.prototype._setHeader = function(e, t) {
                  return l(this, e, t)
                }, e.prototype._setHeaders = function(e) {
                  return c(this, e)
                }
              },
              setters: function(e) {
                e.prototype.setHeader = function(e, t) {
                  return l(this, e, t)
                }, e.prototype.setHeaders = function(e) {
                  return c(this, e)
                }
              },
              gettersAndSetters: function(e) {
                e.prototype.getHeader = function(e) {
                  return a(this, e)
                }, e.prototype.getHeaders = function() {
                  return f(this, arguments)
                }, e.prototype.setHeader = function(e, t) {
                  return l(this, e, t)
                }, e.prototype.setHeaders = function(e) {
                  return c(this, e)
                }
              }
            }
          }), require.define("/node_modules/iconv-lite/package.json", function(e, t, n, r, i) {
            t.exports = {}
          }), require.define("/node_modules/iconv-lite/index.js", function(e, t, n, r, i) {
            var s = t.exports = {
              toEncoding: function(e, t) {
                return s.getCodec(t).toEncoding(e)
              },
              fromEncoding: function(e, t) {
                return s.getCodec(t).fromEncoding(e)
              },
              defaultCharUnicode: "�",
              defaultCharSingleByte: "?",
              getCodec: function(e) {
                var t = e || "utf8",
                  n = undefined;
                for (;;) {
                  c(t) === "String" && (t = t.replace(/[- ]/g, "").toLowerCase());
                  var r = s.encodings[t],
                    i = c(r);
                  if (i === "String") n = {
                    originalEncoding: t
                  }, t = r;
                  else {
                    if (i !== "Object" || r.type == undefined) {
                      if (i === "Function") return r(n);
                      throw new Error("Encoding not recognized: '" + e + "' (searched as: '" + t + "')")
                    }
                    n = r, t = r.type
                  }
                }
              },
              encodings: {
                internal: function(e) {
                  return {
                    toEncoding: function(t) {
                      return new Buffer(l(t), e.originalEncoding)
                    },
                    fromEncoding: function(t) {
                      return f(t).toString(e.originalEncoding)
                    }
                  }
                },
                utf8: "internal",
                ucs2: "internal",
                binary: "internal",
                ascii: "internal",
                base64: "internal",
                singlebyte: function(e) {
                  if (!e.chars || e.chars.length !== 128 && e.chars.length !== 256) throw new Error("Encoding '" + e.type + "' has incorrect 'chars' (must be of len 128 or 256)");
                  e.chars.length === 128 && (e.chars = a + e.chars), e.charsBuf || (e.charsBuf = new Buffer(e.chars, "ucs2"));
                  if (!e.revCharsBuf) {
                    e.revCharsBuf = new Buffer(65536);
                    var t = s.defaultCharSingleByte.charCodeAt(0);
                    for (var n = 0; n < e.revCharsBuf.length; n++) e.revCharsBuf[n] = t;
                    for (var n = 0; n < e.chars.length; n++) e.revCharsBuf[e.chars.charCodeAt(n)] = n
                  }
                  return {
                    toEncoding: function(t) {
                      t = l(t);
                      var n = new Buffer(t.length),
                        r = e.revCharsBuf;
                      for (var i = 0; i < t.length; i++) n[i] = r[t.charCodeAt(i)];
                      return n
                    },
                    fromEncoding: function(t) {
                      t = f(t);
                      var n = e.charsBuf,
                        r = new Buffer(t.length * 2),
                        i = 0,
                        s = 0;
                      for (var o = 0, u = t.length; o < u; o++) i = t[o] * 2, s = o * 2, r[s] = n[i], r[s + 1] = n[i + 1];
                      return r.toString("ucs2")
                    }
                  }
                },
                table: function(e) {
                  var t = e.table,
                    n, r = e.revCharsTable;
                  if (!t) throw new Error("Encoding '" + e.type + "' has incorect 'table' option");
                  if (!r) {
                    r = e.revCharsTable = {};
                    for (n in t) r[t[n]] = parseInt(n)
                  }
                  return {
                    toEncoding: function(e) {
                      e = l(e);
                      var t = e.length,
                        n = t;
                      for (var i = 0; i < t; i++) e.charCodeAt(i) >> 7 && n++;
                      var o = new Buffer(n),
                        u, a, f = r[s.defaultCharUnicode.charCodeAt(0)];
                      for (var i = 0, c = 0; i < t; i++) a = e.charCodeAt(i), a >> 7 ? (u = r[a] || f, o[c++] = u >> 8, o[c++] = u & 255) : o[c++] = a;
                      return o
                    },
                    fromEncoding: function(e) {
                      e = f(e);
                      var n = e.length,
                        r = 0;
                      for (var i = 0; i < n; i++) r++, e[i] & 128 && i++;
                      var o = new Buffer(r * 2),
                        u, a, l = s.defaultCharUnicode.charCodeAt(0);
                      for (var i = 0, c = 0; i < n; i++, c += 2) a = e[i], a & 128 ? (a = (a << 8) + e[++i], u = t[a] || l) : u = a, o[c] = u & 255, o[c + 1] = u >> 8;
                      return o.toString("ucs2")
                    }
                  }
                }
              }
            };
            s.encode = s.toEncoding, s.decode = s.fromEncoding;
            var o = r + "/encodings/",
              u = e("fs");
            u.readdirSync(o).forEach(function(t) {
              if (u.statSync(o + t).isDirectory()) return;
              var n = e(o + t);
              for (var r in n) s.encodings[r] = n[r]
            });
            var a = "\0\b	\n\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
              f = function(e) {
                return e = e || new Buffer(0), e instanceof Buffer ? e : new Buffer(e.toString(), "utf8")
              }, l = function(e) {
                return e = e || "", e instanceof String ? e : e.toString(e instanceof Buffer ? "utf8" : undefined)
              }, c = function(e) {
                return Object.prototype.toString.call(e).slice(8, - 1)
              }
          }), require.define("/node_modules/http-browserify/package.json", function(e, t, n, r, i) {
            t.exports = {
              main: "index.js",
              browserify: "browser.js"
            }
          }), require.define("/node_modules/http-browserify/browser.js", function(e, t, n, r, i) {
            var s = t.exports,
              o = e("events").EventEmitter,
              u = e("./lib/request");
            s.request = function(e, t) {
              e || (e = {}), e.host || (e.host = window.location.host.split(":")[0]), e.port || (e.port = window.location.port);
              var n = new u(new a, e);
              return t && n.on("response", t), n
            }, s.get = function(e, t) {
              e.method = "GET";
              var n = s.request(e, t);
              return n.end(), n
            };
            var a = function() {
              if (typeof window == "undefined") throw new Error("no window object present");
              if (window.XMLHttpRequest) return window.XMLHttpRequest;
              if (window.ActiveXObject) {
                var e = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Microsoft.XMLHTTP"];
                for (var t = 0; t < e.length; t++) try {
                  var n = new window.ActiveXObject(e[t]);
                  return function() {
                    if (n) {
                      var r = n;
                      return n = null, r
                    }
                    return new window.ActiveXObject(e[t])
                  }
                } catch (r) {}
                throw new Error("ajax not supported in this browser")
              }
              throw new Error("ajax not supported in this browser")
            }();
            s.STATUS_CODES = {
              100: "Continue",
              101: "Switching Protocols",
              102: "Processing",
              200: "OK",
              201: "Created",
              202: "Accepted",
              203: "Non-Authoritative Information",
              204: "No Content",
              205: "Reset Content",
              206: "Partial Content",
              207: "Multi-Status",
              300: "Multiple Choices",
              301: "Moved Permanently",
              302: "Moved Temporarily",
              303: "See Other",
              304: "Not Modified",
              305: "Use Proxy",
              307: "Temporary Redirect",
              400: "Bad Request",
              401: "Unauthorized",
              402: "Payment Required",
              403: "Forbidden",
              404: "Not Found",
              405: "Method Not Allowed",
              406: "Not Acceptable",
              407: "Proxy Authentication Required",
              408: "Request Time-out",
              409: "Conflict",
              410: "Gone",
              411: "Length Required",
              412: "Precondition Failed",
              413: "Request Entity Too Large",
              414: "Request-URI Too Large",
              415: "Unsupported Media Type",
              416: "Requested Range Not Satisfiable",
              417: "Expectation Failed",
              418: "I'm a teapot",
              422: "Unprocessable Entity",
              423: "Locked",
              424: "Failed Dependency",
              425: "Unordered Collection",
              426: "Upgrade Required",
              500: "Internal Server Error",
              501: "Not Implemented",
              502: "Bad Gateway",
              503: "Service Unavailable",
              504: "Gateway Time-out",
              505: "HTTP Version not supported",
              506: "Variant Also Negotiates",
              507: "Insufficient Storage",
              509: "Bandwidth Limit Exceeded",
              510: "Not Extended"
            }
          }), require.define("/node_modules/http-browserify/lib/request.js", function(e, t, n, r, i) {
            var s = e("events").EventEmitter,
              o = e("./response"),
              u = e("./isSafeHeader"),
              a = t.exports = function(e, t) {
                var n = this;
                n.xhr = e, n.body = "";
                var r = t.host + ":" + t.port + (t.path || "/");
                e.open(t.method || "GET", (t.scheme || "http") + "://" + r, !0), t.headers && Object.keys(t.headers).forEach(function(n) {
                  if (!u(n)) return;
                  var r = t.headers[n];
                  Array.isArray(r) ? r.forEach(function(t) {
                    e.setRequestHeader(n, t)
                  }) : e.setRequestHeader(n, r)
                });
                var i = new o(e);
                i.on("ready", function() {
                  n.emit("response", i)
                }), e.onreadystatechange = function() {
                  i.handle(e)
                }
              };
            a.prototype = new s, a.prototype.setHeader = function(e, t) {
              if (Array.isArray && Array.isArray(t) || t instanceof Array) for (var n = 0; n < t.length; n++) this.xhr.setRequestHeader(e, t[n]);
              else this.xhr.setRequestHeader(e, t)
            }, a.prototype.write = function(e) {
              this.body += e
            }, a.prototype.end = function(e) {
              e !== undefined && this.write(e), this.xhr.send(this.body)
            }
          }), require.define("/node_modules/http-browserify/lib/response.js", function(e, t, n, r, i) {
            function f(e) {
              var t = e.getAllResponseHeaders().split(/\r?\n/),
                n = {};
              for (var r = 0; r < t.length; r++) {
                var i = t[r];
                if (i === "") continue;
                var s = i.match(/^([^:]+):\s*(.*)/);
                if (s) {
                  var o = s[1].toLowerCase(),
                    u = s[2];
                  n[o] !== undefined ? Array.isArray && Array.isArray(n[o]) || n[o] instanceof Array ? n[o].push(u) : n[o] = [n[o], u] : n[o] = u
                } else n[i] = !0
              }
              return n
            }
            var s = e("events").EventEmitter,
              o = e("./isSafeHeader"),
              u = t.exports = function(e) {
                this.xhr = e, this.offset = 0
              };
            u.prototype = new s;
            var a = {
              streaming: !0,
              status2: !0
            };
            u.prototype.getHeader = function(e) {
              var t = this.headers ? this.headers[e.toLowerCase()] : null;
              return t ? t : o(e) ? this.xhr.getResponseHeader(e) : null
            }, u.prototype.handle = function() {
              var e = this.xhr;
              if (e.readyState === 2 && a.status2) {
                try {
                  this.statusCode = e.status, this.headers = f(e)
                } catch (t) {
                  a.status2 = !1
                }
                a.status2 && this.emit("ready")
              } else if (a.streaming && e.readyState === 3) {
                try {
                  this.statusCode || (this.statusCode = e.status, this.headers = f(e), this.emit("ready"))
                } catch (t) {}
                try {
                  this.write()
                } catch (t) {
                  a.streaming = !1
                }
              } else e.readyState === 4 && (this.statusCode || (this.statusCode = e.status, this.emit("ready")), this.write(), e.error ? this.emit("error", e.responseText) : this.emit("end"))
            }, u.prototype.write = function() {
              var e = this.xhr;
              e.responseText.length > this.offset && (this.emit("data", e.responseText.slice(this.offset)), this.offset = e.responseText.length)
            }
          }), require.define("/node_modules/http-browserify/lib/isSafeHeader.js", function(e, t, n, r, i) {
            var s = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "content-transfer-encoding", "date", "expect", "host", "keep-alive", "origin", "referer", "set-cookie", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];
            t.exports = function(e) {
              return e ? s.indexOf(e.toLowerCase()) === -1 : !1
            }
          }), require.alias("http-browserify", "/node_modules/http"), require.alias("http-browserify", "/node_modules/https")
        },

        "89f447aafb7eb2aab8a5865df4376f49": // from: examples/examples.js
        function(exports, require, module, __filename, __dirname) {
          // # Introduction
          //
          // Shred is an HTTP client library intended to simplify the use of Node's
          // built-in HTTP library. In particular, we wanted to make it easier to interact
          // with HTTP-based APIs.
          //
          // # A Simple Example
          //
          // Let's start simple. We're going to use the <a class="logo" href="/">spire<span
          // class="grey">.</span><span class="blue">io</span></a> API as our example.
          // Let's begin by getting the documentation for the API as HTML.

          // First, we need to instantiate a Shred instance. We can re-use this instance
          // over any number of requests. The main purpose of creating an instance is to
          // make it possible for you to provide default options that will be applied
          // across each request for that instance. Later, we also expect to allow you to
          // manage connections on a per-instance basis.
          //
          // For these examples, however, a simple Shred instance will work fine.
          var Shred = require("shred");
          var shred = new Shred;

          // We're going to check our responses with `assert`.
          var assert = require("assert");

          // So now let's get that documentation:
          //
          // We have to let the <a class="logo" href="/">spire<span
          // class="grey">.</span><span class="blue">io</span></a> API know that we want
          // the docs as HTML.
          shred.get({
            url: "http://api.spire.io",
            headers: {
              accept: "text/html"
            },
            on: {
              // Response events can be specified in terms of response codes. More specific
              // events have precedence.
              200: function(response) {
                assert.ok(response.content.body);
                console.log("√ Got API description as HTML");
              },
              // Here, `200` takes precedence over the more generic `response` event. This
              // allows us to avoid writing code like:
              //
              //     if (response.status!=200) { // etc. 
              //
              response: function(response) {
                console.log("We got something besides a 200 response!")
              }
            }
          });

          // We can also chain response handlers and have many handlers
          // for the generic 'response' event.
          shred.get({
            url: "http://api.spire.io",
            headers: {
              accept: "text/html"
            }
          }).on(200, function(response) {
            assert.ok(response.content.body);
            console.log("√ Got API description as HTML");
          }).on(function(response) {
            console.log("We got something besides a 200 response!");
          }).on(function(response) {
            console.log("I'm not so happy about this non 200 response. Launch the missiles!");
          });

          // # Data Conversion
          //
          // Shred provides a very helpful facility for converting content entities to and
          // from Javascript data types. The conversion is based on the content type of the
          // entity.
          //
          // Let's try asking for the API description as `application/json`:

          // First, let's declare a couple of variables we'll be using in later examples.
          var resources, schema;

          shred.get({
            url: "http://api.spire.io",
            headers: {
              accept: "application/json"
            },
            on: {
              // This time, instead of asking for `response.content.body` we'll ask for
              // `response.content.data`. Since Shred knows we asked for JSON, it will
              // attempt to parse the response content as JSON.
              200: function(response) {
                assert.ok(response.content.data);
                // We can treat this as an ordinary Javascript object:
                assert.ok(response.content.data.resources.sessions.url);
                // Let's save some of this for later.
                resources = response.content.data.resources;
                schema = response.content.data.schema["1.0"];
                console.log("√ Got API description as JSON");
              },
              response: function(response) {
                console.log("We got something besides a 200 response!")
              }
            }
          });

          // We can do the same trick to `PUT` or `POST` a Javascript object. Let's go
          // ahead and use our session key to create a new session.

          // This time, we're going to wrap our call to Shred in a function, so that we can
          // use it in a callback.

          var createSession = function() {
            shred.post({
              url: resources.sessions.url,
              headers: {
                accept: schema.session.mediaType,
                // Shred will automatically normalize the header names for you. Here,
                // `content_type` will be normalized to `Content-Type`.
                content_type: schema.account.mediaType
              },
              // This is the new bit. We just pass a Javascript object and Shred converts it
              // for us.
              content: {
                key: "c9KfjaIirRlg9YKpCck97Q-1321321628"
              },
              on: {
                // This time, we want a `201`, which means something (the session) was
                // created by the request. Again, we're freed from having to check the
                // response status.
                201: function(response) {
                  assert.ok(response.content.data);
                  // We'll save the session for future reference
                  resources.session = response.content.data;
                  console.log("√ Created a session.");
                },
                response: function(response) {
                  console.log("We got something besides a 201 response!")
                }
              }
            });
          };

          // We'll call it using `setTimeout` to make sure our `resources` and `schema`
          // variables are initialized properly in the return from the earlier `GET`.
          // Normally, you'd call this in its event handler.
          setTimeout(createSession, 1000);

          // # Error Handling

          // Let's see how Shred error handling works. We'll attempt to create channel
          // using the <a class="logo" href="/">spire<span class="grey">.</span><span
          // class="blue">io</span></a> message service. However, we'll "forget" to include
          // an authorization header. This should give us back a `401: Unauthorized`.

          // Now, we could simply handle this via the `response` event. We could also
          // handle it via the `401` event. But let's use the `error` event instead, just
          // for kicks.

          var createChannel = function() {
            shred.post({
              url: resources.session.resources.channels.url,
              // Normally, we'd pass in a authorization header, too.
              headers: {
                accept: schema.channel.mediaType,
                content_type: schema.channel.mediaType
              },
              // We'll try to create a channel named "foo".
              content: {
                name: "foo"
              },
              on: {
                // The `error` event will fire on any response status above 400.
                error: function(response) {
                  assert.equal(response.status, 401);
                  console.log("√ Handled channel create error.");
                },
                response: function(response) {
                  console.log("We got something besides an error response!")
                }
              }
            });
          };

          // Again, you'd normally call this function in an event handler.
          setTimeout(createChannel, 2000);

          // You can also handle redirects explicitly using the `redirect` event.
          // (Normally, Shred handles them for you.)

          // # Other Resources
          //
          // - **Code.** Check out our [GitHub
          //   repository](https://github.com/spire-io/shred). Don't hesitate to send us
          //   pull requests!
          // - **Bugs.** Please file any [bugs or feature
          //   requests](https://github.com/spire-io/shred/issues)!

        },

        "91ead0407d37ff5af5880eafdd045b2a": // from: lib/shred.js
        function(exports, require, module, __filename, __dirname) {
          // Shred is an HTTP client library intended to simplify the use of Node's
          // built-in HTTP library. In particular, we wanted to make it easier to interact
          // with HTTP-based APIs.
          // 
          // See the [examples](./examples.html) for more details.

          // Ax is a nice logging library we wrote. You can use any logger, providing it
          // has `info`, `warn`, `debug`, and `error` methods that take a string.
          var Ax = require("ax"),
            CookieJarLib = require("cookiejar"),
            CookieJar = CookieJarLib.CookieJar;

          // Shred takes some options, including a logger and request defaults.

          var Shred = function(options) {
            options = (options || {});
            this.agent = options.agent;
            this.defaults = options.defaults || {};
            this.log = options.logger || (new Ax({
              level: "info"
            }));
            this._sharedCookieJar = new CookieJar();
            this.logCurl = options.logCurl || false;
          };

          // Most of the real work is done in the request and reponse classes.

          Shred.Request = require("./shred/request");
          Shred.Response = require("./shred/response");
          Shred.registerProcessor = require("./shred/content").registerProcessor;

          // The `request` method kicks off a new request, instantiating a new `Request`
          // object and passing along whatever default options we were given.

          Shred.prototype = {
            request: function(options) {
              options.logger = options.logger || this.log;
              options.logCurl = options.logCurl || this.logCurl;
              // allow users to set cookieJar = null
              options.cookieJar = ('cookieJar' in options) ? options.cookieJar : this._sharedCookieJar;
              options.agent = options.agent || this.agent;
              // fill in default options
              for (var key in this.defaults) {
                if (this.defaults.hasOwnProperty(key) && !options[key]) {
                  options[key] = this.defaults[key]
                }
              }
              return new Shred.Request(options);
            }
          };

          // Define a bunch of convenience methods so that you don't have to include
          // a `method` property in your request options.

          "get put post delete".split(" ").forEach(function(method) {
            Shred.prototype[method] = function(options) {
              options.method = method;
              return this.request(options);
            };
          });


          module.exports = Shred;

        },

        "097818971e926c40ff8b34e3fa8ecd9f": // from: lib/shred/content.js
        function(exports, require, module, __filename, __dirname) {

          // The purpose of the `Content` object is to abstract away the data conversions
          // to and from raw content entities as strings. For example, you want to be able
          // to pass in a Javascript object and have it be automatically converted into a
          // JSON string if the `content-type` is set to a JSON-based media type.
          // Conversely, you want to be able to transparently get back a Javascript object
          // in the response if the `content-type` is a JSON-based media-type.

          // One limitation of the current implementation is that it [assumes the `charset` is UTF-8](https://github.com/spire-io/shred/issues/5).

          // The `Content` constructor takes an options object, which *must* have either a
          // `body` or `data` property and *may* have a `type` property indicating the
          // media type. If there is no `type` attribute, a default will be inferred.
          var Content = function(options) {
            this.body = options.body;
            this.data = options.data;
            this.type = options.type;
          };

          Content.prototype = {
            // Treat `toString()` as asking for the `content.body`. That is, the raw content entity.
            //
            //     toString: function() { return this.body; }
            //
            // Commented out, but I've forgotten why. :/
          };


          // `Content` objects have the following attributes:
          Object.defineProperties(Content.prototype, {

            // - **type**. Typically accessed as `content.type`, reflects the `content-type`
            //   header associated with the request or response. If not passed as an options
            //   to the constructor or set explicitly, it will infer the type the `data`
            //   attribute, if possible, and, failing that, will default to `text/plain`.
            type: {
              get: function() {
                if (this._type) {
                  return this._type;
                } else {
                  if (this._data) {
                    switch (typeof this._data) {
                    case "string":
                      return "text/plain";
                    case "object":
                      return "application/json";
                    }
                  }
                }
                return "text/plain";
              },
              set: function(value) {
                this._type = value;
                return this;
              },
              enumerable: true
            },

            // - **data**. Typically accessed as `content.data`, reflects the content entity
            //   converted into Javascript data. This can be a string, if the `type` is, say,
            //   `text/plain`, but can also be a Javascript object. The conversion applied is
            //   based on the `processor` attribute. The `data` attribute can also be set
            //   directly, in which case the conversion will be done the other way, to infer
            //   the `body` attribute.
            data: {
              get: function() {
                if (this._body) {
                  return this.processor.parser(this._body);
                } else {
                  return this._data;
                }
              },
              set: function(data) {
                if (this._body && data) Errors.setDataWithBody(this);
                this._data = data;
                return this;
              },
              enumerable: true
            },

            // - **body**. Typically accessed as `content.body`, reflects the content entity
            //   as a UTF-8 string. It is the mirror of the `data` attribute. If you set the
            //   `data` attribute, the `body` attribute will be inferred and vice-versa. If
            //   you attempt to set both, an exception is raised.
            body: {
              get: function() {
                if (this._data) {
                  return this.processor.stringify(this._data);
                } else {
                  return this._body.toString();
                }
              },
              set: function(body) {
                if (this._data && body) Errors.setBodyWithData(this);
                this._body = body;
                return this;
              },
              enumerable: true
            },

            // - **processor**. The functions that will be used to convert to/from `data` and
            //   `body` attributes. You can add processors. The two that are built-in are for
            //   `text/plain`, which is basically an identity transformation and
            //   `application/json` and other JSON-based media types (including custom media
            //   types with `+json`). You can add your own processors. See below.
            processor: {
              get: function() {
                var processor = Content.processors[this.type];
                if (processor) {
                  return processor;
                } else {
                  // Return the first processor that matches any part of the
                  // content type. ex: application/vnd.foobar.baz+json will match json.
                  var main = this.type.split(";")[0];
                  var parts = main.split(/\+|\//);
                  for (var i = 0, l = parts.length; i < l; i++) {
                    processor = Content.processors[parts[i]]
                  }
                  return processor || {
                    parser: identity,
                    stringify: toString
                  };
                }
              },
              enumerable: true
            },

            // - **length**. Typically accessed as `content.length`, returns the length in
            //   bytes of the raw content entity.
            length: {
              get: function() {
                if (typeof Buffer !== 'undefined') {
                  return Buffer.byteLength(this.body);
                }
                return this.body.length;
              }
            }
          });

          Content.processors = {};

          // The `registerProcessor` function allows you to add your own processors to
          // convert content entities. Each processor consists of a Javascript object with
          // two properties:
          // - **parser**. The function used to parse a raw content entity and convert it
          //   into a Javascript data type.
          // - **stringify**. The function used to convert a Javascript data type into a
          //   raw content entity.
          Content.registerProcessor = function(types, processor) {

            // You can pass an array of types that will trigger this processor, or just one.
            // We determine the array via duck-typing here.
            if (types.forEach) {
              types.forEach(function(type) {
                Content.processors[type] = processor;
              });
            } else {
              // If you didn't pass an array, we just use what you pass in.
              Content.processors[types] = processor;
            }
          };

          // Register the identity processor, which is used for text-based media types.
          var identity = function(x) {
            return x;
          }, toString = function(x) {
            return x.toString();
          }
          Content.registerProcessor(
          ["text/html", "text/plain", "text"], {
            parser: identity,
            stringify: toString
          });

          // Register the JSON processor, which is used for JSON-based media types.
          Content.registerProcessor(
          ["application/json; charset=utf-8", "application/json", "json"], {
            parser: function(string) {
              return JSON.parse(string);
            },
            stringify: function(data) {
              return JSON.stringify(data);
            }
          });

          var qs = require('querystring');
          // Register the post processor, which is used for JSON-based media types.
          Content.registerProcessor(
          ["application/x-www-form-urlencoded"], {
            parser: qs.parse,
            stringify: qs.stringify
          });

          // Error functions are defined separately here in an attempt to make the code
          // easier to read.
          var Errors = {
            setDataWithBody: function(object) {
              throw new Error("Attempt to set data attribute of a content object " + "when the body attributes was already set.");
            },
            setBodyWithData: function(object) {
              throw new Error("Attempt to set body attribute of a content object " + "when the data attributes was already set.");
            }
          }
          module.exports = Content;

        },

        "39ac48f00aad0db6221f17af0df5baa7": // from: lib/shred/mixins/headers.js
        function(exports, require, module, __filename, __dirname) {
          // The header mixins allow you to add HTTP header support to any object. This
          // might seem pointless: why not simply use a hash? The main reason is that, per
          // the [HTTP spec](http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2),
          // headers are case-insensitive. So, for example, `content-type` is the same as
          // `CONTENT-TYPE` which is the same as `Content-Type`. Since there is no way to
          // overload the index operator in Javascript, using a hash to represent the
          // headers means it's possible to have two conflicting values for a single
          // header.
          // 
          // The solution to this is to provide explicit methods to set or get headers.
          // This also has the benefit of allowing us to introduce additional variations,
          // including snake case, which we automatically convert to what Matthew King has
          // dubbed "corset case" - the hyphen-separated names with initial caps:
          // `Content-Type`. We use corset-case just in case we're dealing with servers
          // that haven't properly implemented the spec.

          // Convert headers to corset-case. **Example:** `CONTENT-TYPE` will be converted
          // to `Content-Type`.

          var corsetCase = function(string) {
            return string.toLowerCase().replace("_", "-").replace(/(^|-)(\w)/g,

            function(s) {
              return s.toUpperCase();
            });
          };

          // We suspect that `initializeHeaders` was once more complicated ...
          var initializeHeaders = function(object) {
            return {};
          };

          // Access the `_headers` property using lazy initialization. **Warning:** If you
          // mix this into an object that is using the `_headers` property already, you're
          // going to have trouble.
          var $H = function(object) {
            return object._headers || (object._headers = initializeHeaders(object));
          };

          // Hide the implementations as private functions, separate from how we expose them.

          // The "real" `getHeader` function: get the header after normalizing the name.
          var getHeader = function(object, name) {
            return $H(object)[corsetCase(name)];
          };

          // The "real" `getHeader` function: get one or more headers, or all of them
          // if you don't ask for any specifics. 
          var getHeaders = function(object, names) {
            var keys = (names && names.length > 0) ? names : Object.keys($H(object));
            var hash = {};
            for (var i = 0, l = keys.length; i < l; i++) {
              var key = keys[i];
              hash[key] = getHeader(object, key);
            }
            Object.freeze(hash);
            return hash;
          };

          // The "real" `setHeader` function: set a header, after normalizing the name.
          var setHeader = function(object, name, value) {
            $H(object)[corsetCase(name)] = value;
            return object;
          };

          // The "real" `setHeaders` function: set multiple headers based on a hash.
          var setHeaders = function(object, hash) {
            for (var key in hash) {
              setHeader(object, key, hash[key]);
            };
            return this;
          };

          // Here's where we actually bind the functionality to an object. These mixins work by
          // exposing mixin functions. Each function mixes in a specific batch of features.
          module.exports = {

            // Add getters.
            getters: function(constructor) {
              constructor.prototype.getHeader = function(name) {
                return getHeader(this, name);
              };
              constructor.prototype.getHeaders = function() {
                return getHeaders(this, arguments);
              };
            },
            // Add setters but as "private" methods.
            privateSetters: function(constructor) {
              constructor.prototype._setHeader = function(key, value) {
                return setHeader(this, key, value);
              };
              constructor.prototype._setHeaders = function(hash) {
                return setHeaders(this, hash);
              };
            },
            // Add setters.
            setters: function(constructor) {
              constructor.prototype.setHeader = function(key, value) {
                return setHeader(this, key, value);
              };
              constructor.prototype.setHeaders = function(hash) {
                return setHeaders(this, hash);
              };
            },
            // Add both getters and setters.
            gettersAndSetters: function(constructor) {
              constructor.prototype.getHeader = function(name) {
                return getHeader(this, name);
              };
              constructor.prototype.getHeaders = function() {
                return getHeaders(this, arguments);
              };
              constructor.prototype.setHeader = function(key, value) {
                return setHeader(this, key, value);
              };
              constructor.prototype.setHeaders = function(hash) {
                return setHeaders(this, hash);
              };
            },
          };

        },

        "f7da3e52db2923e9c29cde066f306bce": // from: lib/shred/parseUri.js
        function(exports, require, module, __filename, __dirname) {
          // parseUri 1.2.2
          // (c) Steven Levithan <stevenlevithan.com>
          // MIT License

          function parseUri(str) {
            var o = parseUri.options,
              m = o.parser[o.strictMode ? "strict" : "loose"].exec(str),
              uri = {},
              i = 14;

            while (i--) uri[o.key[i]] = m[i] || "";

            uri[o.q.name] = {};
            uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
              if ($1) uri[o.q.name][$1] = $2;
            });

            return uri;
          };

          parseUri.options = {
            strictMode: false,
            key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
            q: {
              name: "queryKey",
              parser: /(?:^|&)([^&=]*)=?([^&]*)/g
            },
            parser: {
              strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
              loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
            }
          };

          module.exports = parseUri;

        },

        "0256ce4a492726f7974cafe8ac0c6b52": // from: lib/shred/request.js
        function(exports, require, module, __filename, __dirname) {
          // The request object encapsulates a request, creating a Node.js HTTP request and
          // then handling the response.

          var HTTP = require("http"),
            HTTPS = require("https"),
            parseUri = require("./parseUri"),
            Emitter = require('events').EventEmitter,
            sprintf = require("sprintf").sprintf,
            Response = require("./response"),
            HeaderMixins = require("./mixins/headers"),
            Content = require("./content");

          var STATUS_CODES = HTTP.STATUS_CODES || {
            100: 'Continue',
            101: 'Switching Protocols',
            102: 'Processing', // RFC 2518, obsoleted by RFC 4918
            200: 'OK',
            201: 'Created',
            202: 'Accepted',
            203: 'Non-Authoritative Information',
            204: 'No Content',
            205: 'Reset Content',
            206: 'Partial Content',
            207: 'Multi-Status', // RFC 4918
            300: 'Multiple Choices',
            301: 'Moved Permanently',
            302: 'Moved Temporarily',
            303: 'See Other',
            304: 'Not Modified',
            305: 'Use Proxy',
            307: 'Temporary Redirect',
            400: 'Bad Request',
            401: 'Unauthorized',
            402: 'Payment Required',
            403: 'Forbidden',
            404: 'Not Found',
            405: 'Method Not Allowed',
            406: 'Not Acceptable',
            407: 'Proxy Authentication Required',
            408: 'Request Time-out',
            409: 'Conflict',
            410: 'Gone',
            411: 'Length Required',
            412: 'Precondition Failed',
            413: 'Request Entity Too Large',
            414: 'Request-URI Too Large',
            415: 'Unsupported Media Type',
            416: 'Requested Range Not Satisfiable',
            417: 'Expectation Failed',
            418: 'I\'m a teapot', // RFC 2324
            422: 'Unprocessable Entity', // RFC 4918
            423: 'Locked', // RFC 4918
            424: 'Failed Dependency', // RFC 4918
            425: 'Unordered Collection', // RFC 4918
            426: 'Upgrade Required', // RFC 2817
            500: 'Internal Server Error',
            501: 'Not Implemented',
            502: 'Bad Gateway',
            503: 'Service Unavailable',
            504: 'Gateway Time-out',
            505: 'HTTP Version not supported',
            506: 'Variant Also Negotiates', // RFC 2295
            507: 'Insufficient Storage', // RFC 4918
            509: 'Bandwidth Limit Exceeded',
            510: 'Not Extended' // RFC 2774
          };

          // The Shred object itself constructs the `Request` object. You should rarely
          // need to do this directly.

          var Request = function(options) {
            this.log = options.logger;
            this.cookieJar = options.cookieJar;
            this.encoding = options.encoding;
            this.logCurl = options.logCurl;
            processOptions(this, options || {});
            createRequest(this);
          };

          // A `Request` has a number of properties, many of which help with details like
          // URL parsing or defaulting the port for the request.

          Object.defineProperties(Request.prototype, {

            // - **url**. You can set the `url` property with a valid URL string and all the
            //   URL-related properties (host, port, etc.) will be automatically set on the
            //   request object.

            url: {
              get: function() {
                if (!this.scheme) {
                  return null;
                }
                return sprintf("%s://%s:%s%s",
                this.scheme, this.host, this.port, (this.proxy ? "/" : this.path) + (this.query ? ("?" + this.query) : ""));
              },
              set: function(_url) {
                _url = parseUri(_url);
                this.scheme = _url.protocol;
                this.host = _url.host;
                this.port = _url.port;
                this.path = _url.path;
                this.query = _url.query;
                return this;
              },
              enumerable: true
            },

            // - **headers**. Returns a hash representing the request headers. You can't set
            //   this directly, only get it. You can add or modify headers by using the
            //   `setHeader` or `setHeaders` method. This ensures that the headers are
            //   normalized - that is, you don't accidentally send `Content-Type` and
            //   `content-type` headers. Keep in mind that if you modify the returned hash,
            //   it will *not* modify the request headers.

            headers: {
              get: function() {
                return this.getHeaders();
              },
              enumerable: true
            },

            // - **port**. Unless you set the `port` explicitly or include it in the URL, it
            //   will default based on the scheme.

            port: {
              get: function() {
                if (!this._port) {
                  switch (this.scheme) {
                  case "https":
                    return this._port = 443;
                  case "http":
                  default:
                    return this._port = 80;
                  }
                }
                return this._port;
              },
              set: function(value) {
                this._port = value;
                return this;
              },
              enumerable: true
            },

            // - **method**. The request method - `get`, `put`, `post`, etc. that will be
            //   used to make the request. Defaults to `get`.

            method: {
              get: function() {
                return this._method = (this._method || "GET");
              },
              set: function(value) {
                this._method = value;
                return this;
              },
              enumerable: true
            },

            // - **query**. Can be set either with a query string or a hash (object). Get
            //   will always return a properly escaped query string or null if there is no
            //   query component for the request.

            query: {
              get: function() {
                return this._query;
              },
              set: function(value) {
                var stringify = function(hash) {
                  var query = "";
                  for (var key in hash) {
                    query += encodeURIComponent(key) + '=' + encodeURIComponent(hash[key]) + '&';
                  }
                  // Remove the last '&'
                  query = query.slice(0, - 1);
                  return query;
                }

                if (value) {
                  if (typeof value === 'object') {
                    value = stringify(value);
                  }
                  this._query = value;
                } else {
                  this._query = "";
                }
                return this;
              },
              enumerable: true
            },

            // - **parameters**. This will return the query parameters in the form of a hash
            //   (object).

            parameters: {
              get: function() {
                return QueryString.parse(this._query || "");
              },
              enumerable: true
            },

            // - **content**. (Aliased as `body`.) Set this to add a content entity to the
            //   request. Attempts to use the `content-type` header to determine what to do
            //   with the content value. Get this to get back a [`Content`
            //   object](./content.html).

            body: {
              get: function() {
                return this._body;
              },
              set: function(value) {
                this._body = new Content({
                  data: value,
                  type: this.getHeader("Content-Type")
                });
                this.setHeader("Content-Type", this.content.type);
                this.setHeader("Content-Length", this.content.length);
                return this;
              },
              enumerable: true
            },

            // - **timeout**. Used to determine how long to wait for a response. Does not
            //   distinguish between connect timeouts versus request timeouts. Set either in
            //   milliseconds or with an object with temporal attributes (hours, minutes,
            //   seconds) and convert it into milliseconds. Get will always return
            //   milliseconds.

            timeout: {
              get: function() {
                return this._timeout;
              }, // in milliseconds
              set: function(timeout) {
                var request = this,
                  milliseconds = 0;;
                if (!timeout) return this;
                if (typeof timeout === "number") {
                  milliseconds = timeout;
                } else {
                  milliseconds = (timeout.milliseconds || 0) + (1000 * ((timeout.seconds || 0) + (60 * ((timeout.minutes || 0) + (60 * (timeout.hours || 0))))));
                }
                this._timeout = milliseconds;
                return this;
              },
              enumerable: true
            }
          });

          // Alias `body` property to `content`. Since the [content object](./content.html)
          // has a `body` attribute, it's preferable to use `content` since you can then
          // access the raw content data using `content.body`.

          Object.defineProperty(Request.prototype, "content",
          Object.getOwnPropertyDescriptor(Request.prototype, "body"));

          // The `Request` object can be pretty overwhelming to view using the built-in
          // Node.js inspect method. We want to make it a bit more manageable. This
          // probably goes [too far in the other
          // direction](https://github.com/spire-io/shred/issues/2).

          Request.prototype.inspect = function() {
            var request = this;
            var headers = this.format_headers();
            var summary = ["<Shred Request> ", request.method.toUpperCase(),
            request.url].join(" ")
            return [summary, "- Headers:", headers].join("\n");
          };

          Request.prototype.format_headers = function() {
            var array = []
            var headers = this._headers
            for (var key in headers) {
              if (headers.hasOwnProperty(key)) {
                var value = headers[key]
                array.push("\t" + key + ": " + value);
              }
            }
            return array.join("\n");
          };

          // Allow chainable 'on's:  shred.get({ ... }).on( ... ).  You can pass in a
          // single function, a pair (event, function), or a hash:
          // { event: function, event: function }
          Request.prototype.on = function(eventOrHash, listener) {
            var emitter = this.emitter;
            // Pass in a single argument as a function then make it the default response handler
            if (arguments.length === 1 && typeof(eventOrHash) === 'function') {
              emitter.on('response', eventOrHash);
            } else if (arguments.length === 1 && typeof(eventOrHash) === 'object') {
              for (var key in eventOrHash) {
                if (eventOrHash.hasOwnProperty(key)) {
                  emitter.on(key, eventOrHash[key]);
                }
              }
            } else {
              emitter.on(eventOrHash, listener);
            }
            return this;
          };

          // Add in the header methods. Again, these ensure we don't get the same header
          // multiple times with different case conventions.
          HeaderMixins.gettersAndSetters(Request);

          // `processOptions` is called from the constructor to handle all the work
          // associated with making sure we do our best to ensure we have a valid request.

          var processOptions = function(request, options) {

            request.log.debug("Processing request options ..");

            // We'll use `request.emitter` to manage the `on` event handlers.
            request.emitter = (new Emitter);

            request.agent = options.agent;

            // Set up the handlers ...
            if (options.on) {
              for (var key in options.on) {
                if (options.on.hasOwnProperty(key)) {
                  request.emitter.on(key, options.on[key]);
                }
              }
            }

            // Make sure we were give a URL or a host
            if (!options.url && !options.host) {
              request.emitter.emit("request_error",
              new Error("No url or url options (host, port, etc.)"));
              return;
            }

            // Allow for the [use of a proxy](http://www.jmarshall.com/easy/http/#proxies).

            if (options.url) {
              if (options.proxy) {
                request.url = options.proxy;
                request.path = options.url;
              } else {
                request.url = options.url;
              }
            }

            // Set the remaining options.
            request.query = options.query || options.parameters || request.query;
            request.method = options.method;
            // FIXME: options.agent is supposed to be a Node http.Agent, not the
            // User-Agent string.
            request.setHeader("user-agent", options.agent || "Shred");
            request.setHeaders(options.headers);

            if (request.cookieJar) {
              var cookies = request.cookieJar.getCookies(CookieAccessInfo(request.host, request.path));
              if (cookies.length) {
                var cookieString = request.getHeader('cookie') || '';
                for (var cookieIndex = 0; cookieIndex < cookies.length; ++cookieIndex) {
                  if (cookieString.length && cookieString[cookieString.length - 1] != ';') {
                    cookieString += ';';
                  }
                  cookieString += cookies[cookieIndex].name + '=' + cookies[cookieIndex].value + ';';
                }
                request.setHeader("cookie", cookieString);
              }
            }

            // The content entity can be set either using the `body` or `content` attributes.
            if (options.body || options.content) {
              request.content = options.body || options.content;
            }
            request.timeout = options.timeout;

          };

          // `createRequest` is also called by the constructor, after `processOptions`.
          // This actually makes the request and processes the response, so `createRequest`
          // is a bit of a misnomer.

          var createRequest = function(request) {
            var timeoutId;

            request.log.debug("Creating request ..");
            request.log.debug(request);

            var reqParams = {
              host: request.host,
              port: request.port,
              method: request.method,
              path: request.path + (request.query ? '?' + request.query : ""),
              headers: request.getHeaders(),
              // Node's HTTP/S modules will ignore this, but we are using the
              // browserify-http module in the browser for both HTTP and HTTPS, and this
              // is how you differentiate the two.
              scheme: request.scheme,
              // Use a provided agent.  'Undefined' is the default, which uses a global
              // agent.
              agent: request.agent
            };

            if (request.logCurl) {
              logCurl(request);
            }

            var http = request.scheme == "http" ? HTTP : HTTPS;

            // Set up the real request using the selected library. The request won't be
            // sent until we call `.end()`.
            request._raw = http.request(reqParams, function(response) {
              // The "cleanup" event signifies that any timeout or error handlers
              // that have been set for this request should now be disposed of.
              request.emitter.emit("cleanup");
              request.log.debug("Received response ..");

              // We haven't timed out and we have a response, so make sure we clear the
              // timeout so it doesn't fire while we're processing the response.
              clearTimeout(timeoutId);

              // Construct a Shred `Response` object from the response. This will stream
              // the response, thus the need for the callback. We can access the response
              // entity safely once we're in the callback.
              response = new Response(response, request, function(response) {

                // Set up some event magic. The precedence is given first to
                // status-specific handlers, then to responses for a given event, and then
                // finally to the more general `response` handler. In the last case, we
                // need to first make sure we're not dealing with a a redirect.
                var emit = function(event) {
                  var emitter = request.emitter;
                  var textStatus = STATUS_CODES[response.status] ? STATUS_CODES[response.status].toLowerCase() : null;
                  if (emitter.listeners(response.status).length > 0 || emitter.listeners(textStatus).length > 0) {
                    emitter.emit(response.status, response);
                    emitter.emit(textStatus, response);
                  } else {
                    if (emitter.listeners(event).length > 0) {
                      emitter.emit(event, response);
                    } else if (!response.isRedirect) {
                      emitter.emit("response", response);
                      //console.warn("Request has no event listener for status code " + response.status);
                    }
                  }
                };

                // Next, check for a redirect. We simply repeat the request with the URL
                // given in the `Location` header. We fire a `redirect` event.
                if (response.isRedirect) {
                  request.log.debug("Redirecting to " + response.getHeader("Location"));
                  request.url = response.getHeader("Location");
                  emit("redirect");
                  createRequest(request);

                  // Okay, it's not a redirect. Is it an error of some kind?
                } else if (response.isError) {
                  emit("error");
                } else {
                  // It looks like we're good shape. Trigger the `success` event.
                  emit("success");
                }
              });
            });

            request._raw.setMaxListeners(30); // avoid warnings

            // We're still setting up the request. Next, we're going to handle error cases
            // where we have no response. We don't emit an error event because that event
            // takes a response. We don't response handlers to have to check for a null
            // value. However, we [should introduce a different event
            // type](https://github.com/spire-io/shred/issues/3) for this type of error.
            request._raw.on("error", function(error) {
              if (!timeoutId) {
                request.emitter.emit("request_error", error);
              }
              request.emitter.emit("cleanup", error);
            });

            request._raw.on("socket", function(socket) {
              request.emitter.emit("socket", socket);
            });

            // TCP timeouts should also trigger the "response_error" event.
            request._raw.on('socket', function() {
              var timeout_handler = function() {
                request._raw.abort();
              };

              request.emitter.once("cleanup", function() {
                request._raw.socket.removeListener("timeout", timeout_handler);
              });

              // This should trigger the "error" event on the raw request, which will
              // trigger the "response_error" on the shred request.
              request._raw.socket.on('timeout', timeout_handler);
            });


            // We're almost there. Next, we need to write the request entity to the
            // underlying request object.
            if (request.content) {
              request.log.debug("Streaming body: '" + request.content.body.slice(0, 59) + "' ... ");
              request._raw.write(request.content.body);
            }

            // Finally, we need to set up the timeout. We do this last so that we don't
            // start the clock ticking until the last possible moment.
            if (request.timeout) {
              timeoutId = setTimeout(function() {
                request.log.debug("Timeout fired, aborting request ...");
                request._raw.abort();
                request.emitter.emit("timeout", request);
              }, request.timeout);
            }

            // The `.end()` method will cause the request to fire. Technically, it might
            // have already sent the headers and body.
            request.log.debug("Sending request ...");
            request._raw.end();
          };

          // Logs the curl command for the request.
          var logCurl = function(req) {
            var headers = req.getHeaders();
            var headerString = "";

            for (var key in headers) {
              headerString += '-H "' + key + ": " + headers[key] + '" ';
            }

            var bodyString = ""

            if (req.content) {
              bodyString += "-d '" + req.content.body + "' ";
            }

            var query = req.query ? '?' + req.query : "";

            console.log("curl " + "-X " + req.method.toUpperCase() + " " + req.scheme + "://" + req.host + ":" + req.port + req.path + query + " " + headerString + bodyString);
          };


          module.exports = Request;

        },

        "7fd3f9acfab25ddaad20c8acb5c9f50f": // from: lib/shred/response.js
        function(exports, require, module, __filename, __dirname) {
          // The `Response object` encapsulates a Node.js HTTP response.

          var Content = require("./content"),
            HeaderMixins = require("./mixins/headers"),
            CookieJarLib = require("cookiejar"),
            Cookie = CookieJarLib.Cookie;

          // Browser doesn't have zlib.
          var zlib = null;
          try {
            zlib = require('zlib');
          } catch (e) {
            console.warn("no zlib library");
          }

          // Iconv doesn't work in browser
          var Iconv = null;
          try {
            Iconv = require('iconv-lite');
          } catch (e) {
            console.warn("no iconv library");
          }

          // Construct a `Response` object. You should never have to do this directly. The
          // `Request` object handles this, getting the raw response object and passing it
          // in here, along with the request. The callback allows us to stream the response
          // and then use the callback to let the request know when it's ready.
          var Response = function(raw, request, callback) {
            var response = this;
            this._raw = raw;

            // The `._setHeaders` method is "private"; you can't otherwise set headers on
            // the response.
            this._setHeaders.call(this, raw.headers);

            // store any cookies
            if (request.cookieJar && this.getHeader('set-cookie')) {
              var cookieStrings = this.getHeader('set-cookie');
              var cookieObjs = [],
                cookie;

              for (var i = 0; i < cookieStrings.length; i++) {
                var cookieString = cookieStrings[i];
                if (!cookieString) {
                  continue;
                }

                if (!cookieString.match(/domain\=/i)) {
                  cookieString += '; domain=' + request.host;
                }

                if (!cookieString.match(/path\=/i)) {
                  cookieString += '; path=' + request.path;
                }

                try {
                  cookie = new Cookie(cookieString);
                  if (cookie) {
                    cookieObjs.push(cookie);
                  }
                } catch (e) {
                  console.warn("Tried to set bad cookie: " + cookieString);
                }
              }

              request.cookieJar.setCookies(cookieObjs);
            }

            this.request = request;
            this.client = request.client;
            this.log = this.request.log;

            // Stream the response content entity and fire the callback when we're done.
            // Store the incoming data in a array of Buffers which we concatinate into one
            // buffer at the end.  We need to use buffers instead of strings here in order
            // to preserve binary data.
            var chunkBuffers = [];
            var dataLength = 0;
            raw.on("data", function(chunk) {
              chunkBuffers.push(chunk);
              dataLength += chunk.length;
            });
            raw.on("end", function() {
              var body;
              if (typeof Buffer === 'undefined') {
                // Just concatinate into a string
                body = chunkBuffers.join('');
              } else {
                // Initialize new buffer and add the chunks one-at-a-time.
                body = new Buffer(dataLength);
                for (var i = 0, pos = 0; i < chunkBuffers.length; i++) {
                  chunkBuffers[i].copy(body, pos);
                  pos += chunkBuffers[i].length;
                }
              }

              var setBodyAndFinish = function(body) {
                response._body = new Content({
                  body: body,
                  type: response.getHeader("Content-Type")
                });
                callback(response);
              }

              if (zlib && response.getHeader("Content-Encoding") === 'gzip') {
                zlib.gunzip(body, function(err, gunzippedBody) {
                  if (Iconv && response.request.encoding) {
                    body = Iconv.fromEncoding(gunzippedBody, response.request.encoding);
                  } else {
                    body = gunzippedBody.toString();
                  }
                  setBodyAndFinish(body);
                })
              } else {
                if (response.request.encoding) {
                  body = Iconv.fromEncoding(body, response.request.encoding);
                }
                setBodyAndFinish(body);
              }
            });
          };

          // The `Response` object can be pretty overwhelming to view using the built-in
          // Node.js inspect method. We want to make it a bit more manageable. This
          // probably goes [too far in the other
          // direction](https://github.com/spire-io/shred/issues/2).

          Response.prototype = {
            inspect: function() {
              var response = this;
              var headers = this.format_headers();
              var summary = ["<Shred Response> ", response.status].join(" ")
              return [summary, "- Headers:", headers].join("\n");
            },
            format_headers: function() {
              var array = []
              var headers = this.headers
              for (var key in headers) {
                if (headers.hasOwnProperty(key)) {
                  var value = headers[key]
                  array.push("\t" + key + ": " + value);
                }
              }
              return array.join("\n");
            }
          };

          // `Response` object properties, all of which are read-only:
          Object.defineProperties(Response.prototype, {

            // - **status**. The HTTP status code for the response. 
            status: {
              get: function() {
                return this._raw.statusCode;
              },
              enumerable: true
            },

            // - **content**. The HTTP content entity, if any. Provided as a [content
            //   object](./content.html), which will attempt to convert the entity based upon
            //   the `content-type` header. The converted value is available as
            //   `content.data`. The original raw content entity is available as
            //   `content.body`.
            body: {
              get: function() {
                return this._body;
              }
            },
            content: {
              get: function() {
                return this.body;
              },
              enumerable: true
            },

            headers: {
              get: function() {
                return this._headers;
              },
              enumerable: true
            },
            // - **isRedirect**. Is the response a redirect? These are responses with 3xx
            //   status and a `Location` header.
            isRedirect: {
              get: function() {
                return (this.status > 299 && this.status < 400 && this.getHeader("Location"));
              },
              enumerable: true
            },

            // - **isError**. Is the response an error? These are responses with status of
            //   400 or greater.
            isError: {
              get: function() {
                return (this.status === 0 || this.status > 399)
              },
              enumerable: true
            }
          });

          // Add in the [getters for accessing the normalized headers](./headers.js).
          HeaderMixins.getters(Response);
          HeaderMixins.privateSetters(Response);

          // Work around Mozilla bug #608735 [https://bugzil.la/608735], which causes
          // getAllResponseHeaders() to return {} if the response is a CORS request.
          // xhr.getHeader still works correctly.
          var getHeader = Response.prototype.getHeader;
          Response.prototype.getHeader = function(name) {
            return (getHeader.call(this, name) || (typeof this._raw.getHeader === 'function' && this._raw.getHeader(name)));
          };

          module.exports = Response;

        },

        "132989d40603a8a27e34fed726e9aa14": // from: node_modules/ax/examples/javascripts/lib/ax.js
        function(exports, require, module, __filename, __dirname) {
          var Ax = (function() {
            var require = function(a, b) {
              var c = require.resolve(a, b || "/"),
                d = require.modules[c];
              if (!d) throw new Error("Failed to resolve module " + a + ", tried " + c);
              var e = d._cached ? d._cached : d();
              return e
            };
            require.paths = [], require.modules = {}, require.extensions = [".js", ".coffee"], require._core = {
              assert: !0,
              events: !0,
              fs: !0,
              path: !0,
              vm: !0
            }, require.resolve = function() {
              return function(a, b) {
                function g(a) {
                  if (require.modules[a]) return a;
                  for (var b = 0; b < require.extensions.length; b++) {
                    var c = require.extensions[b];
                    if (require.modules[a + c]) return a + c
                  }
                }
                function h(a) {
                  a = a.replace(/\/+$/, "");
                  var b = a + "/package.json";
                  if (require.modules[b]) {
                    var d = require.modules[b](),
                      e = d.browserify;
                    if (typeof e == "object" && e.main) {
                      var f = g(c.resolve(a, e.main));
                      if (f) return f
                    } else if (typeof e == "string") {
                      var f = g(c.resolve(a, e));
                      if (f) return f
                    } else if (d.main) {
                      var f = g(c.resolve(a, d.main));
                      if (f) return f
                    }
                  }
                  return g(a + "/index")
                }
                function i(a, b) {
                  var c = j(b);
                  for (var d = 0; d < c.length; d++) {
                    var e = c[d],
                      f = g(e + "/" + a);
                    if (f) return f;
                    var i = h(e + "/" + a);
                    if (i) return i
                  }
                  var f = g(a);
                  if (f) return f
                }
                function j(a) {
                  var b;
                  a === "/" ? b = [""] : b = c.normalize(a).split("/");
                  var d = [];
                  for (var e = b.length - 1; e >= 0; e--) {
                    if (b[e] === "node_modules") continue;
                    var f = b.slice(0, e + 1).join("/") + "/node_modules";
                    d.push(f)
                  }
                  return d
                }
                b || (b = "/");
                if (require._core[a]) return a;
                var c = require.modules.path(),
                  d = b || ".";
                if (a.match(/^(?:\.\.?\/|\/)/)) {
                  var e = g(c.resolve(d, a)) || h(c.resolve(d, a));
                  if (e) return e
                }
                var f = i(a, d);
                if (f) return f;
                throw new Error("Cannot find module '" + a + "'")
              }
            }(), require.alias = function(a, b) {
              var c = require.modules.path(),
                d = null;
              try {
                d = require.resolve(a + "/package.json", "/")
              } catch (e) {
                d = require.resolve(a, "/")
              }
              var f = c.dirname(d),
                g = (Object.keys || function(a) {
                  var b = [];
                  for (var c in a) b.push(c);
                  return b
                })(require.modules);
              for (var h = 0; h < g.length; h++) {
                var i = g[h];
                if (i.slice(0, f.length + 1) === f + "/") {
                  var j = i.slice(f.length);
                  require.modules[b + j] = require.modules[f + j]
                } else i === f && (require.modules[b] = require.modules[f])
              }
            }, require.define = function(a, b) {
              var c = require._core[a] ? "" : require.modules.path().dirname(a),
                d = function(a) {
                  return require(a, c)
                };
              d.resolve = function(a) {
                return require.resolve(a, c)
              }, d.modules = require.modules, d.define = require.define;
              var e = {
                exports: {}
              };
              require.modules[a] = function() {
                return require.modules[a]._cached = e.exports, b.call(e.exports, d, e, e.exports, c, a), require.modules[a]._cached = e.exports, e.exports
              }
            }, typeof process == "undefined" && (process = {}), process.nextTick || (process.nextTick = function() {
              var a = [],
                b = typeof window != "undefined" && window.postMessage && window.addEventListener;
              return b && window.addEventListener("message", function(b) {
                if (b.source === window && b.data === "browserify-tick") {
                  b.stopPropagation();
                  if (a.length > 0) {
                    var c = a.shift();
                    c()
                  }
                }
              }, !0),
              function(c) {
                b ? (a.push(c), window.postMessage("browserify-tick", "*")) : setTimeout(c, 0)
              }
            }()), process.title || (process.title = "browser"), process.binding || (process.binding = function(a) {
              if (a === "evals") return require("vm");
              throw new Error("No such module")
            }), process.cwd || (process.cwd = function() {
              return "."
            }), require.define("path", function(a, b, c, d, e) {
              function f(a, b) {
                var c = [];
                for (var d = 0; d < a.length; d++) b(a[d], d, a) && c.push(a[d]);
                return c
              }
              function g(a, b) {
                var c = 0;
                for (var d = a.length; d >= 0; d--) {
                  var e = a[d];
                  e == "." ? a.splice(d, 1) : e === ".." ? (a.splice(d, 1), c++) : c && (a.splice(d, 1), c--)
                }
                if (b) for (; c--; c) a.unshift("..");
                return a
              }
              var h = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;
              c.resolve = function() {
                var a = "",
                  b = !1;
                for (var c = arguments.length; c >= -1 && !b; c--) {
                  var d = c >= 0 ? arguments[c] : process.cwd();
                  if (typeof d != "string" || !d) continue;
                  a = d + "/" + a, b = d.charAt(0) === "/"
                }
                return a = g(f(a.split("/"), function(a) {
                  return !!a
                }), !b).join("/"), (b ? "/" : "") + a || "."
              }, c.normalize = function(a) {
                var b = a.charAt(0) === "/",
                  c = a.slice(-1) === "/";
                return a = g(f(a.split("/"), function(a) {
                  return !!a
                }), !b).join("/"), !a && !b && (a = "."), a && c && (a += "/"), (b ? "/" : "") + a
              }, c.join = function() {
                var a = Array.prototype.slice.call(arguments, 0);
                return c.normalize(f(a, function(a, b) {
                  return a && typeof a == "string"
                }).join("/"))
              }, c.dirname = function(a) {
                var b = h.exec(a)[1] || "",
                  c = !1;
                return b ? b.length === 1 || c && b.length <= 3 && b.charAt(1) === ":" ? b : b.substring(0, b.length - 1) : "."
              }, c.basename = function(a, b) {
                var c = h.exec(a)[2] || "";
                return b && c.substr(-1 * b.length) === b && (c = c.substr(0, c.length - b.length)), c
              }, c.extname = function(a) {
                return h.exec(a)[3] || ""
              }
            }), require.define("/ax.js", function(a, b, c, d, e) {
              var f = a("util").inspect,
                g = a("fs"),
                h = function(a, b) {
                  var c = a == "debug" || a == "error";
                  return b ? typeof b == "object" ? b instanceof Error && c ? b.stack : f(b) : b.toString() : b.toString()
                }, i = function(a) {
                  return this
                }, j = function(a, b) {
                  return function(b) {
                    return this.stream.write(this.format(a, b) + "\n"), this
                  }
                }, k = function(a) {
                  var b = this,
                    a = a || {};
                  a.level = a.level || "info", a.timestamp = a.timestamp || !0, a.prefix = a.prefix || "", b.options = a, b.options.module && (b.options.prefix = b.options.module), b.options.file ? b.stream = g.createWriteStream(b.options.file, {
                    flags: "a"
                  }) : process.title === "node" ? b.stream = process.stderr : process.title === "browser" && (b.stream = function() {
                    return console[b.options.level].apply(console, arguments)
                  });
                  switch (b.options.level) {
                  case "debug":
                    ["debug", "info", "warn"].forEach(function(a) {
                      b[a] = k.writer(a)
                    });
                  case "info":
                    ["info", "warn"].forEach(function(a) {
                      b[a] = k.writer(a)
                    });
                  case "warn":
                    b.warn = k.writer("warn")
                  }
                };
              k.writer = function(a) {
                return function(b) {
                  var c = this;
                  process.title === "node" ? c.stream.write(c.format(a, b) + "\n") : process.title === "browser" && c.stream(c.format(a, b) + "\n")
                }
              }, k.prototype = {
                info: function() {},
                debug: function() {},
                warn: function() {},
                error: k.writer("error"),
                format: function(a, b) {
                  if (!b) return "";
                  var c = this,
                    d = c.options.prefix,
                    e = c.options.timestamp ? " " + (new Date).toISOString() : "";
                  return d + e + ": " + b
                }
              }, b.exports = k
            }), require.define("util", function(a, b, c, d, e) {
              function g(a) {
                return a instanceof Array || Array.isArray(a) || a && a !== Object.prototype && g(a.__proto__)
              }
              function h(a) {
                return a instanceof RegExp || typeof a == "object" && Object.prototype.toString.call(a) === "[object RegExp]"
              }
              function i(a) {
                if (a instanceof Date) return !0;
                if (typeof a != "object") return !1;
                var b = Date.prototype && Object.getOwnPropertyNames(Date.prototype),
                  c = a.__proto__ && Object.getOwnPropertyNames(a.__proto__);
                return JSON.stringify(c) === JSON.stringify(b)
              }
              function j(a) {
                return a < 10 ? "0" + a.toString(10) : a.toString(10)
              }
              function l() {
                var a = new Date,
                  b = [j(a.getHours()), j(a.getMinutes()), j(a.getSeconds())].join(":");
                return [a.getDate(), k[a.getMonth()], b].join(" ")
              }
              var f = a("events");
              c.print = function() {}, c.puts = function() {}, c.debug = function() {}, c.inspect = function(a, b, d, e) {
                function k(a, d) {
                  if (a && typeof a.inspect == "function" && a !== c && (!a.constructor || a.constructor.prototype !== a)) return a.inspect(d);
                  switch (typeof a) {
                  case "undefined":
                    return j("undefined", "undefined");
                  case "string":
                    var e = "'" + JSON.stringify(a).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                    return j(e, "string");
                  case "number":
                    return j("" + a, "number");
                  case "boolean":
                    return j("" + a, "boolean")
                  }
                  if (a === null) return j("null", "null");
                  var l = Object.keys(a),
                    m = b ? Object.getOwnPropertyNames(a) : l;
                  if (typeof a == "function" && m.length === 0) {
                    if (h(a)) return j("" + a, "regexp");
                    var n = a.name ? ": " + a.name : "";
                    return j("[Function" + n + "]", "special")
                  }
                  if (i(a) && m.length === 0) return j(a.toUTCString(), "date");
                  var o, p, q;
                  g(a) ? (p = "Array", q = ["[", "]"]) : (p = "Object", q = ["{", "}"]);
                  if (typeof a == "function") {
                    var r = a.name ? ": " + a.name : "";
                    o = h(a) ? " " + a : " [Function" + r + "]"
                  } else o = "";
                  i(a) && (o = " " + a.toUTCString());
                  if (m.length === 0) return q[0] + o + q[1];
                  if (d < 0) return h(a) ? j("" + a, "regexp") : j("[Object]", "special");
                  f.push(a);
                  var s = m.map(function(b) {
                    var c, e;
                    a.__lookupGetter__ && (a.__lookupGetter__(b) ? a.__lookupSetter__(b) ? e = j("[Getter/Setter]", "special") : e = j("[Getter]", "special") : a.__lookupSetter__(b) && (e = j("[Setter]", "special"))), l.indexOf(b) < 0 && (c = "[" + b + "]"), e || (f.indexOf(a[b]) < 0 ? (d === null ? e = k(a[b]) : e = k(a[b], d - 1), e.indexOf("\n") > -1 && (g(a) ? e = e.split("\n").map(function(a) {
                      return "  " + a
                    }).join("\n").substr(2) : e = "\n" + e.split("\n").map(function(a) {
                      return "   " + a
                    }).join("\n"))) : e = j("[Circular]", "special"));
                    if (typeof c == "undefined") {
                      if (p === "Array" && b.match(/^\d+$/)) return e;
                      c = JSON.stringify("" + b), c.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (c = c.substr(1, c.length - 2), c = j(c, "name")) : (c = c.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), c = j(c, "string"))
                    }
                    return c + ": " + e
                  });
                  f.pop();
                  var t = 0,
                    u = s.reduce(function(a, b) {
                      return t++, b.indexOf("\n") >= 0 && t++, a + b.length + 1
                    }, 0);
                  return u > 50 ? s = q[0] + (o === "" ? "" : o + "\n ") + " " + s.join(",\n  ") + " " + q[1] : s = q[0] + o + " " + s.join(", ") + " " + q[1], s
                }
                var f = [],
                  j = function(a, b) {
                    var c = {
                      bold: [1, 22],
                      italic: [3, 23],
                      underline: [4, 24],
                      inverse: [7, 27],
                      white: [37, 39],
                      grey: [90, 39],
                      black: [30, 39],
                      blue: [34, 39],
                      cyan: [36, 39],
                      green: [32, 39],
                      magenta: [35, 39],
                      red: [31, 39],
                      yellow: [33, 39]
                    }, d = {
                      special: "cyan",
                      number: "blue",
                      "boolean": "yellow",
                      "undefined": "grey",
                      "null": "bold",
                      string: "green",
                      date: "magenta",
                      regexp: "red"
                    }[b];
                    return d ? "[" + c[d][0] + "m" + a + "[" + c[d][1] + "m" : a
                  };
                return e || (j = function(a, b) {
                  return a
                }), k(a, typeof d == "undefined" ? 2 : d)
              };
              var k = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
              c.log = function(a) {}, c.pump = null, c.inherits = function(a, b) {
                a.super_ = b, a.prototype = Object.create(b.prototype, {
                  constructor: {
                    value: a,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                  }
                })
              }
            }), require.define("events", function(a, b, c, d, e) {
              process.EventEmitter || (process.EventEmitter = function() {});
              var f = c.EventEmitter = process.EventEmitter,
                g = typeof Array.isArray == "function" ? Array.isArray : function(a) {
                  return Object.toString.call(a) === "[object Array]"
                }, h = 10;
              f.prototype.setMaxListeners = function(a) {
                this._events || (this._events = {}), this._events.maxListeners = a
              }, f.prototype.emit = function(a) {
                if (a === "error") if (!this._events || !this._events.error || g(this._events.error) && !this._events.error.length) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
                if (!this._events) return !1;
                var b = this._events[a];
                if (!b) return !1;
                if (typeof b == "function") {
                  switch (arguments.length) {
                  case 1:
                    b.call(this);
                    break;
                  case 2:
                    b.call(this, arguments[1]);
                    break;
                  case 3:
                    b.call(this, arguments[1], arguments[2]);
                    break;
                  default:
                    var c = Array.prototype.slice.call(arguments, 1);
                    b.apply(this, c)
                  }
                  return !0
                }
                if (g(b)) {
                  var c = Array.prototype.slice.call(arguments, 1),
                    d = b.slice();
                  for (var e = 0, f = d.length; e < f; e++) d[e].apply(this, c);
                  return !0
                }
                return !1
              }, f.prototype.addListener = function(a, b) {
                if ("function" != typeof b) throw new Error("addListener only takes instances of Function");
                this._events || (this._events = {}), this.emit("newListener", a, b);
                if (!this._events[a]) this._events[a] = b;
                else if (g(this._events[a])) {
                  if (!this._events[a].warned) {
                    var c;
                    this._events.maxListeners !== undefined ? c = this._events.maxListeners : c = h, c && c > 0 && this._events[a].length > c && (this._events[a].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[a].length), console.trace())
                  }
                  this._events[a].push(b)
                } else this._events[a] = [this._events[a], b];
                return this
              }, f.prototype.on = f.prototype.addListener, f.prototype.once = function(a, b) {
                var c = this;
                return c.on(a, function d() {
                  c.removeListener(a, d), b.apply(this, arguments)
                }), this
              }, f.prototype.removeListener = function(a, b) {
                if ("function" != typeof b) throw new Error("removeListener only takes instances of Function");
                if (!this._events || !this._events[a]) return this;
                var c = this._events[a];
                if (g(c)) {
                  var d = c.indexOf(b);
                  if (d < 0) return this;
                  c.splice(d, 1), c.length == 0 && delete this._events[a]
                } else this._events[a] === b && delete this._events[a];
                return this
              }, f.prototype.removeAllListeners = function(a) {
                return a && this._events && this._events[a] && (this._events[a] = null), this
              }, f.prototype.listeners = function(a) {
                return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), g(this._events[a]) || (this._events[a] = [this._events[a]]), this._events[a]
              }
            }), require.define("fs", function(a, b, c, d, e) {});
            return require("./ax")
          })()
        },

        "d41d8cd98f00b204e9800998ecf8427e": // from: node_modules/ax/examples/javascripts/ax.js
        function(exports, require, module, __filename, __dirname) {

        },

        "04be349b3c0f2856b0074f9dc4824189": // from: node_modules/ax/examples/simple.js
        function(exports, require, module, __filename, __dirname) {
          // Copyright (c) 2011 Border Stylo

          var Ax = require("ax");
          var logger = new Ax({
            level: "debug"
          });

          logger.info("Greetings, Professor Falken.");
          logger.warn("Warning, Will Robinson!");
          logger.error("If I may say so, sir, I noticed earlier the hyperdrive" + " motivator has been damaged. It's impossible to go to lightspeed.");
          logger.debug("Instruments register only those things they're designed to" + " register. Space still contains infinite unknowns.");

        },

        "f54c237eca3ec015842d2946265847f7": // from: node_modules/ax/lib/ax.js
        function(exports, require, module, __filename, __dirname) {
          // Copyright (c) 2011 Border Stylo

          var inspect = require("util").inspect,
            fs = require("fs");


          // this is a quick-and-dirty logger. there are other nicer loggers out there
          // but the ones i found were also somewhat involved. this one has a Ruby
          // logger type interface
          //
          // we can easily replace this, provide the info, debug, etc. methods are the
          // same. or, we can change Haiku to use a more standard node.js interface

          var format = function(level, message) {
            var debug = (level == "debug" || level == "error");
            if (!message) {
              return message.toString();
            }
            if (typeof(message) == "object") {
              if (message instanceof Error && debug) {
                return message.stack;
              } else {
                return inspect(message);
              }
            } else {
              return message.toString();
            }
          };

          var noOp = function(message) {
            return this;
          }
          var makeLogger = function(level, fn) {
            return function(message) {
              this.stream.write(this.format(level, message) + "\n");
              return this;
            }
          };

          var Logger = function(options) {
            var logger = this;
            var options = options || {};

            // Default options
            options.level = options.level || "info";
            options.timestamp = options.timestamp || true;
            options.prefix = options.prefix || "";
            logger.options = options;

            // Allows a prefix to be added to the message.
            //
            //    var logger = new Ax({ module: 'Haiku' })
            //    logger.warn('this is going to be awesome!');
            //    //=> Haiku: this is going to be awesome!
            //
            if (logger.options.module) {
              logger.options.prefix = logger.options.module;
            }

            // Write to stdout or a file
            if (logger.options.file) {
              logger.stream = fs.createWriteStream(logger.options.file, {
                "flags": "a"
              });
            } else {
              if (process.title === "node") logger.stream = process.stdout;
              else if (process.title === "browser") logger.stream = function() {
                // Work around weird console context issue: http://code.google.com/p/chromium/issues/detail?id=48662
                return console[logger.options.level].apply(console, arguments);
              };
            }

            switch (logger.options.level) {
            case 'debug':
              ['debug', 'info', 'warn'].forEach(function(level) {
                logger[level] = Logger.writer(level);
              });
            case 'info':
              ['info', 'warn'].forEach(function(level) {
                logger[level] = Logger.writer(level);
              });
            case 'warn':
              logger.warn = Logger.writer('warn');
            }
          }

          // Used to define logger methods
          Logger.writer = function(level) {
            return function(message) {
              var logger = this;

              if (process.title === "node") logger.stream.write(logger.format(level, message) + '\n');
              else if (process.title === "browser") logger.stream(logger.format(level, message) + '\n');

            };
          }


          Logger.prototype = {
            info: function() {},
            debug: function() {},
            warn: function() {},
            error: Logger.writer('error'),
            format: function(level, message) {
              if (!message) return '';

              var logger = this,
                prefix = logger.options.prefix,
                timestamp = logger.options.timestamp ? " " + (new Date().toISOString()) : "";

              return (prefix + timestamp + ": " + message);
            }
          };

          module.exports = Logger;

        },

        "f41fe98f55620bae34c8b5ce969028b8": // from: node_modules/buffer-browserify/buffer_ieee754.js
        function(exports, require, module, __filename, __dirname) {
          exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
            var e, m,
            eLen = nBytes * 8 - mLen - 1,
              eMax = (1 << eLen) - 1,
              eBias = eMax >> 1,
              nBits = -7,
              i = isBE ? 0 : (nBytes - 1),
              d = isBE ? 1 : -1,
              s = buffer[offset + i];

            i += d;

            e = s & ((1 << (-nBits)) - 1);
            s >>= (-nBits);
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

            m = e & ((1 << (-nBits)) - 1);
            e >>= (-nBits);
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : ((s ? -1 : 1) * Infinity);
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          };

          exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
            var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
              eMax = (1 << eLen) - 1,
              eBias = eMax >> 1,
              rt = (mLen === 23 ? Math.pow(2, - 24) - Math.pow(2, - 77) : 0),
              i = isBE ? (nBytes - 1) : 0,
              d = isBE ? -1 : 1,
              s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

            value = Math.abs(value);

            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);
              if (value * (c = Math.pow(2, - e)) < 1) {
                e--;
                c *= 2;
              }
              if (e + eBias >= 1) {
                value += rt / c;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }
              if (value * c >= 2) {
                e++;
                c /= 2;
              }

              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

            e = (e << mLen) | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

            buffer[offset + i - d] |= s * 128;
          };

        },

        "dc10a398e1e1237d5a4d2512cd4115e7": // from: node_modules/buffer-browserify/index.js
        function(exports, require, module, __filename, __dirname) {
          function SlowBuffer(size) {
            this.length = size;
          };

          var assert = require('assert');

          exports.INSPECT_MAX_BYTES = 50;


          function toHex(n) {
            if (n < 16) return '0' + n.toString(16);
            return n.toString(16);
          }

          function utf8ToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; i++)
            if (str.charCodeAt(i) <= 0x7F) byteArray.push(str.charCodeAt(i));
            else {
              var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
              for (var j = 0; j < h.length; j++)
              byteArray.push(parseInt(h[j], 16));
            }

            return byteArray;
          }

          function asciiToBytes(str) {
            var byteArray = []
            for (var i = 0; i < str.length; i++)
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xFF);

            return byteArray;
          }

          function base64ToBytes(str) {
            return require("base64-js").toByteArray(str);
          }

          SlowBuffer.byteLength = function(str, encoding) {
            switch (encoding || "utf8") {
            case 'hex':
              return str.length / 2;

            case 'utf8':
            case 'utf-8':
              return utf8ToBytes(str).length;

            case 'ascii':
            case 'binary':
              return str.length;

            case 'base64':
              return base64ToBytes(str).length;

            default:
              throw new Error('Unknown encoding');
            }
          };

          function blitBuffer(src, dst, offset, length) {
            var pos, i = 0;
            while (i < length) {
              if ((i + offset >= dst.length) || (i >= src.length)) break;

              dst[i + offset] = src[i];
              i++;
            }
            return i;
          }

          SlowBuffer.prototype.utf8Write = function(string, offset, length) {
            var bytes, pos;
            return SlowBuffer._charsWritten = blitBuffer(utf8ToBytes(string), this, offset, length);
          };

          SlowBuffer.prototype.asciiWrite = function(string, offset, length) {
            var bytes, pos;
            return SlowBuffer._charsWritten = blitBuffer(asciiToBytes(string), this, offset, length);
          };

          SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

          SlowBuffer.prototype.base64Write = function(string, offset, length) {
            var bytes, pos;
            return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
          };

          SlowBuffer.prototype.base64Slice = function(start, end) {
            var bytes = Array.prototype.slice.apply(this, arguments)
            return require("base64-js").fromByteArray(bytes);
          }

          function decodeUtf8Char(str) {
            try {
              return decodeURIComponent(str);
            } catch (err) {
              return String.fromCharCode(0xFFFD); // UTF 8 invalid char
            }
          }

          SlowBuffer.prototype.utf8Slice = function() {
            var bytes = Array.prototype.slice.apply(this, arguments);
            var res = "";
            var tmp = "";
            var i = 0;
            while (i < bytes.length) {
              if (bytes[i] <= 0x7F) {
                res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
                tmp = "";
              } else tmp += "%" + bytes[i].toString(16);

              i++;
            }

            return res + decodeUtf8Char(tmp);
          }

          SlowBuffer.prototype.asciiSlice = function() {
            var bytes = Array.prototype.slice.apply(this, arguments);
            var ret = "";
            for (var i = 0; i < bytes.length; i++)
            ret += String.fromCharCode(bytes[i]);
            return ret;
          }

          SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

          SlowBuffer.prototype.inspect = function() {
            var out = [],
              len = this.length;
            for (var i = 0; i < len; i++) {
              out[i] = toHex(this[i]);
              if (i == exports.INSPECT_MAX_BYTES) {
                out[i + 1] = '...';
                break;
              }
            }
            return '<SlowBuffer ' + out.join(' ') + '>';
          };


          SlowBuffer.prototype.hexSlice = function(start, end) {
            var len = this.length;

            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;

            var out = '';
            for (var i = start; i < end; i++) {
              out += toHex(this[i]);
            }
            return out;
          };


          SlowBuffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();
            start = +start || 0;
            if (typeof end == 'undefined') end = this.length;

            // Fastpath empty strings
            if (+end == start) {
              return '';
            }

            switch (encoding) {
            case 'hex':
              return this.hexSlice(start, end);

            case 'utf8':
            case 'utf-8':
              return this.utf8Slice(start, end);

            case 'ascii':
              return this.asciiSlice(start, end);

            case 'binary':
              return this.binarySlice(start, end);

            case 'base64':
              return this.base64Slice(start, end);

            case 'ucs2':
            case 'ucs-2':
              return this.ucs2Slice(start, end);

            default:
              throw new Error('Unknown encoding');
            }
          };


          SlowBuffer.prototype.hexWrite = function(string, offset, length) {
            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = +length;
              if (length > remaining) {
                length = remaining;
              }
            }

            // must be an even number of digits
            var strLen = string.length;
            if (strLen % 2) {
              throw new Error('Invalid hex string');
            }
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; i++) {
              var byte = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(byte)) throw new Error('Invalid hex string');
              this[offset + i] = byte;
            }
            SlowBuffer._charsWritten = i * 2;
            return i;
          };


          SlowBuffer.prototype.write = function(string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
              if (!isFinite(length)) {
                encoding = length;
                length = undefined;
              }
            } else { // legacy
              var swap = encoding;
              encoding = offset;
              offset = length;
              length = swap;
            }

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = +length;
              if (length > remaining) {
                length = remaining;
              }
            }
            encoding = String(encoding || 'utf8').toLowerCase();

            switch (encoding) {
            case 'hex':
              return this.hexWrite(string, offset, length);

            case 'utf8':
            case 'utf-8':
              return this.utf8Write(string, offset, length);

            case 'ascii':
              return this.asciiWrite(string, offset, length);

            case 'binary':
              return this.binaryWrite(string, offset, length);

            case 'base64':
              return this.base64Write(string, offset, length);

            case 'ucs2':
            case 'ucs-2':
              return this.ucs2Write(string, offset, length);

            default:
              throw new Error('Unknown encoding');
            }
          };


          // slice(start, end)
          SlowBuffer.prototype.slice = function(start, end) {
            if (end === undefined) end = this.length;

            if (end > this.length) {
              throw new Error('oob');
            }
            if (start > end) {
              throw new Error('oob');
            }

            return new Buffer(this, end - start, + start);
          };

          SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
            var temp = [];
            for (var i = sourcestart; i < sourceend; i++) {
              assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
              temp.push(this[i]);
            }

            for (var i = targetstart; i < targetstart + temp.length; i++) {
              target[i] = temp[i - targetstart];
            }
          };

          SlowBuffer.prototype.fill = function(value, start, end) {
            if (end > this.length) {
              throw new Error('oob');
            }
            if (start > end) {
              throw new Error('oob');
            }

            for (var i = start; i < end; i++) {
              this[i] = value;
            }
          }

          function coerce(length) {
            // Coerce length to a number (possibly NaN), round up
            // in case it's fractional (e.g. 123.456) then do a
            // double negate to coerce a NaN to 0. Easy, right?
            length = ~~Math.ceil(+length);
            return length < 0 ? 0 : length;
          }


          // Buffer

          function Buffer(subject, encoding, offset) {
            if (!(this instanceof Buffer)) {
              return new Buffer(subject, encoding, offset);
            }

            var type;

            // Are we slicing?
            if (typeof offset === 'number') {
              this.length = coerce(encoding);
              this.parent = subject;
              this.offset = offset;
            } else {
              // Find the length
              switch (type = typeof subject) {
              case 'number':
                this.length = coerce(subject);
                break;

              case 'string':
                this.length = Buffer.byteLength(subject, encoding);
                break;

              case 'object':
                // Assume object is an array
                this.length = coerce(subject.length);
                break;

              default:
                throw new Error('First argument needs to be a number, ' + 'array or string.');
              }

              if (this.length > Buffer.poolSize) {
                // Big buffer, just alloc one.
                this.parent = new SlowBuffer(this.length);
                this.offset = 0;

              } else {
                // Small buffer.
                if (!pool || pool.length - pool.used < this.length) allocPool();
                this.parent = pool;
                this.offset = pool.used;
                pool.used += this.length;
              }

              // Treat array-ish objects as a byte array.
              if (isArrayIsh(subject)) {
                for (var i = 0; i < this.length; i++) {
                  if (subject instanceof Buffer) {
                    this.parent[i + this.offset] = subject.readUInt8(i);
                  } else {
                    this.parent[i + this.offset] = subject[i];
                  }
                }
              } else if (type == 'string') {
                // We are a string
                this.length = this.write(subject, 0, encoding);
              }
            }

          }

          function isArrayIsh(subject) {
            return Array.isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === 'object' && typeof subject.length === 'number';
          }

          exports.SlowBuffer = SlowBuffer;
          exports.Buffer = Buffer;

          Buffer.poolSize = 8 * 1024;
          var pool;

          function allocPool() {
            pool = new SlowBuffer(Buffer.poolSize);
            pool.used = 0;
          }


          // Static methods
          Buffer.isBuffer = function isBuffer(b) {
            return b instanceof Buffer || b instanceof SlowBuffer;
          };

          Buffer.concat = function(list, totalLength) {
            if (!Array.isArray(list)) {
              throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
            }

            if (list.length === 0) {
              return new Buffer(0);
            } else if (list.length === 1) {
              return list[0];
            }

            if (typeof totalLength !== 'number') {
              totalLength = 0;
              for (var i = 0; i < list.length; i++) {
                var buf = list[i];
                totalLength += buf.length;
              }
            }

            var buffer = new Buffer(totalLength);
            var pos = 0;
            for (var i = 0; i < list.length; i++) {
              var buf = list[i];
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };

          // Inspect
          Buffer.prototype.inspect = function inspect() {
            var out = [],
              len = this.length;

            for (var i = 0; i < len; i++) {
              out[i] = toHex(this.parent[i + this.offset]);
              if (i == exports.INSPECT_MAX_BYTES) {
                out[i + 1] = '...';
                break;
              }
            }

            return '<Buffer ' + out.join(' ') + '>';
          };


          Buffer.prototype.get = function get(i) {
            if (i < 0 || i >= this.length) throw new Error('oob');
            return this.parent[this.offset + i];
          };


          Buffer.prototype.set = function set(i, v) {
            if (i < 0 || i >= this.length) throw new Error('oob');
            return this.parent[this.offset + i] = v;
          };


          // write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
          Buffer.prototype.write = function(string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
              if (!isFinite(length)) {
                encoding = length;
                length = undefined;
              }
            } else { // legacy
              var swap = encoding;
              encoding = offset;
              offset = length;
              length = swap;
            }

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = +length;
              if (length > remaining) {
                length = remaining;
              }
            }
            encoding = String(encoding || 'utf8').toLowerCase();

            var ret;
            switch (encoding) {
            case 'hex':
              ret = this.parent.hexWrite(string, this.offset + offset, length);
              break;

            case 'utf8':
            case 'utf-8':
              ret = this.parent.utf8Write(string, this.offset + offset, length);
              break;

            case 'ascii':
              ret = this.parent.asciiWrite(string, this.offset + offset, length);
              break;

            case 'binary':
              ret = this.parent.binaryWrite(string, this.offset + offset, length);
              break;

            case 'base64':
              // Warning: maxLength not taken into account in base64Write
              ret = this.parent.base64Write(string, this.offset + offset, length);
              break;

            case 'ucs2':
            case 'ucs-2':
              ret = this.parent.ucs2Write(string, this.offset + offset, length);
              break;

            default:
              throw new Error('Unknown encoding');
            }

            Buffer._charsWritten = SlowBuffer._charsWritten;

            return ret;
          };


          // toString(encoding, start=0, end=buffer.length)
          Buffer.prototype.toString = function(encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            if (typeof start == 'undefined' || start < 0) {
              start = 0;
            } else if (start > this.length) {
              start = this.length;
            }

            if (typeof end == 'undefined' || end > this.length) {
              end = this.length;
            } else if (end < 0) {
              end = 0;
            }

            start = start + this.offset;
            end = end + this.offset;

            switch (encoding) {
            case 'hex':
              return this.parent.hexSlice(start, end);

            case 'utf8':
            case 'utf-8':
              return this.parent.utf8Slice(start, end);

            case 'ascii':
              return this.parent.asciiSlice(start, end);

            case 'binary':
              return this.parent.binarySlice(start, end);

            case 'base64':
              return this.parent.base64Slice(start, end);

            case 'ucs2':
            case 'ucs-2':
              return this.parent.ucs2Slice(start, end);

            default:
              throw new Error('Unknown encoding');
            }
          };


          // byteLength
          Buffer.byteLength = SlowBuffer.byteLength;


          // fill(value, start=0, end=buffer.length)
          Buffer.prototype.fill = function fill(value, start, end) {
            value || (value = 0);
            start || (start = 0);
            end || (end = this.length);

            if (typeof value === 'string') {
              value = value.charCodeAt(0);
            }
            if (!(typeof value === 'number') || isNaN(value)) {
              throw new Error('value is not a number');
            }

            if (end < start) throw new Error('end < start');

            // Fill 0 bytes; we're done
            if (end === start) return 0;
            if (this.length == 0) return 0;

            if (start < 0 || start >= this.length) {
              throw new Error('start out of bounds');
            }

            if (end < 0 || end > this.length) {
              throw new Error('end out of bounds');
            }

            return this.parent.fill(value,
            start + this.offset,
            end + this.offset);
          };


          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function(target, target_start, start, end) {
            var source = this;
            start || (start = 0);
            end || (end = this.length);
            target_start || (target_start = 0);

            if (end < start) throw new Error('sourceEnd < sourceStart');

            // Copy 0 bytes; we're done
            if (end === start) return 0;
            if (target.length == 0 || source.length == 0) return 0;

            if (target_start < 0 || target_start >= target.length) {
              throw new Error('targetStart out of bounds');
            }

            if (start < 0 || start >= source.length) {
              throw new Error('sourceStart out of bounds');
            }

            if (end < 0 || end > source.length) {
              throw new Error('sourceEnd out of bounds');
            }

            // Are we oob?
            if (end > this.length) {
              end = this.length;
            }

            if (target.length - target_start < end - start) {
              end = target.length - target_start + start;
            }

            return this.parent.copy(target.parent,
            target_start + target.offset,
            start + this.offset,
            end + this.offset);
          };


          // slice(start, end)
          Buffer.prototype.slice = function(start, end) {
            if (end === undefined) end = this.length;
            if (end > this.length) throw new Error('oob');
            if (start > end) throw new Error('oob');

            return new Buffer(this.parent, end - start, + start + this.offset);
          };


          // Legacy methods for backwards compatibility.

          Buffer.prototype.utf8Slice = function(start, end) {
            return this.toString('utf8', start, end);
          };

          Buffer.prototype.binarySlice = function(start, end) {
            return this.toString('binary', start, end);
          };

          Buffer.prototype.asciiSlice = function(start, end) {
            return this.toString('ascii', start, end);
          };

          Buffer.prototype.utf8Write = function(string, offset) {
            return this.write(string, offset, 'utf8');
          };

          Buffer.prototype.binaryWrite = function(string, offset) {
            return this.write(string, offset, 'binary');
          };

          Buffer.prototype.asciiWrite = function(string, offset) {
            return this.write(string, offset, 'ascii');
          };

          Buffer.prototype.readUInt8 = function(offset, noAssert) {
            var buffer = this;

            if (!noAssert) {
              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset < buffer.length, 'Trying to read beyond buffer length');
            }

            if (offset >= buffer.length) return;

            return buffer.parent[buffer.offset + offset];
          };

          function readUInt16(buffer, offset, isBigEndian, noAssert) {
            var val = 0;


            if (!noAssert) {
              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 1 < buffer.length, 'Trying to read beyond buffer length');
            }

            if (offset >= buffer.length) return 0;

            if (isBigEndian) {
              val = buffer.parent[buffer.offset + offset] << 8;
              if (offset + 1 < buffer.length) {
                val |= buffer.parent[buffer.offset + offset + 1];
              }
            } else {
              val = buffer.parent[buffer.offset + offset];
              if (offset + 1 < buffer.length) {
                val |= buffer.parent[buffer.offset + offset + 1] << 8;
              }
            }

            return val;
          }

          Buffer.prototype.readUInt16LE = function(offset, noAssert) {
            return readUInt16(this, offset, false, noAssert);
          };

          Buffer.prototype.readUInt16BE = function(offset, noAssert) {
            return readUInt16(this, offset, true, noAssert);
          };

          function readUInt32(buffer, offset, isBigEndian, noAssert) {
            var val = 0;

            if (!noAssert) {
              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 3 < buffer.length, 'Trying to read beyond buffer length');
            }

            if (offset >= buffer.length) return 0;

            if (isBigEndian) {
              if (offset + 1 < buffer.length) val = buffer.parent[buffer.offset + offset + 1] << 16;
              if (offset + 2 < buffer.length) val |= buffer.parent[buffer.offset + offset + 2] << 8;
              if (offset + 3 < buffer.length) val |= buffer.parent[buffer.offset + offset + 3];
              val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
            } else {
              if (offset + 2 < buffer.length) val = buffer.parent[buffer.offset + offset + 2] << 16;
              if (offset + 1 < buffer.length) val |= buffer.parent[buffer.offset + offset + 1] << 8;
              val |= buffer.parent[buffer.offset + offset];
              if (offset + 3 < buffer.length) val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
            }

            return val;
          }

          Buffer.prototype.readUInt32LE = function(offset, noAssert) {
            return readUInt32(this, offset, false, noAssert);
          };

          Buffer.prototype.readUInt32BE = function(offset, noAssert) {
            return readUInt32(this, offset, true, noAssert);
          };


          /*
           * Signed integer types, yay team! A reminder on how two's complement actually
           * works. The first bit is the signed bit, i.e. tells us whether or not the
           * number should be positive or negative. If the two's complement value is
           * positive, then we're done, as it's equivalent to the unsigned representation.
           *
           * Now if the number is positive, you're pretty much done, you can just leverage
           * the unsigned translations and return those. Unfortunately, negative numbers
           * aren't quite that straightforward.
           *
           * At first glance, one might be inclined to use the traditional formula to
           * translate binary numbers between the positive and negative values in two's
           * complement. (Though it doesn't quite work for the most negative value)
           * Mainly:
           *  - invert all the bits
           *  - add one to the result
           *
           * Of course, this doesn't quite work in Javascript. Take for example the value
           * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
           * course, Javascript will do the following:
           *
           * > ~0xff80
           * -65409
           *
           * Whoh there, Javascript, that's not quite right. But wait, according to
           * Javascript that's perfectly correct. When Javascript ends up seeing the
           * constant 0xff80, it has no notion that it is actually a signed number. It
           * assumes that we've input the unsigned value 0xff80. Thus, when it does the
           * binary negation, it casts it into a signed value, (positive 0xff80). Then
           * when you perform binary negation on that, it turns it into a negative number.
           *
           * Instead, we're going to have to use the following general formula, that works
           * in a rather Javascript friendly way. I'm glad we don't support this kind of
           * weird numbering scheme in the kernel.
           *
           * (BIT-MAX - (unsigned)val + 1) * -1
           *
           * The astute observer, may think that this doesn't make sense for 8-bit numbers
           * (really it isn't necessary for them). However, when you get 16-bit numbers,
           * you do. Let's go back to our prior example and see how this will look:
           *
           * (0xffff - 0xff80 + 1) * -1
           * (0x007f + 1) * -1
           * (0x0080) * -1
           */
          Buffer.prototype.readInt8 = function(offset, noAssert) {
            var buffer = this;
            var neg;

            if (!noAssert) {
              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset < buffer.length, 'Trying to read beyond buffer length');
            }

            if (offset >= buffer.length) return;

            neg = buffer.parent[buffer.offset + offset] & 0x80;
            if (!neg) {
              return (buffer.parent[buffer.offset + offset]);
            }

            return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
          };

          function readInt16(buffer, offset, isBigEndian, noAssert) {
            var neg, val;

            if (!noAssert) {
              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 1 < buffer.length, 'Trying to read beyond buffer length');
            }

            val = readUInt16(buffer, offset, isBigEndian, noAssert);
            neg = val & 0x8000;
            if (!neg) {
              return val;
            }

            return (0xffff - val + 1) * -1;
          }

          Buffer.prototype.readInt16LE = function(offset, noAssert) {
            return readInt16(this, offset, false, noAssert);
          };

          Buffer.prototype.readInt16BE = function(offset, noAssert) {
            return readInt16(this, offset, true, noAssert);
          };

          function readInt32(buffer, offset, isBigEndian, noAssert) {
            var neg, val;

            if (!noAssert) {
              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 3 < buffer.length, 'Trying to read beyond buffer length');
            }

            val = readUInt32(buffer, offset, isBigEndian, noAssert);
            neg = val & 0x80000000;
            if (!neg) {
              return (val);
            }

            return (0xffffffff - val + 1) * -1;
          }

          Buffer.prototype.readInt32LE = function(offset, noAssert) {
            return readInt32(this, offset, false, noAssert);
          };

          Buffer.prototype.readInt32BE = function(offset, noAssert) {
            return readInt32(this, offset, true, noAssert);
          };

          function readFloat(buffer, offset, isBigEndian, noAssert) {
            if (!noAssert) {
              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset + 3 < buffer.length, 'Trying to read beyond buffer length');
            }

            return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
            23, 4);
          }

          Buffer.prototype.readFloatLE = function(offset, noAssert) {
            return readFloat(this, offset, false, noAssert);
          };

          Buffer.prototype.readFloatBE = function(offset, noAssert) {
            return readFloat(this, offset, true, noAssert);
          };

          function readDouble(buffer, offset, isBigEndian, noAssert) {
            if (!noAssert) {
              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset + 7 < buffer.length, 'Trying to read beyond buffer length');
            }

            return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
            52, 8);
          }

          Buffer.prototype.readDoubleLE = function(offset, noAssert) {
            return readDouble(this, offset, false, noAssert);
          };

          Buffer.prototype.readDoubleBE = function(offset, noAssert) {
            return readDouble(this, offset, true, noAssert);
          };


          /*
           * We have to make sure that the value is a valid integer. This means that it is
           * non-negative. It has no fractional component and that it does not exceed the
           * maximum allowed value.
           *
           *      value           The number to check for validity
           *
           *      max             The maximum value
           */
          function verifuint(value, max) {
            assert.ok(typeof(value) == 'number', 'cannot write a non-number as a number');

            assert.ok(value >= 0, 'specified a negative value for writing an unsigned value');

            assert.ok(value <= max, 'value is larger than maximum value for type');

            assert.ok(Math.floor(value) === value, 'value has a fractional component');
          }

          Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
            var buffer = this;

            if (!noAssert) {
              assert.ok(value !== undefined && value !== null, 'missing value');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset < buffer.length, 'trying to write beyond buffer length');

              verifuint(value, 0xff);
            }

            if (offset < buffer.length) {
              buffer.parent[buffer.offset + offset] = value;
            }
          };

          function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
            if (!noAssert) {
              assert.ok(value !== undefined && value !== null, 'missing value');

              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 1 < buffer.length, 'trying to write beyond buffer length');

              verifuint(value, 0xffff);
            }

            for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
              buffer.parent[buffer.offset + offset + i] = (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>> (isBigEndian ? 1 - i : i) * 8;
            }

          }

          Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
            writeUInt16(this, value, offset, false, noAssert);
          };

          Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
            writeUInt16(this, value, offset, true, noAssert);
          };

          function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
            if (!noAssert) {
              assert.ok(value !== undefined && value !== null, 'missing value');

              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 3 < buffer.length, 'trying to write beyond buffer length');

              verifuint(value, 0xffffffff);
            }

            for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
              buffer.parent[buffer.offset + offset + i] = (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
            }
          }

          Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
            writeUInt32(this, value, offset, false, noAssert);
          };

          Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
            writeUInt32(this, value, offset, true, noAssert);
          };


          /*
           * We now move onto our friends in the signed number category. Unlike unsigned
           * numbers, we're going to have to worry a bit more about how we put values into
           * arrays. Since we are only worrying about signed 32-bit values, we're in
           * slightly better shape. Unfortunately, we really can't do our favorite binary
           * & in this system. It really seems to do the wrong thing. For example:
           *
           * > -32 & 0xff
           * 224
           *
           * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
           * this aren't treated as a signed number. Ultimately a bad thing.
           *
           * What we're going to want to do is basically create the unsigned equivalent of
           * our representation and pass that off to the wuint* functions. To do that
           * we're going to do the following:
           *
           *  - if the value is positive
           *      we can pass it directly off to the equivalent wuint
           *  - if the value is negative
           *      we do the following computation:
           *         mb + val + 1, where
           *         mb   is the maximum unsigned value in that byte size
           *         val  is the Javascript negative integer
           *
           *
           * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
           * you do out the computations:
           *
           * 0xffff - 128 + 1
           * 0xffff - 127
           * 0xff80
           *
           * You can then encode this value as the signed version. This is really rather
           * hacky, but it should work and get the job done which is our goal here.
           */

          /*
           * A series of checks to make sure we actually have a signed 32-bit number
           */
          function verifsint(value, max, min) {
            assert.ok(typeof(value) == 'number', 'cannot write a non-number as a number');

            assert.ok(value <= max, 'value larger than maximum allowed value');

            assert.ok(value >= min, 'value smaller than minimum allowed value');

            assert.ok(Math.floor(value) === value, 'value has a fractional component');
          }

          function verifIEEE754(value, max, min) {
            assert.ok(typeof(value) == 'number', 'cannot write a non-number as a number');

            assert.ok(value <= max, 'value larger than maximum allowed value');

            assert.ok(value >= min, 'value smaller than minimum allowed value');
          }

          Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
            var buffer = this;

            if (!noAssert) {
              assert.ok(value !== undefined && value !== null, 'missing value');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset < buffer.length, 'Trying to write beyond buffer length');

              verifsint(value, 0x7f, - 0x80);
            }

            if (value >= 0) {
              buffer.writeUInt8(value, offset, noAssert);
            } else {
              buffer.writeUInt8(0xff + value + 1, offset, noAssert);
            }
          };

          function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
            if (!noAssert) {
              assert.ok(value !== undefined && value !== null, 'missing value');

              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 1 < buffer.length, 'Trying to write beyond buffer length');

              verifsint(value, 0x7fff, - 0x8000);
            }

            if (value >= 0) {
              writeUInt16(buffer, value, offset, isBigEndian, noAssert);
            } else {
              writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
            }
          }

          Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
            writeInt16(this, value, offset, false, noAssert);
          };

          Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
            writeInt16(this, value, offset, true, noAssert);
          };

          function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
            if (!noAssert) {
              assert.ok(value !== undefined && value !== null, 'missing value');

              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 3 < buffer.length, 'Trying to write beyond buffer length');

              verifsint(value, 0x7fffffff, - 0x80000000);
            }

            if (value >= 0) {
              writeUInt32(buffer, value, offset, isBigEndian, noAssert);
            } else {
              writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
            }
          }

          Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
            writeInt32(this, value, offset, false, noAssert);
          };

          Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
            writeInt32(this, value, offset, true, noAssert);
          };

          function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
            if (!noAssert) {
              assert.ok(value !== undefined && value !== null, 'missing value');

              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 3 < buffer.length, 'Trying to write beyond buffer length');

              verifIEEE754(value, 3.4028234663852886e+38, - 3.4028234663852886e+38);
            }

            require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
            23, 4);
          }

          Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
            writeFloat(this, value, offset, false, noAssert);
          };

          Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
            writeFloat(this, value, offset, true, noAssert);
          };

          function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
            if (!noAssert) {
              assert.ok(value !== undefined && value !== null, 'missing value');

              assert.ok(typeof(isBigEndian) === 'boolean', 'missing or invalid endian');

              assert.ok(offset !== undefined && offset !== null, 'missing offset');

              assert.ok(offset + 7 < buffer.length, 'Trying to write beyond buffer length');

              verifIEEE754(value, 1.7976931348623157E+308, - 1.7976931348623157E+308);
            }

            require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
            52, 8);
          }

          Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
            writeDouble(this, value, offset, false, noAssert);
          };

          Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
            writeDouble(this, value, offset, true, noAssert);
          };

          SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
          SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
          SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
          SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
          SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
          SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
          SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
          SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
          SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
          SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
          SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
          SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
          SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
          SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
          SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
          SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
          SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
          SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
          SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
          SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
          SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
          SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
          SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
          SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
          SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
          SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
          SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
          SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

        },

        "3a6e76760acad26f4fda49be6424ea8f": // from: node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js
        function(exports, require, module, __filename, __dirname) {
          (function(exports) {
            'use strict';

            var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

            function b64ToByteArray(b64) {
              var i, j, l, tmp, placeHolders, arr;

              if (b64.length % 4 > 0) {
                throw 'Invalid string. Length must be a multiple of 4';
              }

              // the number of equal signs (place holders)
              // if there are two placeholders, than the two characters before it
              // represent one byte
              // if there is only one, then the three characters before it represent 2 bytes
              // this is just a cheap hack to not do indexOf twice
              placeHolders = b64.indexOf('=');
              placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

              // base64 is 4/3 + up to two characters of the original data
              arr = []; //new Uint8Array(b64.length * 3 / 4 - placeHolders);

              // if there are placeholders, only get up to the last complete 4 chars
              l = placeHolders > 0 ? b64.length - 4 : b64.length;

              for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
                arr.push((tmp & 0xFF0000) >> 16);
                arr.push((tmp & 0xFF00) >> 8);
                arr.push(tmp & 0xFF);
              }

              if (placeHolders === 2) {
                tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
                arr.push(tmp & 0xFF);
              } else if (placeHolders === 1) {
                tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
                arr.push((tmp >> 8) & 0xFF);
                arr.push(tmp & 0xFF);
              }

              return arr;
            }

            function uint8ToBase64(uint8) {
              var i,
              extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                output = "",
                temp, length;

              function tripletToBase64(num) {
                return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
              };

              // go through the array every three bytes, we'll deal with trailing stuff later
              for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                output += tripletToBase64(temp);
              }

              // pad the end with zeros, but make sure to not forget the extra bytes
              switch (extraBytes) {
              case 1:
                temp = uint8[uint8.length - 1];
                output += lookup[temp >> 2];
                output += lookup[(temp << 4) & 0x3F];
                output += '==';
                break;
              case 2:
                temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
                output += lookup[temp >> 10];
                output += lookup[(temp >> 4) & 0x3F];
                output += lookup[(temp << 2) & 0x3F];
                output += '=';
                break;
              }

              return output;
            }

            module.exports.toByteArray = b64ToByteArray;
            module.exports.fromByteArray = uint8ToBase64;
          }());

        },

        "e926a8d145979e541da928088365eecf": // from: node_modules/cookiejar/cookiejar.js
        function(exports, require, module, __filename, __dirname) {
          exports.CookieAccessInfo = CookieAccessInfo = function CookieAccessInfo(domain, path, secure, script) {
            if (this instanceof CookieAccessInfo) {
              this.domain = domain || undefined;
              this.path = path || "/";
              this.secure = !! secure;
              this.script = !! script;
              return this;
            } else {
              return new CookieAccessInfo(domain, path, secure, script)
            }
          }

          exports.Cookie = Cookie = function Cookie(cookiestr) {
            if (cookiestr instanceof Cookie) {
              return cookiestr;
            } else {
              if (this instanceof Cookie) {
                this.name = null;
                this.value = null;
                this.expiration_date = Infinity;
                this.path = "/";
                this.domain = null;
                this.secure = false; //how to define?
                this.noscript = false; //httponly
                if (cookiestr) {
                  this.parse(cookiestr)
                }
                return this;
              }
              return new Cookie(cookiestr)
            }
          }

          Cookie.prototype.toString = function toString() {
            var str = [this.name + "=" + this.value];
            if (this.expiration_date !== Infinity) {
              str.push("expires=" + (new Date(this.expiration_date)).toGMTString());
            }
            if (this.domain) {
              str.push("domain=" + this.domain);
            }
            if (this.path) {
              str.push("path=" + this.path);
            }
            if (this.secure) {
              str.push("secure");
            }
            if (this.noscript) {
              str.push("httponly");
            }
            return str.join("; ");
          }

          Cookie.prototype.toValueString = function toValueString() {
            return this.name + "=" + this.value;
          }

          var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g
          Cookie.prototype.parse = function parse(str) {
            if (this instanceof Cookie) {
              var parts = str.split(";"),
                pair = parts[0].match(/([^=]+)=((?:.|\n)*)/),
                key = pair[1],
                value = pair[2];
              this.name = key;
              this.value = value;

              for (var i = 1; i < parts.length; i++) {
                pair = parts[i].match(/([^=]+)(?:=((?:.|\n)*))?/), key = pair[1].trim().toLowerCase(), value = pair[2];
                switch (key) {
                case "httponly":
                  this.noscript = true;
                  break;
                case "expires":
                  this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                  break;
                case "path":
                  this.path = value ? value.trim() : "";
                  break;
                case "domain":
                  this.domain = value ? value.trim() : "";
                  break;
                case "secure":
                  this.secure = true;
                  break
                }
              }

              return this;
            }
            return new Cookie().parse(str)
          }

          Cookie.prototype.matches = function matches(access_info) {
            if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
              return false
            }
            return true;
          }

          Cookie.prototype.collidesWith = function collidesWith(access_info) {
            if ((this.path && !access_info.path) || (this.domain && !access_info.domain)) {
              return false
            }
            if (this.path && access_info.path.indexOf(this.path) !== 0) {
              return false;
            }
            if (this.domain === access_info.domain) {
              return true;
            } else if (this.domain && this.domain.charAt(0) === ".") {
              var wildcard = access_info.domain.indexOf(this.domain.slice(1))
              if (wildcard === -1 || wildcard !== access_info.domain.length - this.domain.length + 1) {
                return false;
              }
            } else if (this.domain) {
              return false
            }
            return true;
          }

          exports.CookieJar = CookieJar = function CookieJar() {
            if (this instanceof CookieJar) {
              var cookies = {} //name: [Cookie]

              this.setCookie = function setCookie(cookie) {
                cookie = Cookie(cookie);
                //Delete the cookie if the set is past the current time
                var remove = cookie.expiration_date <= Date.now();
                if (cookie.name in cookies) {
                  var cookies_list = cookies[cookie.name];
                  for (var i = 0; i < cookies_list.length; i++) {
                    var collidable_cookie = cookies_list[i];
                    if (collidable_cookie.collidesWith(cookie)) {
                      if (remove) {
                        cookies_list.splice(i, 1);
                        if (cookies_list.length === 0) {
                          delete cookies[cookie.name]
                        }
                        return false;
                      } else {
                        return cookies_list[i] = cookie;
                      }
                    }
                  }
                  if (remove) {
                    return false;
                  }
                  cookies_list.push(cookie);
                  return cookie;
                } else if (remove) {
                  return false;
                } else {
                  return cookies[cookie.name] = [cookie];
                }
              }
              //returns a cookie
              this.getCookie = function getCookie(cookie_name, access_info) {
                var cookies_list = cookies[cookie_name];
                for (var i = 0; i < cookies_list.length; i++) {
                  var cookie = cookies_list[i];
                  if (cookie.expiration_date <= Date.now()) {
                    if (cookies_list.length === 0) {
                      delete cookies[cookie.name]
                    }
                    continue;
                  }
                  if (cookie.matches(access_info)) {
                    return cookie;
                  }
                }
              }
              //returns a list of cookies
              this.getCookies = function getCookies(access_info) {
                var matches = [];
                for (var cookie_name in cookies) {
                  var cookie = this.getCookie(cookie_name, access_info);
                  if (cookie) {
                    matches.push(cookie);
                  }
                }
                matches.toString = function toString() {
                  return matches.join(":");
                }
                matches.toValueString = function() {
                  return matches.map(function(c) {
                    return c.toValueString();
                  }).join(';');
                }
                return matches;
              }

              return this;
            }
            return new CookieJar()
          }


          //returns list of cookies that were set correctly
          CookieJar.prototype.setCookies = function setCookies(cookies) {
            cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
            var successful = []
            for (var i = 0; i < cookies.length; i++) {
              var cookie = Cookie(cookies[i]);
              if (this.setCookie(cookie)) {
                successful.push(cookie);
              }
            }
            return successful;
          }

        },

        "972690d006842c98fda9e56ccf594a63": // from: node_modules/sprintf/lib/sprintf.js
        function(exports, require, module, __filename, __dirname) {
          /**
sprintf() for JavaScript 0.7-beta1
http://www.diveintojavascript.com/projects/javascript-sprintf

Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of sprintf() for JavaScript nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Changelog:
2010.11.07 - 0.7-beta1-node
  - converted it to a node.js compatible module

2010.09.06 - 0.7-beta1
  - features: vsprintf, support for named placeholders
  - enhancements: format cache, reduced global namespace pollution

2010.05.22 - 0.6:
 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
 Note:
 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
 who warned me about a bug in 0.5, I discovered that the last update was
 a regress. I appologize for that.

2010.05.09 - 0.5:
 - bug fix: 0 is now preceeded with a + sign
 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
 - switched from GPL to BSD license

2007.10.21 - 0.4:
 - unit test and patch (David Baird)

2007.09.17 - 0.3:
 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)

2007.09.11 - 0.2:
 - feature: added argument swapping

2007.04.03 - 0.1:
 - initial release
**/

          var sprintf = (function() {
            function get_type(variable) {
              return Object.prototype.toString.call(variable).slice(8, - 1).toLowerCase();
            }

            function str_repeat(input, multiplier) {
              for (var output = []; multiplier > 0; output[--multiplier] = input) { /* do nothing */
              }
              return output.join('');
            }

            var str_format = function() {
              if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
              }
              return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
            };

            str_format.format = function(parse_tree, argv) {
              var cursor = 1,
                tree_length = parse_tree.length,
                node_type = '',
                arg, output = [],
                i, k, match, pad, pad_character, pad_length;
              for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === 'string') {
                  output.push(parse_tree[i]);
                } else if (node_type === 'array') {
                  match = parse_tree[i]; // convenience purposes only
                  if (match[2]) { // keyword argument
                    arg = argv[cursor];
                    for (k = 0; k < match[2].length; k++) {
                      if (!arg.hasOwnProperty(match[2][k])) {
                        throw (sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                      }
                      arg = arg[match[2][k]];
                    }
                  } else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]];
                  } else { // positional argument (implicit)
                    arg = argv[cursor++];
                  }

                  if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                    throw (sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                  }
                  switch (match[8]) {
                  case 'b':
                    arg = arg.toString(2);
                    break;
                  case 'c':
                    arg = String.fromCharCode(arg);
                    break;
                  case 'd':
                    arg = parseInt(arg, 10);
                    break;
                  case 'e':
                    arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                    break;
                  case 'f':
                    arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                    break;
                  case 'o':
                    arg = arg.toString(8);
                    break;
                  case 's':
                    arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg);
                    break;
                  case 'u':
                    arg = Math.abs(arg);
                    break;
                  case 'x':
                    arg = arg.toString(16);
                    break;
                  case 'X':
                    arg = arg.toString(16).toUpperCase();
                    break;
                  }
                  arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg);
                  pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                  pad_length = match[6] - String(arg).length;
                  pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                  output.push(match[5] ? arg + pad : pad + arg);
                }
              }
              return output.join('');
            };

            str_format.cache = {};

            str_format.parse = function(fmt) {
              var _fmt = fmt,
                match = [],
                parse_tree = [],
                arg_names = 0;
              while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                  parse_tree.push(match[0]);
                } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                  parse_tree.push('%');
                } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                  if (match[2]) {
                    arg_names |= 1;
                    var field_list = [],
                      replacement_field = match[2],
                      field_match = [];
                    if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                      field_list.push(field_match[1]);
                      while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                        if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                          field_list.push(field_match[1]);
                        } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                          field_list.push(field_match[1]);
                        } else {
                          throw ('[sprintf] huh?');
                        }
                      }
                    } else {
                      throw ('[sprintf] huh?');
                    }
                    match[2] = field_list;
                  } else {
                    arg_names |= 2;
                  }
                  if (arg_names === 3) {
                    throw ('[sprintf] mixing positional and named placeholders is not (yet) supported');
                  }
                  parse_tree.push(match);
                } else {
                  throw ('[sprintf] huh?');
                }
                _fmt = _fmt.substring(match[0].length);
              }
              return parse_tree;
            };

            return str_format;
          })();

          var vsprintf = function(fmt, argv) {
            argv.unshift(fmt);
            return sprintf.apply(null, argv);
          };

          exports.sprintf = sprintf;
          exports.vsprintf = vsprintf;
        },

        "a089014e00fc816889fd3a26e987bdbd": // from: node_modules/testify/node_modules/colors/colors.js
        function(exports, require, module, __filename, __dirname) {
          /*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

          var isHeadless = false;

          if (typeof module !== 'undefined') {
            isHeadless = true;
          }

          if (!isHeadless) {
            var exports = {};
            var module = {};
            var colors = exports;
            exports.mode = "browser";
          } else {
            exports.mode = "console";
          }

          //
          // Prototypes the string object to have additional method calls that add terminal colors
          //
          var addProperty = function(color, func) {
            var allowOverride = ['bold'];
            exports[color] = function(str) {
              return func.apply(str);
            };
            String.prototype.__defineGetter__(color, func);
          }

          //
          // Iterate through all default styles and colors
          //

          var x = ['bold', 'underline', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
          x.forEach(function(style) {

            // __defineGetter__ at the least works in more browsers
            // http://robertnyman.com/javascript/javascript-getters-setters.html
            // Object.defineProperty only works in Chrome
            addProperty(style, function() {
              return stylize(this, style);
            });
          });

          function sequencer(map) {
            return function() {
              if (!isHeadless) {
                return this.replace(/( )/, '$1');
              }
              var exploded = this.split("");
              var i = 0;
              exploded = exploded.map(map);
              return exploded.join("");
            }
          }

          var rainbowMap = (function() {
            var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
            return function(letter, i, exploded) {
              if (letter == " ") {
                return letter;
              } else {
                return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
              }
            }
          })();

          exports.addSequencer = function(name, map) {
            addProperty(name, sequencer(map));
          }

          exports.addSequencer('rainbow', rainbowMap);
          exports.addSequencer('zebra', function(letter, i, exploded) {
            return i % 2 === 0 ? letter : letter.inverse;
          });

          exports.setTheme = function(theme) {
            Object.keys(theme).forEach(function(prop) {
              addProperty(prop, function() {
                return exports[theme[prop]](this);
              });
            });
          }

          function stylize(str, style) {

            if (exports.mode == 'console') {
              var styles = {
                //styles
                'bold': ['\033[1m', '\033[22m'],
                'italic': ['\033[3m', '\033[23m'],
                'underline': ['\033[4m', '\033[24m'],
                'inverse': ['\033[7m', '\033[27m'],
                //grayscale
                'white': ['\033[37m', '\033[39m'],
                'grey': ['\033[90m', '\033[39m'],
                'black': ['\033[30m', '\033[39m'],
                //colors
                'blue': ['\033[34m', '\033[39m'],
                'cyan': ['\033[36m', '\033[39m'],
                'green': ['\033[32m', '\033[39m'],
                'magenta': ['\033[35m', '\033[39m'],
                'red': ['\033[31m', '\033[39m'],
                'yellow': ['\033[33m', '\033[39m']
              };
            } else if (exports.mode == 'browser') {
              var styles = {
                //styles
                'bold': ['<b>', '</b>'],
                'italic': ['<i>', '</i>'],
                'underline': ['<u>', '</u>'],
                'inverse': ['<span style="background-color:black;color:white;">', '</span>'],
                //grayscale
                'white': ['<span style="color:white;">', '</span>'],
                'grey': ['<span style="color:grey;">', '</span>'],
                'black': ['<span style="color:black;">', '</span>'],
                //colors
                'blue': ['<span style="color:blue;">', '</span>'],
                'cyan': ['<span style="color:cyan;">', '</span>'],
                'green': ['<span style="color:green;">', '</span>'],
                'magenta': ['<span style="color:magenta;">', '</span>'],
                'red': ['<span style="color:red;">', '</span>'],
                'yellow': ['<span style="color:yellow;">', '</span>']
              };
            } else if (exports.mode == 'none') {
              return str;
            } else {
              console.log('unsupported mode, try "browser", "console" or "none"');
            }
            return styles[style][0] + str + styles[style][1];
          };

          // don't summon zalgo
          addProperty('zalgo', function() {
            return zalgo(this);
          });

          // please no
          function zalgo(text, options) {
            var soul = {
              "up": ['̍', '̎', '̄', '̅', '̿', '̑', '̆', '̐', '͒', '͗', '͑', '̇', '̈', '̊', '͂', '̓', '̈', '͊', '͋', '͌', '̃', '̂', '̌', '͐', '̀', '́', '̋', '̏', '̒', '̓', '̔', '̽', '̉', 'ͣ', 'ͤ', 'ͥ', 'ͦ', 'ͧ', 'ͨ', 'ͩ', 'ͪ', 'ͫ', 'ͬ', 'ͭ', 'ͮ', 'ͯ', '̾', '͛', '͆', '̚'],
              "down": ['̖', '̗', '̘', '̙', '̜', '̝', '̞', '̟', '̠', '̤', '̥', '̦', '̩', '̪', '̫', '̬', '̭', '̮', '̯', '̰', '̱', '̲', '̳', '̹', '̺', '̻', '̼', 'ͅ', '͇', '͈', '͉', '͍', '͎', '͓', '͔', '͕', '͖', '͙', '͚', '̣'],
              "mid": ['̕', '̛', '̀', '́', '͘', '̡', '̢', '̧', '̨', '̴', '̵', '̶', '͜', '͝', '͞', '͟', '͠', '͢', '̸', '̷', '͡', ' ҉']
            },
            all = [].concat(soul.up, soul.down, soul.mid),
              zalgo = {};

            function randomNumber(range) {
              r = Math.floor(Math.random() * range);
              return r;
            };

            function is_char(character) {
              var bool = false;
              all.filter(function(i) {
                bool = (i == character);
              });
              return bool;
            }

            function heComes(text, options) {
              result = '';
              options = options || {};
              options["up"] = options["up"] || true;
              options["mid"] = options["mid"] || true;
              options["down"] = options["down"] || true;
              options["size"] = options["size"] || "maxi";
              var counts;
              text = text.split('');
              for (var l in text) {
                if (is_char(l)) {
                  continue;
                }
                result = result + text[l];

                counts = {
                  "up": 0,
                  "down": 0,
                  "mid": 0
                };

                switch (options.size) {
                case 'mini':
                  counts.up = randomNumber(8);
                  counts.min = randomNumber(2);
                  counts.down = randomNumber(8);
                  break;
                case 'maxi':
                  counts.up = randomNumber(16) + 3;
                  counts.min = randomNumber(4) + 1;
                  counts.down = randomNumber(64) + 3;
                  break;
                default:
                  counts.up = randomNumber(8) + 1;
                  counts.mid = randomNumber(6) / 2;
                  counts.down = randomNumber(8) + 1;
                  break;
                }

                var arr = ["up", "mid", "down"];
                for (var d in arr) {
                  var index = arr[d];
                  for (var i = 0; i <= counts[index]; i++) {
                    if (options[index]) {
                      result = result + soul[index][randomNumber(soul[index].length)];
                    }
                  }
                }
              }
              return result;
            };
            return heComes(text);
          }

          addProperty('stripColors', function() {
            return ("" + this).replace(/\u001b\[\d+m/g, '');
          });

        },

        "865b933cdca5bf49b1f012335b02ff93": // from: node_modules/testify/node_modules/colors/example.js
        function(exports, require, module, __filename, __dirname) {
          var colors = require('./colors');

          //colors.mode = "browser";

          var test = colors.red("hopefully colorless output");
          console.log('Rainbows are fun!'.rainbow);
          console.log('So '.italic + 'are'.underline + ' styles! '.bold + 'inverse'.inverse); // styles not widely supported
          console.log('Chains are also cool.'.bold.italic.underline.red); // styles not widely supported
          //console.log('zalgo time!'.zalgo);
          console.log(test.stripColors);
          console.log("a".grey + " b".black);

          console.log("Zebras are so fun!".zebra);

          console.log(colors.rainbow('Rainbows are fun!'));
          console.log(colors.italic('So ') + colors.underline('are') + colors.bold(' styles! ') + colors.inverse('inverse')); // styles not widely supported
          console.log(colors.bold(colors.italic(colors.underline(colors.red('Chains are also cool.'))))); // styles not widely supported
          //console.log(colors.zalgo('zalgo time!'));
          console.log(colors.stripColors(test));
          console.log(colors.grey("a") + colors.black(" b"));

          colors.addSequencer("america", function(letter, i, exploded) {
            if (letter === " ") return letter;
            switch (i % 3) {
            case 0:
              return letter.red;
            case 1:
              return letter.white;
            case 2:
              return letter.blue;
            }
          });

          colors.addSequencer("random", (function() {
            var available = ['bold', 'underline', 'italic', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];

            return function(letter, i, exploded) {
              return letter === " " ? letter : letter[available[Math.round(Math.random() * (available.length - 1))]];
            };
          })());

          console.log("AMERICA! F--K YEAH!".america);
          console.log("So apparently I've been to Mars, with all the little green men. But you know, I don't recall.".random);

          //
          // Custom themes
          //

          colors.setTheme({
            silly: 'rainbow',
            input: 'grey',
            verbose: 'cyan',
            prompt: 'grey',
            info: 'green',
            data: 'grey',
            help: 'cyan',
            warn: 'yellow',
            debug: 'blue',
            error: 'red'
          });

          // outputs red text
          console.log("this is an error".error);

          // outputs yellow text
          console.log("this is a warning".warn);



        },

        "c3451fe7035e99947143be3e88c3eaef": // from: node_modules/testify/node_modules/colors/test.js
        function(exports, require, module, __filename, __dirname) {
          var assert = require('assert'),
            colors = require('./colors');

          // 
          // This is a pretty nice example on how tests shouldn't be written. However,
          // it's more about API stability than about really testing it (although it's
          // a pretty complete test suite).
          //

          var s = 'string';

          function a(s, code) {
            return '\033[' + code.toString() + 'm' + s + '\033[39m';
          }

          function aE(s, color, code) {
            assert.equal(s[color], a(s, code));
            assert.equal(colors[color](s), a(s, code));
            assert.equal(s[color], colors[color](s));
            assert.equal(s[color].stripColors, s);
            assert.equal(s[color].stripColors, colors.stripColors(s));
          }

          function h(s, color) {
            return '<span style="color:' + color + ';">' + s + '</span>';
            // that's pretty dumb approach to testing it
          }

          var stylesColors = ['white', 'grey', 'black', 'blue', 'cyan', 'green', 'magenta', 'red', 'yellow'];
          var stylesAll = stylesColors.concat(['bold', 'italic', 'underline', 'inverse', 'rainbow']);

          colors.mode = 'console';
          assert.equal(s.bold, '\033[1m' + s + '\033[22m');
          assert.equal(s.italic, '\033[3m' + s + '\033[23m');
          assert.equal(s.underline, '\033[4m' + s + '\033[24m');
          assert.equal(s.inverse, '\033[7m' + s + '\033[27m');
          assert.ok(s.rainbow);
          aE(s, 'white', 37);
          aE(s, 'grey', 90);
          aE(s, 'black', 30);
          aE(s, 'blue', 34);
          aE(s, 'cyan', 36);
          aE(s, 'green', 32);
          aE(s, 'magenta', 35);
          aE(s, 'red', 31);
          aE(s, 'yellow', 33);
          assert.equal(s, 'string');

          colors.mode = 'browser';
          assert.equal(s.bold, '<b>' + s + '</b>');
          assert.equal(s.italic, '<i>' + s + '</i>');
          assert.equal(s.underline, '<u>' + s + '</u>');
          assert.equal(s.inverse, '<span style="background-color:black;color:white;">' + s + '</span>');
          assert.ok(s.rainbow);
          stylesColors.forEach(function(color) {
            assert.equal(s[color], h(s, color));
            assert.equal(colors[color](s), h(s, color));
          });

          colors.mode = 'none';
          stylesAll.forEach(function(style) {
            assert.equal(s[style], s);
            assert.equal(colors[style](s), s);
          });


        },

        "d7c4041289e5445eec291db26b21409d": // from: node_modules/testify/node_modules/minfinite/minfinite.js
        function(exports, require, module, __filename, __dirname) {
          // Generated by CoffeeScript 1.4.0
          (function() {
            var EventEmitter, FSM,
            __slice = [].slice;

            EventEmitter = require("events").EventEmitter;

            module.exports = FSM = (function() {

              function FSM(initial_state) {
                if (initial_state == null) {
                  initial_state = "START";
                }
                this.state = initial_state;
                this.emitter = new EventEmitter();
              }

              FSM.prototype.define = function(table) {
                if (this.validate(table)) {
                  return this.table = table;
                } else {
                  throw new Error("Invalid state table");
                }
              };

              FSM.prototype.validate = function(table) {
                var action, def, event, next, state, transition;
                for (state in table) {
                  def = table[state];
                  if (!(Object.keys(def).length > 0)) {
                    return false;
                  }
                  for (event in def) {
                    transition = def[event];
                    action = transition.action, next = transition.next;
                    if (typeof action !== "function") {
                      console.log("Action for " + state + ", " + event + " is not a function");
                      return false;
                    }
                    if (typeof next !== "string") {
                      console.log("Next state for " + state + ", " + event + " is not a string");
                      return false;
                    }
                    if (!table[next]) {
                      console.log("Next state for " + state + ", " + event + " does not exist");
                      return false;
                    }
                  }
                }
                return true;
              };

              FSM.prototype.event = function() {
                var action, args, current_state, name, next, transition;
                name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                current_state = this.state;
                transition = this.table[this.state][name];
                if (!transition) {
                  console.error("State(" + this.state + ") has no transition for Event(" + name + ")");
                } else {
                  action = transition.action, next = transition.next;
                  action.apply(null, args);
                  this.state = next;
                }
                if (this.state !== current_state) {
                  return this.emitter.emit(this.state);
                }
              };

              return FSM;

            })();

          }).call(this);

        },

        "e771513490ac1884ffed5cef377b37be": // from: node_modules/testify/src/benchmark.coffee
        function(exports, require, module, __filename, __dirname) {
          var Benchmark, Context, Dataset, microtime,
          __hasProp = {}.hasOwnProperty,
            __extends = function(child, parent) {
              for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            },
            __slice = [].slice;

          microtime = require("microtime");

          require("../statistics");

          Context = require("./context");

          module.exports = Benchmark = (function(_super) {

            __extends(Benchmark, _super);

            function Benchmark() {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              this.results = {};
              Benchmark.__super__.constructor.apply(this, args);
            }

            Benchmark.prototype.measure = function(name, work) {
              return this.child(name, work);
            };

            Benchmark.prototype.run = function(options, callback) {
              var count, done_handler, iterate, iterations, results, suite_start,
              _this = this;
              iterations = options.iterations;
              count = 0;
              results = {};
              suite_start = microtime.now();
              done_handler = function() {
                var data, finish_time, name, out, values, _ref;
                finish_time = microtime.now();
                out = {
                  runtime: finish_time - suite_start,
                  data: data = {}
                };
                _ref = _this.results;
                for (name in _ref) {
                  values = _ref[name];
                  data[name] = new Dataset(values);
                }
                if (callback) {
                  return callback(out);
                }
              };
              process.stdout.write("Iteration: ");
              iterate = function() {
                if (++count <= iterations) {
                  if (count % 5 === 0 || count === 1) {
                    process.stdout.write(count.toString());
                  } else {
                    process.stdout.write(".");
                  }
                  return _this._run();
                } else {
                  process.stdout.write("\n");
                  return done_handler();
                }
              };
              this.fsm.emitter.on("COMPLETE", function() {
                _this.event("reset");
                return iterate();
              });
              return iterate();
            };

            Benchmark.prototype._run = function() {
              var _this = this;
              this.record_start(this.name, - microtime.now());
              this.fsm.emitter.once("COMPLETE", function() {
                var finish_time;
                finish_time = microtime.now();
                return _this.record_end(_this.name, finish_time);
              });
              return Benchmark.__super__._run.call(this);
            };

            Benchmark.prototype.record_start = function(name, value) {
              var array, _base;
              if (this.parent) {
                return this.parent.record_start(name, value);
              } else {
                if (name !== this.name) {
                  array = ((_base = this.results)[name] || (_base[name] = []));
                  return array.push(value);
                }
              }
            };

            Benchmark.prototype.record_end = function(name, value) {
              var array, index, _base;
              if (this.parent) {
                return this.parent.record_end(name, value);
              } else {
                if (name !== this.name) {
                  array = ((_base = this.results)[name] || (_base[name] = []));
                  index = array.length - 1;
                  return array[index] = array[index] + value;
                }
              }
            };

            Benchmark.prototype.finish = function() {
              if (this.is_done()) {
                return this.event("completion");
              }
            };

            return Benchmark;

          })(Context);

          Dataset = (function() {

            function Dataset(array) {
              this.data = array;
            }

            Dataset.prototype.summarize = function() {
              var args, _ref;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              return (_ref = this.data).summarize.apply(_ref, args);
            };

            return Dataset;

          })();

        },

        "1f082de170804a1f8caa134abdafdb55": // from: node_modules/testify/src/context.coffee
        function(exports, require, module, __filename, __dirname) {
          var Context, EventEmitter, FSM,
          __slice = [].slice;

          EventEmitter = require("events").EventEmitter;

          FSM = require("minfinite");

          module.exports = Context = (function() {

            function Context(name, work, parent) {
              var _this = this;
              this.name = name;
              this.work = work;
              this.parent = parent;
              if (this.work.length === 0) {
                this.type = "sync";
              } else {
                this.type = "async";
              }
              if (this.parent) {
                this.level = this.parent.level + 1;
              } else {
                this.level = 0;
              }
              this.children = [];
              this.emitter = new EventEmitter();
              this.fsm = new FSM();
              this.fsm.define({
                START: {
                  sync_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "SYNC"
                  },
                  async_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  childless: {
                    action: function() {},
                    next: "CHILDLESS"
                  },
                  end_of_block: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  }
                },
                SYNC: {
                  sync_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "SYNC"
                  },
                  async_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  end_of_block: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  },
                  completion: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  }
                },
                ASYNC: {
                  sync_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  async_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  end_of_block: {
                    action: function() {},
                    next: "ASYNC"
                  },
                  completion: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  }
                },
                CHILDLESS: {
                  sync_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "SYNC"
                  },
                  async_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  completion: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  }
                },
                COMPLETE: {
                  sync_child: {
                    action: function() {
                      throw new Error("Context '" + _this.name + "' created a synchronous child after it had completed");
                    },
                    next: "COMPLETE"
                  },
                  completion: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "COMPLETE"
                  },
                  reset: {
                    action: function() {},
                    next: "START"
                  }
                }
              });
            }

            Context.prototype.state = function() {
              return this.fsm.state;
            };

            Context.prototype.event = function() {
              var args, name, _ref;
              name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
              return (_ref = this.fsm).event.apply(_ref, [name].concat(__slice.call(args)));
            };

            Context.prototype.is_done = function() {
              return this.children.every(function(child) {
                return child.state() === "COMPLETE";
              });
            };

            Context.prototype.notify_parent = function() {
              var _this = this;
              return setTimeout((function() {
                var _ref, _ref1;
                if ((_ref = _this.parent) != null ? _ref.is_done() : void 0) {
                  return (_ref1 = _this.parent) != null ? _ref1.event("completion", _this) : void 0;
                }
              }), 0);
            };

            Context.prototype.done = function() {
              return this.event("completion");
            };

            Context.prototype.child = function(description, work) {
              var child;
              child = new this.constructor(description, work, this);
              if (child.type === "sync") {
                this.event("sync_child", child);
              } else if (child.type === "async") {
                this.event("async_child", child);
              } else {
                throw new Error("bad type: " + child.type);
              }
              this.children.push(child);
              this.emitter.emit("child", child);
              return child._run();
            };

            Context.prototype._run = function() {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              this.work(this);
              if (this.type === "sync" || this.children.length > 0) {
                return this.event("end_of_block");
              } else {
                return this.event("childless");
              }
            };

            return Context;

          })();

        },

        "7abe6dc3c91fe653e9c4a2d096ee8684": // from: node_modules/testify/src/reporters.coffee
        function(exports, require, module, __filename, __dirname) {
          var ConsoleReporter, DOMReporter;

          ConsoleReporter = (function() {

            function ConsoleReporter() {}

            ConsoleReporter.prototype.add_suite = function(suite) {
              var _this = this;
              suite.emitter.on("child", function(child) {
                return _this.hook(child);
              });
              suite.fsm.emitter.on("COMPLETE", function() {
                return _this.report_suite(suite);
              });
              return process.on("exit", function() {
                return _this.report_suite(suite);
              });
            };

            ConsoleReporter.prototype.hook = function(child) {
              var _this = this;
              child.emitter.on("child", function(context) {
                return _this.hook(context);
              });
              return child.emitter.on("status", function(status) {
                return _this.status(status);
              });
            };

            ConsoleReporter.prototype.status = function(type) {
              var abbrev;
              if (abbrev = this.abbreviation[type]) {
                return process.stdout.write(this.colorize(type, abbrev));
              }
            };

            ConsoleReporter.prototype.abbreviation = {
              pass: ".",
              incomplete: "I",
              failure: "F",
              error: "E"
            };

            ConsoleReporter.prototype.report_suite = function(suite) {
              var level, result, test, _i, _len;
              if (suite._reported) {
                return;
              } else {
                suite._reported = true;
              }
              if (suite.failed) {
                suite.name = "" + suite.name + " (FAILED)";
              } else {
                suite.name = "" + suite.name + " (PASSED)";
              }
              result = [];
              this.collect(suite, result);
              for (_i = 0, _len = result.length; _i < _len; _i++) {
                test = result[_i];
                level = test.level;
                if (test.state() !== "COMPLETE") {
                  this.result("" + test.name + " ( incomplete )", {
                    type: "incomplete",
                    level: level
                  });
                } else if (test.failed === false) {
                  this.result(test.name, {
                    type: "pass",
                    level: level
                  });
                } else if (test.failed.constructor === String || test.failed.name === "AssertionError") {
                  this.result("" + test.name + " ( " + (test.failed.toString()) + " )", {
                    type: "failure",
                    level: level,
                    stack: test.failed.stack
                  });
                } else {
                  this.result("" + test.name + " ( " + (test.failed.toString()) + " )", {
                    type: "error",
                    level: level,
                    stack: test.failed.stack
                  });
                }
              }
              if (suite.failed && process.exit) {
                return process.exit(1);
              }
            };

            ConsoleReporter.prototype.collect = function(context, array) {
              var item, _i, _len, _ref, _results;
              if (array == null) {
                array = [];
              }
              array.push(context);
              _ref = context.children;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                _results.push(this.collect(item, array));
              }
              return _results;
            };

            ConsoleReporter.prototype.result = function(string, options) {
              var level, match, regex, space, where;
              if (options == null) {
                options = {};
              }
              if (!this._receiving_results) {
                console.log();
                this._receiving_results = true;
              }
              if (options.type) {
                string = this.colorize(options.type, string);
              }
              if (level = options.level) {
                space = "";
                while (level--) {
                  space = space + "    ";
                }
                string = space + string;
              }
              console.log(string);
              if (options.stack) {
                where = options.stack.split("\n")[1];
                regex = /\((.*)\)/;
                match = regex.exec(where);
                try {
                  return console.log(space + match[1]);
                } catch (error) {
                  return console.log(space + where.slice(7));
                }
              }
            };

            ConsoleReporter.prototype.colorize = function(type, string) {
              var color;
              if (color = this.color_map[type]) {
                return string[color];
              } else {
                return string;
              }
            };

            ConsoleReporter.prototype.color_map = {
              pass: "green",
              incomplete: "magenta",
              failure: "red",
              error: "yellow"
            };

            return ConsoleReporter;

          })();

          DOMReporter = (function() {

            function DOMReporter(id, options) {
              if (options == null) {
                options = {};
              }
              this.timeout = options.timeout || 2000;
              this.root = document.getElementById(id);
              this.suites = [];
            }

            DOMReporter.prototype.add_suite = function(suite) {
              var _this = this;
              this.suite_dom(suite);
              suite.emitter.on("child", function(child) {
                return _this.handle_child(suite, child);
              });
              suite.fsm.emitter.on("COMPLETE", function() {
                return _this.report_suite(suite);
              });
              return setTimeout((function() {
                return _this.report_suite(suite);
              }), this.timeout);
            };

            DOMReporter.prototype.handle_child = function(suite, child) {
              var _this = this;
              this.test_dom(child);
              child.emitter.on("child", function(context) {
                return _this.handle_child(suite, context);
              });
              return child.emitter.on("status", function(status) {
                return _this.status(suite, child, status);
              });
            };

            DOMReporter.prototype.report_suite = function(suite) {
              var level, test, tests, _i, _j, _len, _len1, _ref, _results;
              if (suite._reported) {
                return;
              } else {
                suite._reported = true;
              }
              if (suite.state() !== "COMPLETE") {
                suite._html.title.classList.add("incomplete");
              } else if (suite.failed === false) {
                suite._html.title.classList.add("pass");
              } else {
                suite._html.title.classList.add("failed");
              }
              tests = [];
              _ref = suite.children;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                test = _ref[_i];
                this.collect(test, tests);
              }
              _results = [];
              for (_j = 0, _len1 = tests.length; _j < _len1; _j++) {
                test = tests[_j];
                level = test.level;
                if (test.state() !== "COMPLETE") {
                  _results.push(this.result(test, {
                    type: "incomplete"
                  }));
                } else if (test.failed === false) {
                  _results.push(this.result(test, {
                    type: "pass"
                  }));
                } else if (test.failed.constructor === String || test.failed.name === "AssertionError") {
                  _results.push(this.result(test, {
                    type: "failure",
                    stack: test.failed.stack
                  }));
                } else {
                  _results.push(this.result(test, {
                    type: "error",
                    stack: test.failed.stack
                  }));
                }
              }
              return _results;
            };

            DOMReporter.prototype.collect = function(context, array) {
              var item, _i, _len, _ref;
              if (array == null) {
                array = [];
              }
              array.push(context);
              _ref = context.children;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                this.collect(item, array);
              }
              return array;
            };

            DOMReporter.prototype.suite_dom = function(suite) {
              var main, tests, title, _ref;
              suite._html = {
                main: document.createElement("div"),
                title: document.createElement("h3"),
                tests: document.createElement("ul")
              };
              _ref = suite._html, main = _ref.main, tests = _ref.tests, title = _ref.title;
              main.classList.add("testify_suite");
              title.textContent = suite.name;
              main.appendChild(title);
              main.appendChild(tests);
              return this.root.appendChild(main);
            };

            DOMReporter.prototype.test_dom = function(test) {
              var span, tests;
              test._html = {
                name: document.createElement("li")
              };
              test._html.name.classList.add("testify_test");
              span = document.createElement("span");
              span.classList.add("testify_test_name");
              span.textContent = test.name;
              test._html.name.appendChild(span);
              if (test.parent._html.tests) {

              } else {
                tests = test.parent._html.tests = document.createElement("ul");
                test.parent._html.name.appendChild(tests);
              }
              return test.parent._html.tests.appendChild(test._html.name);
            };

            DOMReporter.prototype.status = function(suite, test, type) {
              var fn,
              _this = this;
              fn = function() {
                var element, match, regex, span, stacky, where;
                element = test._html.name;
                span = element.children[0];
                span.classList.add(type);
                if (type === "failure" || type === "error") {
                  span.textContent = span.textContent + (" (" + (test.failed.toString()) + ")");
                  stacky = document.createElement("pre");
                  where = test.failed.stack.split("\n")[1];
                  regex = /\((.*)\)/;
                  match = regex.exec(where);
                  try {
                    stacky.textContent = match[1];
                  } catch (error) {
                    stacky.textContent = where.slice(7);
                  }
                  stacky.classList.add("stack");
                  return element.insertBefore(stacky, span.nextSibling);
                } else if (type === "incomplete") {
                  return span.textContent = span.textContent + " (incomplete)";
                }
              };
              return setTimeout(fn, 50);
            };

            DOMReporter.prototype.result = function(test, options) {
              var element, span, type_string;
              if (test.children.length > 0 || options.type === "incomplete") {
                element = test._html.name;
                if (options.type) {
                  span = element.children[0];
                  span.classList.add(options.type);
                  type_string = " (" + options.type + ")";
                  if (options.type === "failure") {
                    return span.textContent = span.textContent + (" (" + (test.failed.toString()) + ")");
                  } else if (options.type === "incomplete") {
                    return span.textContent = span.textContent + " (incomplete)";
                  }
                }
              }
            };

            return DOMReporter;

          })();

          module.exports = {
            ConsoleReporter: ConsoleReporter,
            DOMReporter: DOMReporter
          };

        },

        "62e49fef2333868ff4848cf4ec8f121d": // from: node_modules/testify/src/test.coffee
        function(exports, require, module, __filename, __dirname) {
          var Context, TestContext, colors,
          __hasProp = {}.hasOwnProperty,
            __extends = function(child, parent) {
              for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            },
            __slice = [].slice;

          colors = require("colors");

          Context = require("./context");

          module.exports = TestContext = (function(_super) {

            __extends(TestContext, _super);

            function TestContext() {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              TestContext.__super__.constructor.apply(this, args);
              this.failed = false;
            }

            TestContext.prototype.test = function(description, work) {
              return this.child(description, work);
            };

            TestContext.prototype.run = function() {
              TestContext.reporter.add_suite(this);
              return this._run();
            };

            TestContext.prototype._run = function() {
              var _this = this;
              this.fsm.emitter.once("COMPLETE", function() {
                if (_this.timeout_id) {
                  clearTimeout(_this.timeout_id);
                }
                return _this.timeout_id = void 0;
              });
              try {
                TestContext.__super__._run.call(this);
                if (this.type === "sync") {
                  return this.status("pass", ".");
                }
              } catch (error) {
                this.fail(error);
                return this.event("end_of_block");
              }
            };

            TestContext.prototype.status = function(type) {
              return this.emitter.emit("status", type);
            };

            TestContext.prototype.pass = function() {
              if (!this.failed) {
                this.status("pass");
                return this.done();
              }
            };

            TestContext.prototype.fail = function(error) {
              var message, throwaway;
              if (error.constructor === String) {
                this.status("failure");
                throwaway = new Error(error);
                message = error.toString();
                error = {
                  name: "AssertionError",
                  stack: throwaway.stack.split("\n").slice(1).join("\n"),
                  toString: function() {
                    return message;
                  }
                };
              } else if (error.name === "AssertionError") {
                this.status("failure");
              } else {
                this.status("error");
              }
              if (this.type === "async") {
                this.event("completion");
              }
              return this.propagate_failure(error);
            };

            TestContext.prototype.timeout = function(milliseconds, message) {
              var fn,
              _this = this;
              fn = function() {
                return _this.fail(message || ("Timed out after " + milliseconds + " milliseconds"));
              };
              return this.timeout_id = setTimeout(fn, milliseconds);
            };

            TestContext.prototype.propagate_failure = function(error) {
              var _ref;
              this.failed = error;
              return (_ref = this.parent) != null ? _ref.propagate_failure("subtest failures") : void 0;
            };

            return TestContext;

          })(Context);

        },

        "1acd0107c78da6657c2d635a044b63b7": // from: node_modules/testify/src/testify.coffee
        function(exports, require, module, __filename, __dirname) {
          var Context, EventEmitter, TestContext, TestOutput, Testify, colors,
          __slice = [].slice;

          colors = require("colors");

          EventEmitter = require("events").EventEmitter;

          Context = require("./context");

          TestOutput = (function() {

            function TestOutput() {
              console.log();
            }

            TestOutput.prototype.status = function(type, string) {
              return process.stdout.write(this.colorize(type, string));
            };

            TestOutput.prototype.result = function(string, options) {
              var level, match, regex, space, where;
              if (options == null) {
                options = {};
              }
              if (!this._receiving_results) {
                console.log();
                this._receiving_results = true;
              }
              if (options.type) {
                string = this.colorize(options.type, string);
              }
              if (level = options.level) {
                space = "";
                while (level--) {
                  space = space + "    ";
                }
                string = space + string;
              }
              console.log(string);
              if (options.stack) {
                where = options.stack.split("\n")[1];
                regex = /\((.*)\)/;
                match = regex.exec(where);
                try {
                  return console.log(space + match[1]);
                } catch (error) {
                  return console.log(space + where.slice(7));
                }
              }
            };

            TestOutput.prototype.colorize = function(type, string) {
              var color;
              if (Testify.options.color && (color = this.color_map[type])) {
                return string[color];
              } else {
                return string;
              }
            };

            TestOutput.prototype.color_map = {
              pass: "green",
              incomplete: "magenta",
              failure: "red",
              error: "yellow"
            };

            return TestOutput;

          })();

          TestContext = require("./test");

          Testify = {
            ConsoleReporter: require("./reporters").ConsoleReporter,
            DOMReporter: require("./reporters").DOMReporter,
            TestContext: TestContext,
            count: 0,
            emitter: new EventEmitter(),
            once: function() {
              var args, _ref;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              return (_ref = Testify.emitter).once.apply(_ref, args);
            },
            options: {
              color: true
            },
            test: function(name, fn) {
              var suite;
              TestContext.options = Testify.options;
              TestContext.reporter = Testify.reporter || new Testify.ConsoleReporter();
              suite = new TestContext(name, fn);
              Testify.count++;
              suite.emitter.once("COMPLETE", function() {
                Testify.count--;
                if (Testify.count === 0) {
                  return Testify.emitter.emit("done");
                }
              });
              return suite.run();
            },
            benchmark: function(name, fn) {
              var Benchmark;
              Benchmark = require("./benchmark");
              return new Benchmark(name, fn);
            }
          };

          module.exports = Testify;

        },

        "d5618ac652297a3b9b8a6b6a4104f37b": // from: node_modules/testify/statistics.js
        function(exports, require, module, __filename, __dirname) {
          /****************************************************************************************************
JavaScript Math and Statistics Library

@file		pseudoMathStats.js
@version	1.0
@author 	Paul Ellis
@url        http://code.google.com/p/pseudosavant
@copyright 	Copyright 2010, Paul Ellis
@license    BSD
****************************************************************************************************/


          /****************************************************************************************************
Calculates the Standard Deviation of an array
****************************************************************************************************/
          Array.prototype.stdDev = function() {
            // Calculate Mean
            var mean = this.mean();

            var length = this.length;

            // Calculate Variance
            for (var i = 0, sumOfSquares = 0; i < length; i++) {
              sumOfSquares += Math.pow(this[i] - mean, 2);
            }
            var stdDev = Math.sqrt(sumOfSquares / length);

            return stdDev;
          }


          /****************************************************************************************************
Calculates the Variance of an array
****************************************************************************************************/
          Array.prototype.variance = function() {
            // Calculate Mean
            var mean = this.mean();

            var length = this.length;

            // Calculate Variance
            for (var i = 0, sumOfSquares = 0; i < length; i++) {
              sumOfSquares += Math.pow(this[i] - mean, 2);
            }
            var variance = sumOfSquares / length;

            return variance;
          }


          /****************************************************************************************************
Sums all values in an array
****************************************************************************************************/
          Array.prototype.sum = function() {
            for (var i = 0, length = this.length, sum = 0; i < length; sum += this[i++]);
            return sum;
          }


          /****************************************************************************************************
Calculates the arithmetic mean of an array
****************************************************************************************************/
          Array.prototype.mean = function() {
            for (var i = 0, length = this.length, sum = 0; i < length; sum += this[i++]);
            var mean = sum / length;
            return mean;
          }


          /****************************************************************************************************
Returns the highest numeric value of an array
****************************************************************************************************/
          Array.prototype.max = function() {
            return this.reduceRight(function(i, j) {
              if (j < i) {
                return i
              } else {
                return j
              }
            });
          }


          /****************************************************************************************************
Returns the lowest numeric value of an array
****************************************************************************************************/
          Array.prototype.min = function() {
            return this.reduceRight(function(i, j) {
              if (j > i) {
                return i
              } else {
                return j
              }
            });
          }


          /****************************************************************************************************
Calculates the median of an array
****************************************************************************************************/
          Array.prototype.median = function() {
            var length = this.length;

            if (length % 2 == 1) // Odd
            {
              var middle = Math.floor(length / 2);
              var median = this.sortNumber()[middle];
            } else // Even
            {
              var middle = length / 2;
              var sorted = this.sortNumber();
              var median = (sorted[middle - 1] + sorted[middle]) / 2;
            }
            return median;
          }


          /****************************************************************************************************
Returns the array sorted ascendingly, or decendingly if sortNumber(true).
****************************************************************************************************/
          Array.prototype.sortNumber = function(invert) {
            if (invert == true) // Decending
            {
              return this.slice().sort(function(a, b) {
                return a - b
              }).reverse(); // Using reverse() is faster than b - a.
            } else // Ascending, default
            {
              return this.slice().sort(function(a, b) {
                return a - b
              });
            }
          }


          /****************************************************************************************************
Returns an object containing the most common stats for the array.
****************************************************************************************************/
          Array.prototype.summarize = function summarize(places) {
            if (!this.length) {
              return {
                error: "no values"
              };
            }
            return {
              sample_size: this.length,
              mean: fixedDecimal(this.mean(), places),
              max: fixedDecimal(this.max(), places),
              median: fixedDecimal(this.median(), places),
              min: fixedDecimal(this.min(), places),
              stdDev: fixedDecimal(this.stdDev(), places),
            };
          };


          var fixedDecimal = function fixedDecimal(num, numOfDec) {
            var pow10s = Math.pow(10, numOfDec || 0);
            return (numOfDec) ? Math.round(pow10s * num) / pow10s : num;
          };


          /****************************************************************************************************
Lower tail quantile for standard normal distribution function.

Written by Alankar Misra (alankar@digitalsutras.com)
Algorithm by Peter John Acklam (pjacklam@online.no, http://home.online.no/~pjacklam)
****************************************************************************************************/
          function normsinv(p) {
            // Coefficients in rational approximations
            var a = new Array(-3.969683028665376e+01, 2.209460984245205e+02, - 2.759285104469687e+02, 1.383577518672690e+02, - 3.066479806614716e+01, 2.506628277459239e+00);

            var b = new Array(-5.447609879822406e+01, 1.615858368580409e+02, - 1.556989798598866e+02, 6.680131188771972e+01, - 1.328068155288572e+01);

            var c = new Array(-7.784894002430293e-03, - 3.223964580411365e-01, - 2.400758277161838e+00, - 2.549732539343734e+00,
            4.374664141464968e+00, 2.938163982698783e+00);

            var d = new Array(7.784695709041462e-03, 3.224671290700398e-01,
            2.445134137142996e+00, 3.754408661907416e+00);

            // Define break-points.
            var plow = 0.02425;
            var phigh = 1 - plow;

            // Rational approximation for lower region:
            if (p < plow) {
              var q = Math.sqrt(-2 * Math.log(p));
              return (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) / ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            }

            // Rational approximation for upper region:
            if (phigh < p) {
              var q = Math.sqrt(-2 * Math.log(1 - p));
              return -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) / ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            }

            // Rational approximation for central region:
            var q = p - 0.5;
            var r = q * q;
            return (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q / (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
          }





        },

        "472824fe00f2d2075a0fbd3267b79538": // from: src/shred.coffee
        function(exports, require, module, __filename, __dirname) {
          var Ax, CookieJar, Request, Shred,
          __hasProp = {}.hasOwnProperty;

          Ax = require("ax");

          CookieJar = require("cookiejar").CookieJar;

          Request = require("./shred/request");

          module.exports = Shred = (function() {

            function Shred(options) {
              if (options == null) {
                options = {};
              }
              this.agent = options.agent;
              this.defaults = options.defaults || {};
              this.log = options.logger || (new Ax({
                level: "info"
              }));
              if (options.cookies !== false) {
                this._sharedCookieJar = new CookieJar();
              }
              this.logCurl = options.logCurl || false;
            }

            Shred.prototype.request = function(options) {
              var key, value, _ref;
              options.logger || (options.logger = this.log);
              options.logCurl || (options.logCurl = this.logCurl);
              options.cookieJar = ("cookieJar" in options ? options.cookieJar : this._sharedCookieJar);
              options.agent || (options.agent = this.agent);
              _ref = this.defaults;
              for (key in _ref) {
                if (!__hasProp.call(_ref, key)) continue;
                value = _ref[key];
                options[key] || (options[key] = value);
              }
              return new Request(options);
            };

            return Shred;

          })();

          "get put post delete".split(" ").forEach(function(method) {
            return Shred.prototype[method] = function(options) {
              options.method = method;
              return this.request(options);
            };
          });

          Shred.registerProcessor = require("./shred/content").registerProcessor;

        },

        "de6f3ec27408aa6c2dbef934db6778ac": // from: src/shred/content.coffee
        function(exports, require, module, __filename, __dirname) {
          var Content, querystring;

          querystring = require("querystring");

          module.exports = Content = (function() {

            Content.processors = {};

            Content.registerProcessor = function(types, processor) {
              if (types.forEach) {
                return types.forEach(function(type) {
                  return Content.processors[type] = processor;
                });
              } else {
                return Content.processors[types] = processor;
              }
            };

            function Content(options) {
              this.body = options.body;
              this.data = options.data;
              this._type = options.type;
            }

            return Content;

          })();

          Object.defineProperties(Content.prototype, {
            type: {
              get: function() {
                var t;
                if (this._type) {
                  return this._type;
                } else if (this._data) {
                  t = typeof this._data;
                  if (t === "string") {
                    return "text/plain";
                  } else if (t === "object") {
                    return "application/json";
                  }
                } else {
                  return "text/plain";
                }
              },
              enumerable: true
            },
            data: {
              get: function() {
                if (this._body) {
                  return this.processor.parser(this._body);
                } else {
                  return this._data;
                }
              },
              set: function(data) {
                if (this._body && data) {
                  throw new Error("Attempt to set data attribute of a content object " + "when the body attributes was already set.");
                }
                return this._data = data;
              },
              enumerable: true
            },
            body: {
              get: function() {
                if (this._data) {
                  return this.processor.stringify(this._data);
                } else {
                  return this._body.toString();
                }
              },
              set: function(body) {
                if (this._data && body) {
                  throw new Error("Attempt to set body attribute of a content object " + "when the data attributes was already set.");
                }
                this._body = body;
                return this;
              },
              enumerable: true
            },
            processor: {
              get: function() {
                var i, l, main, parts, processor;
                processor = Content.processors[this.type];
                if (processor) {
                  return processor;
                } else {
                  main = this.type.split(";")[0];
                  parts = main.split(/\+|\//);
                  i = 0;
                  l = parts.length;
                  while (i < l) {
                    processor = Content.processors[parts[i]];
                    i++;
                  }
                  return processor || Content.processors["default"];
                }
              },
              enumerable: true
            },
            length: {
              get: function() {
                if (typeof Buffer !== "undefined") {
                  return Buffer.byteLength(this.body);
                }
                return this.body.length;
              }
            }
          });

          Content.registerProcessor("default", {
            parser: function(x) {
              return x;
            },
            stringify: function(x) {
              return x.toString();
            }
          });

          Content.registerProcessor(["text/html", "text/plain", "text"], {
            parser: function(x) {
              return x;
            },
            stringify: function(x) {
              return x.toString();
            }
          });

          Content.registerProcessor(["application/json; charset=utf-8", "application/json", "json"], {
            parser: function(string) {
              return JSON.parse(string);
            },
            stringify: function(data) {
              return JSON.stringify(data);
            }
          });

          Content.registerProcessor(["application/x-www-form-urlencoded"], {
            parser: querystring.parse,
            stringify: querystring.stringify
          });

        },

        "e938fbd381641c5df05e3419364a31b8": // from: src/shred/mixins/headers.coffee
        function(exports, require, module, __filename, __dirname) {
          var $H, corsetCase, getHeader, getHeaders, initializeHeaders, setHeader, setHeaders,
          __slice = [].slice;

          corsetCase = function(string) {
            return string.toLowerCase().replace("_", "-").replace(/(^|-)(\w)/g, function(s) {
              return s.toUpperCase();
            });
          };

          initializeHeaders = function(object) {
            return {};
          };

          $H = function(object) {
            return object._headers || (object._headers = initializeHeaders(object));
          };

          getHeader = function(object, name) {
            return $H(object)[corsetCase(name)];
          };

          getHeaders = function(object, names) {
            var hash, i, key, keys, l;
            keys = (names && names.length > 0 ? names : Object.keys($H(object)));
            hash = {};
            i = 0;
            l = keys.length;
            while (i < l) {
              key = keys[i];
              hash[key] = getHeader(object, key);
              i++;
            }
            Object.freeze(hash);
            return hash;
          };

          setHeader = function(object, name, value) {
            $H(object)[corsetCase(name)] = value;
            return object;
          };

          setHeaders = function(object, hash) {
            var key;
            for (key in hash) {
              setHeader(object, key, hash[key]);
            }
            return this;
          };

          module.exports = {
            getters: function(constructor) {
              constructor.prototype.getHeader = function(name) {
                return getHeader(this, name);
              };
              return constructor.prototype.getHeaders = function() {
                var args;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return getHeaders(this, args);
              };
            },
            privateSetters: function(constructor) {
              constructor.prototype._setHeader = function(key, value) {
                return setHeader(this, key, value);
              };
              return constructor.prototype._setHeaders = function(hash) {
                return setHeaders(this, hash);
              };
            },
            setters: function(constructor) {
              constructor.prototype.setHeader = function(key, value) {
                return setHeader(this, key, value);
              };
              return constructor.prototype.setHeaders = function(hash) {
                return setHeaders(this, hash);
              };
            },
            gettersAndSetters: function(constructor) {
              constructor.prototype.getHeader = function(name) {
                return getHeader(this, name);
              };
              constructor.prototype.getHeaders = function() {
                var args;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return getHeaders(this, args);
              };
              constructor.prototype.setHeader = function(key, value) {
                return setHeader(this, key, value);
              };
              return constructor.prototype.setHeaders = function(hash) {
                return setHeaders(this, hash);
              };
            }
          };

        },

        "e8b753db709b5ef4915068e0925367dc": // from: src/shred/parseUri.coffee
        function(exports, require, module, __filename, __dirname) {
          var parseUri;

          parseUri = function(str) {
            var i, m, o, uri;
            o = parseUri.options;
            m = o.parser[(o.strictMode ? "strict" : "loose")].exec(str);
            uri = {};
            i = 14;
            while (i--) {
              uri[o.key[i]] = m[i] || "";
            }
            uri[o.q.name] = {};
            uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
              if ($1) {
                return uri[o.q.name][$1] = $2;
              }
            });
            return uri;
          };

          parseUri.options = {
            strictMode: false,
            key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
            q: {
              name: "queryKey",
              parser: /(?:^|&)([^&=]*)=?([^&]*)/g
            },
            parser: {
              strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
              loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
            }
          };

          module.exports = parseUri;

        },

        "43dfb23f47862a3f4f5b2ac8879a2729": // from: src/shred/request.coffee
        function(exports, require, module, __filename, __dirname) {
          var Content, Emitter, HTTP, HTTPS, HeaderMixins, Request, Response, STATUS_CODES, createRequest, logCurl, parseUri, processOptions, sprintf;

          HTTP = require("http");

          HTTPS = require("https");

          parseUri = require("./parseUri");

          Emitter = require("events").EventEmitter;

          sprintf = require("sprintf").sprintf;

          Response = require("./response");

          HeaderMixins = require("./mixins/headers");

          Content = require("./content");

          STATUS_CODES = HTTP.STATUS_CODES || {
            100: "Continue"
          };

          ({
            101: "Switching Protocols",
            102: "Processing",
            200: "OK",
            201: "Created",
            202: "Accepted",
            203: "Non-Authoritative Information",
            204: "No Content",
            205: "Reset Content",
            206: "Partial Content",
            207: "Multi-Status",
            300: "Multiple Choices",
            301: "Moved Permanently",
            302: "Moved Temporarily",
            303: "See Other",
            304: "Not Modified",
            305: "Use Proxy",
            307: "Temporary Redirect",
            400: "Bad Request",
            401: "Unauthorized",
            402: "Payment Required",
            403: "Forbidden",
            404: "Not Found",
            405: "Method Not Allowed",
            406: "Not Acceptable",
            407: "Proxy Authentication Required",
            408: "Request Time-out",
            409: "Conflict",
            410: "Gone",
            411: "Length Required",
            412: "Precondition Failed",
            413: "Request Entity Too Large",
            414: "Request-URI Too Large",
            415: "Unsupported Media Type",
            416: "Requested Range Not Satisfiable",
            417: "Expectation Failed",
            418: "I'm a teapot",
            422: "Unprocessable Entity",
            423: "Locked",
            424: "Failed Dependency",
            425: "Unordered Collection",
            426: "Upgrade Required",
            500: "Internal Server Error",
            501: "Not Implemented",
            502: "Bad Gateway",
            503: "Service Unavailable",
            504: "Gateway Time-out",
            505: "HTTP Version not supported",
            506: "Variant Also Negotiates",
            507: "Insufficient Storage",
            509: "Bandwidth Limit Exceeded",
            510: "Not Extended"
          });

          Request = function(options) {
            this.log = options.logger;
            this.cookieJar = options.cookieJar;
            this.encoding = options.encoding;
            this.logCurl = options.logCurl;
            processOptions(this, options || {});
            return createRequest(this);
          };

          Object.defineProperties(Request.prototype, {
            url: {
              get: function() {
                if (!this.scheme) {
                  return null;
                }
                return sprintf("%s://%s:%s%s", this.scheme, this.host, this.port, (this.proxy ? "/" : this.path) + (this.query ? "?" + this.query : ""));
              },
              set: function(_url) {
                _url = parseUri(_url);
                this.scheme = _url.protocol;
                this.host = _url.host;
                this.port = _url.port;
                this.path = _url.path;
                this.query = _url.query;
                return this;
              },
              enumerable: true
            },
            headers: {
              get: function() {
                return this.getHeaders();
              },
              enumerable: true
            },
            port: {
              get: function() {
                if (!this._port) {
                  switch (this.scheme) {
                  case "https":
                    return this._port = 443;
                  case "http":
                    break;
                  default:
                    return this._port = 80;
                  }
                }
                return this._port;
              },
              set: function(value) {
                this._port = value;
                return this;
              },
              enumerable: true
            },
            method: {
              get: function() {
                return this._method = this._method || "GET";
              },
              set: function(value) {
                this._method = value;
                return this;
              },
              enumerable: true
            },
            query: {
              get: function() {
                return this._query;
              },
              set: function(value) {
                var stringify;
                stringify = function(hash) {
                  var key, query;
                  query = "";
                  for (key in hash) {
                    query += encodeURIComponent(key) + "=" + encodeURIComponent(hash[key]) + "&";
                  }
                  query = query.slice(0, - 1);
                  return query;
                };
                if (value) {
                  if (typeof value === "object") {
                    value = stringify(value);
                  }
                  this._query = value;
                } else {
                  this._query = "";
                }
                return this;
              },
              enumerable: true
            },
            parameters: {
              get: function() {
                return QueryString.parse(this._query || "");
              },
              enumerable: true
            },
            body: {
              get: function() {
                return this._body;
              },
              set: function(value) {
                this._body = new Content({
                  data: value,
                  type: this.getHeader("Content-Type")
                });
                this.setHeader("Content-Type", this.content.type);
                this.setHeader("Content-Length", this.content.length);
                return this;
              },
              enumerable: true
            },
            timeout: {
              get: function() {
                return this._timeout;
              },
              set: function(timeout) {
                var milliseconds, request;
                request = this;
                milliseconds = 0;
                if (!timeout) {
                  return this;
                }
                if (typeof timeout === "number") {
                  milliseconds = timeout;
                } else {
                  milliseconds = (timeout.milliseconds || 0) + (1000 * ((timeout.seconds || 0) + (60 * ((timeout.minutes || 0) + (60 * (timeout.hours || 0))))));
                }
                this._timeout = milliseconds;
                return this;
              },
              enumerable: true
            }
          });

          Object.defineProperty(Request.prototype, "content", Object.getOwnPropertyDescriptor(Request.prototype, "body"));

          Request.prototype.inspect = function() {
            var headers, request, summary;
            request = this;
            headers = this.format_headers();
            summary = ["<Shred Request> ", request.method.toUpperCase(), request.url].join(" ");
            return [summary, "- Headers:", headers].join("\n");
          };

          Request.prototype.format_headers = function() {
            var array, headers, key, value;
            array = [];
            headers = this._headers;
            for (key in headers) {
              if (headers.hasOwnProperty(key)) {
                value = headers[key];
                array.push("\t" + key + ": " + value);
              }
            }
            return array.join("\n");
          };

          Request.prototype.on = function(eventOrHash, listener) {
            var emitter, key;
            emitter = this.emitter;
            if (arguments_.length === 1 && typeof eventOrHash === "function") {
              emitter.on("response", eventOrHash);
            } else if (arguments_.length === 1 && typeof eventOrHash === "object") {
              for (key in eventOrHash) {
                if (eventOrHash.hasOwnProperty(key)) {
                  emitter.on(key, eventOrHash[key]);
                }
              }
            } else {
              emitter.on(eventOrHash, listener);
            }
            return this;
          };

          HeaderMixins.gettersAndSetters(Request);

          processOptions = function(request, options) {
            var cookieIndex, cookieString, cookies, key;
            request.log.debug("Processing request options ..");
            request.emitter = new Emitter;
            request.agent = options.agent;
            if (options.on) {
              for (key in options.on) {
                if (options.on.hasOwnProperty(key)) {
                  request.emitter.on(key, options.on[key]);
                }
              }
            }
            if (!options.url && !options.host) {
              request.emitter.emit("request_error", new Error("No url or url options (host, port, etc.)"));
              return;
            }
            if (options.url) {
              if (options.proxy) {
                request.url = options.proxy;
                request.path = options.url;
              } else {
                request.url = options.url;
              }
            }
            request.query = options.query || options.parameters || request.query;
            request.method = options.method;
            request.setHeader("user-agent", options.agent || "Shred");
            request.setHeaders(options.headers);
            if (request.cookieJar) {
              cookies = request.cookieJar.getCookies(CookieAccessInfo(request.host, request.path));
              if (cookies.length) {
                cookieString = request.getHeader("cookie") || "";
                cookieIndex = 0;
                while (cookieIndex < cookies.length) {
                  if (cookieString.length && cookieString[cookieString.length - 1] !== ";") {
                    cookieString += ";";
                  }
                  cookieString += cookies[cookieIndex].name + "=" + cookies[cookieIndex].value + ";";
                  ++cookieIndex;
                }
                request.setHeader("cookie", cookieString);
              }
            }
            if (options.body || options.content) {
              request.content = options.body || options.content;
            }
            return request.timeout = options.timeout;
          };

          createRequest = function(request) {
            var http, reqParams, timeoutId;
            timeoutId = void 0;
            request.log.debug("Creating request ..");
            request.log.debug(request);
            reqParams = {
              host: request.host,
              port: request.port,
              method: request.method,
              path: request.path + (request.query ? "?" + request.query : ""),
              headers: request.getHeaders(),
              scheme: request.scheme,
              agent: request.agent
            };
            if (request.logCurl) {
              logCurl(request);
            }
            http = (request.scheme === "http" ? HTTP : HTTPS);
            request._raw = http.request(reqParams, function(response) {
              request.emitter.emit("cleanup");
              request.log.debug("Received response ..");
              clearTimeout(timeoutId);
              return response = new Response(response, request, function(response) {
                var emit;
                emit = function(event) {
                  var emitter, textStatus;
                  emitter = request.emitter;
                  textStatus = (STATUS_CODES[response.status] ? STATUS_CODES[response.status].toLowerCase() : null);
                  if (emitter.listeners(response.status).length > 0 || emitter.listeners(textStatus).length > 0) {
                    emitter.emit(response.status, response);
                    return emitter.emit(textStatus, response);
                  } else {
                    if (emitter.listeners(event).length > 0) {
                      return emitter.emit(event, response);
                    } else {
                      if (!response.isRedirect) {
                        return emitter.emit("response", response);
                      }
                    }
                  }
                };
                if (response.isRedirect) {
                  request.log.debug("Redirecting to " + response.getHeader("Location"));
                  request.url = response.getHeader("Location");
                  emit("redirect");
                  return createRequest(request);
                } else if (response.isError) {
                  return emit("error");
                } else {
                  return emit("success");
                }
              });
            });
            request._raw.setMaxListeners(30);
            request._raw.on("error", function(error) {
              if (!timeoutId) {
                request.emitter.emit("request_error", error);
              }
              return request.emitter.emit("cleanup", error);
            });
            request._raw.on("socket", function(socket) {
              return request.emitter.emit("socket", socket);
            });
            request._raw.on("socket", function() {
              var timeout_handler;
              timeout_handler = function() {
                return request._raw.abort();
              };
              request.emitter.once("cleanup", function() {
                return request._raw.socket.removeListener("timeout", timeout_handler);
              });
              return request._raw.socket.on("timeout", timeout_handler);
            });
            if (request.content) {
              request.log.debug("Streaming body: '" + request.content.body.slice(0, 59) + "' ... ");
              request._raw.write(request.content.body);
            }
            if (request.timeout) {
              timeoutId = setTimeout(function() {
                request.log.debug("Timeout fired, aborting request ...");
                request.emitter.emit("timeout", request);
                return request._raw.abort();
              }, request.timeout);
            }
            request.log.debug("Sending request ...");
            return request._raw.end();
          };

          logCurl = function(req) {
            var bodyString, headerString, headers, key, query;
            headers = req.getHeaders();
            headerString = "";
            for (key in headers) {
              headerString += "-H \"" + key + ": " + headers[key] + "\" ";
            }
            bodyString = "";
            if (req.content) {
              bodyString += "-d '" + req.content.body + "' ";
            }
            query = (req.query ? "?" + req.query : "");
            return console.log("curl " + "-X " + req.method.toUpperCase() + " " + req.scheme + "://" + req.host + ":" + req.port + req.path + query + " " + headerString + bodyString);
          };

          module.exports = Request;

        },

        "b025a4ec5f8e8625d8be4f61ef482b60": // from: src/shred/response.coffee
        function(exports, require, module, __filename, __dirname) {
          var Content, Cookie, CookieJarLib, HeaderMixins, Iconv, Response, getHeader, zlib;

          Content = require("./content");

          HeaderMixins = require("./mixins/headers");

          CookieJarLib = require("cookiejar");

          Cookie = CookieJarLib.Cookie;

          zlib = null;

          try {
            zlib = require("zlib");
          } catch (e) {
            console.warn("no zlib library");
          }

          Iconv = null;

          try {
            Iconv = require("iconv-lite");
          } catch (e) {
            console.warn("no iconv library");
          }

          Response = function(raw, request, callback) {
            var chunks, cookie, cookieObjs, cookieString, cookieStrings, dataLength, i, response;
            response = this;
            this._raw = raw;
            this._setHeaders.call(this, raw.headers);
            if (request.cookieJar && this.getHeader("set-cookie")) {
              cookieStrings = this.getHeader("set-cookie");
              cookieObjs = [];
              cookie = void 0;
              i = 0;
              while (i < cookieStrings.length) {
                cookieString = cookieStrings[i];
                if (!cookieString) {
                  continue;
                }
                if (!cookieString.match(/domain\=/i)) {
                  cookieString += "; domain=" + request.host;
                }
                if (!cookieString.match(/path\=/i)) {
                  cookieString += "; path=" + request.path;
                }
                try {
                  cookie = new Cookie(cookieString);
                  if (cookie) {
                    cookieObjs.push(cookie);
                  }
                } catch (e) {
                  console.warn("Tried to set bad cookie: " + cookieString);
                }
                i++;
              }
              request.cookieJar.setCookies(cookieObjs);
            }
            this.request = request;
            this.client = request.client;
            this.log = this.request.log;
            chunks = [];
            dataLength = 0;
            raw.on("data", function(chunk) {
              chunks.push(chunk);
              return dataLength += chunk.length;
            });
            return raw.on("end", function() {
              var body, setBodyAndFinish;
              body = chunks.join("");
              setBodyAndFinish = function(body) {
                response._body = new Content({
                  body: body,
                  type: response.getHeader("Content-Type")
                });
                return callback(response);
              };
              if (zlib && response.getHeader("Content-Encoding") === "gzip") {
                return zlib.gunzip(body, function(err, gunzippedBody) {
                  if (Iconv && response.request.encoding) {
                    body = Iconv.fromEncoding(gunzippedBody, response.request.encoding);
                  } else {
                    body = gunzippedBody.toString();
                  }
                  return setBodyAndFinish(body);
                });
              } else {
                if (response.request.encoding) {
                  body = Iconv.fromEncoding(body, response.request.encoding);
                }
                return setBodyAndFinish(body);
              }
            });
          };

          Response.prototype = {
            inspect: function() {
              var headers, response, summary;
              response = this;
              headers = this.format_headers();
              summary = ["<Shred Response> ", response.status].join(" ");
              return [summary, "- Headers:", headers].join("\n");
            },
            format_headers: function() {
              var array, headers, key, value;
              array = [];
              headers = this.headers;
              for (key in headers) {
                if (headers.hasOwnProperty(key)) {
                  value = headers[key];
                  array.push("\t" + key + ": " + value);
                }
              }
              return array.join("\n");
            }
          };

          Object.defineProperties(Response.prototype, {
            status: {
              get: function() {
                return this._raw.statusCode;
              },
              enumerable: true
            },
            body: {
              get: function() {
                return this._body;
              }
            },
            content: {
              get: function() {
                return this.body;
              },
              enumerable: true
            },
            headers: {
              get: function() {
                return this._headers;
              },
              enumerable: true
            },
            isRedirect: {
              get: function() {
                return this.status > 299 && this.status < 400 && this.getHeader("Location");
              },
              enumerable: true
            },
            isError: {
              get: function() {
                return this.status === 0 || this.status > 399;
              },
              enumerable: true
            }
          });

          HeaderMixins.getters(Response);

          HeaderMixins.privateSetters(Response);

          getHeader = Response.prototype.getHeader;

          Response.prototype.getHeader = function(name) {
            return getHeader.call(this, name) || (typeof this._raw.getHeader === "function" && this._raw.getHeader(name));
          };

          module.exports = Response;

        },

        "aa29b8a06095dd170e247794b8ea185c": // from: test/browser/application.coffee
        function(exports, require, module, __filename, __dirname) {
          var Testify, assert, saneTimeout;

          Testify = require("testify");

          window.Buffer = require("buffer-browserify").Buffer;

          assert = require("assert");

          saneTimeout = function(ms, fn) {
            return setTimeout(fn, ms);
          };

          Testify.reporter = new Testify.DOMReporter("testify", 2000);

          require("../shred_test");

        },

        "7c6f94265ce22f5ba1d0be971c82b6a2": // from: test/content_test.coffee
        function(exports, require, module, __filename, __dirname) {
          var Content, Testify, assert;

          Testify = require("testify");

          assert = require("assert");

          Content = require("../src/shred/content");

          Testify.test("Content constructor", function(context) {
            context.test("An instance constructed with body but no type", function(context) {
              var content;
              content = new Content({
                body: "Hello"
              });
              context.test("has default type of test/plain", function() {
                return assert.equal(content.type, "text/plain");
              });
              context.test("has a data property equal to the body", function() {
                return assert.equal(content.data, content._body);
              });
              return context.test("has a length property equal to body's length", function() {
                return assert.equal(content.length, content._body.length);
              });
            });
            context.test("An instance constructed with body and type 'text/html'", function(context) {
              var content;
              content = new Content({
                type: "text/html",
                body: "Hello"
              });
              context.test("has the correct type", function() {
                return assert.equal(content.type, "text/html");
              });
              context.test("has a data property equal to the body", function() {
                return assert.equal(content.data, content.body);
              });
              return context.test("has a length property equal to body's length", function() {
                return assert.equal(content.length, content.body.length);
              });
            });
            context.test("An instance constructed with an Object and no type", function(context) {
              var content;
              content = new Content({
                data: {
                  foo: "Hello"
                }
              });
              context.test("has a type of application/json", function() {
                return assert.equal(content.type, "application/json");
              });
              context.test("has a body equal to the JSON form of the data", function() {
                assert.equal(content.body.constructor, String);
                return assert.equal(content.body, JSON.stringify(content.data));
              });
              return context.test("has a length property equal to body's length", function() {
                return assert.equal(content.length, content.body.length);
              });
            });
            context.test("An instance constructed with an Object and type application/json", function(context) {
              var content;
              content = new Content({
                type: "application/json",
                data: {
                  foo: "Hello"
                }
              });
              context.test("has a body equal to the JSON form of the data", function() {
                assert.equal(content.body.constructor, String);
                return assert.equal(content.body, JSON.stringify(content.data));
              });
              return context.test("has a length property equal to body's length", function() {
                return assert.equal(content.length, content.body.length);
              });
            });
            context.test("An instance constructed with composite media-type", function(context) {
              var content;
              content = new Content({
                type: "application/vnd.foo.bar+json;version=1.1",
                data: {
                  foo: "Hello"
                }
              });
              context.test("has a String body", function() {
                return assert.equal(content.body.constructor, String);
              });
              context.test("has a body equal to the JSON form of the data", function() {
                return assert.equal(content.body, JSON.stringify(content.data));
              });
              return context.test("has a length property equal to body's length", function() {
                return assert.equal(content.length, content.body.length);
              });
            });
            return context.test("An instance constructed with an unknown type", function(context) {
              var content;
              content = new Content({
                type: "application/monkeys",
                data: {
                  foo: "Hello"
                }
              });
              return context.test("identity processor", function() {
                return assert.equal(content.body, "[object Object]");
              });
            });
          });

        },

        "70163b46f8555ff67c92083cf367db04": // from: test/headers_test.coffee
        function(exports, require, module, __filename, __dirname) {
          var HeaderUser, Headers, Testify, assert;

          Testify = require("testify");

          assert = require("assert");

          Headers = require("../src/shred/mixins/headers");

          HeaderUser = (function() {

            function HeaderUser() {}

            return HeaderUser;

          })();

          Headers.gettersAndSetters(HeaderUser);

          Testify.test("Headers mixin", function(context) {
            context.test("setHeader and getHeader", function(context) {
              context.test("setHeader and getHeader with correctly cased names", function() {
                var object;
                object = new HeaderUser();
                object.setHeader("Content-Type", "text/html");
                return assert.equal(object.getHeader("Content-Type"), "text/html");
              });
              context.test("setHeader with downcased name, getHeader with correct name", function() {
                var object;
                object = new HeaderUser();
                object.setHeader("content-type", "text/html");
                return assert.equal(object.getHeader("Content-Type"), "text/html");
              });
              return context.test("setHeader with correct name, getHeader with downcased name", function() {
                var object;
                object = new HeaderUser();
                object.setHeader("Content-Type", "text/html");
                return assert.equal(object.getHeader("content-type"), "text/html");
              });
            });
            return context.test("setHeaders and getHeaders", function(context) {
              context.test("Setting multiple headers", function() {
                var object;
                object = new HeaderUser();
                object.setHeaders({
                  "Content-Type": "text/html",
                  "Accept": "text/html",
                  "Host": "foobar.com"
                });
                assert.equal(object.getHeader("Host"), "foobar.com");
                assert.equal(object.getHeader("Accept"), "text/html");
                return assert.equal(object.getHeader("Content-Type"), "text/html");
              });
              return context.test("Getting multiple headers", function() {
                var object;
                object = new HeaderUser();
                object.setHeaders({
                  "Content-Type": "text/html",
                  "Accept": "text/html",
                  "Host": "foobar.com"
                });
                return assert.deepEqual(object.getHeaders("Host", "Accept", "Content-Type"), {
                  "Content-Type": "text/html",
                  "Accept": "text/html",
                  "Host": "foobar.com"
                });
              });
            });
          });

        },

        "e7b0a85973e60e50391916726b0eac62": // from: test/shred_test.coffee
        function(exports, require, module, __filename, __dirname) {
          var Shred, Testify, assert, http_error_handler, request_error_handler, shred;

          Shred = require("../src/shred");

          Testify = require("testify");

          assert = require("assert");

          shred = new Shred({
            cookies: false
          });

          request_error_handler = function(error) {
            throw new Error("Request error. Is Rephraser running?");
          };

          http_error_handler = function(context) {
            return function(response) {
              return context.fail("Unexpected HTTP error: " + response.status);
            };
          };

          Testify.test("Shred", function(context) {
            context.test("A minimal valid GET", function(context) {
              return shred.get({
                url: "http://localhost:31337/200",
                on: {
                  request_error: request_error_handler,
                  error: http_error_handler(context),
                  response: function(response) {
                    context.test("response status is 200", function() {
                      return assert.equal(response.status, 200);
                    });
                    context.test("request (as represented in response data) does not have a content-type header", function() {
                      return assert.ok(!response.content.data.headers["Content-Type"]);
                    });
                    context.test("response.content.body is a String", function() {
                      return assert.equal(response.content.body.constructor, String);
                    });
                    context.test("response.content.body.length is correct", function() {
                      console.log(response.headers);
                      return assert.equal(response.headers["Content-Length"], response.content.body.length);
                    });
                    context.test("response.content.length is correct", function() {
                      return assert.equal(response.headers["Content-Length"], response.content.length);
                    });
                    return context.test("response.content._body is a String", function() {
                      return assert.equal(response.content._body.constructor, String);
                    });
                  }
                }
              });
            });
            return;
            context.test("A minimal valid POST request", function(context) {
              return shred.post({
                url: "http://localhost:31337/200",
                on: {
                  request_error: request_error_handler,
                  error: http_error_handler(context),
                  response: function(response) {
                    context.test("response status is 200", function() {
                      return assert.equal(response.status, 200);
                    });
                    return context.test("response does not have a content-type header", function() {
                      return assert.ok(!response.content.data.headers["Content-Type"]);
                    });
                  }
                }
              });
            });
            context.test("A POST request with a body", function(context) {
              return shred.post({
                url: "http://localhost:31337/200",
                body: "Hello",
                on: {
                  request_error: request_error_handler,
                  error: http_error_handler(context),
                  response: function(response) {
                    context.test("response status is 200", function() {
                      return assert.equal(response.status, 200);
                    });
                    return context.test("response has default content-type header", function() {
                      return assert.equal(response.content.data.headers["Content-Type"], "text/plain");
                    });
                  }
                }
              });
            });
            context.test("A POST with content type of 'application/json' and status 201", function(context) {
              return shred.post({
                url: "http://localhost:31337/201",
                body: {
                  foo: 1,
                  bar: 2
                },
                headers: {
                  "Content-Type": "application/json"
                },
                on: {
                  request_error: request_error_handler,
                  error: http_error_handler(context),
                  response: function(response) {
                    context.test("response status is 201", function() {
                      return assert.equal(response.status, 201);
                    });
                    return context.test("response has content-type header: 'application/json'", function() {
                      return assert.equal(response.content.data.headers["Content-Type"], "application/json");
                    });
                  }
                }
              });
            });
            context.test("A POST with content type of 'application/x-www-form-urlencoded'", function(context) {
              return shred.post({
                url: "http://localhost:31337/201",
                content: {
                  foo: 1,
                  bar: 2
                },
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded"
                },
                on: {
                  request_error: request_error_handler,
                  error: http_error_handler(context),
                  response: function(response) {
                    var request_data;
                    request_data = response.content.data;
                    context.test("response status is 201", function() {
                      return assert.equal(response.status, 201);
                    });
                    context.test("request has content-type header: 'application/x-www-form-urlencoded'", function() {
                      return assert.equal(request_data.headers["Content-Type"], "application/x-www-form-urlencoded");
                    });
                    return context.test("request body is properly encoded", function() {
                      return assert.equal(response.request.body.body, "foo=1&bar=2");
                    });
                  }
                }
              });
            });
            context.test("Requests with specific and generic status handlers", function(context) {
              context.test("On success, only exact status handler fires", function(context) {
                return shred.get({
                  url: "http://localhost:31337/200",
                  on: {
                    request_error: request_error_handler,
                    error: http_error_handler(context),
                    200: function(response) {
                      return context.pass();
                    },
                    response: function(response) {
                      return context.fail("generic response handler fired");
                    }
                  }
                });
              });
              context.test("On error, only the exact error status handler fires", function(context) {
                return shred.get({
                  url: "http://localhost:31337/404",
                  on: {
                    request_error: function(error) {
                      return context.fail("request_error handler fired");
                    },
                    404: function(response) {
                      return context.pass();
                    },
                    error: function(response) {
                      return context.fail("generic error handler fired");
                    },
                    response: function(response) {
                      return context.fail("generic response handler fired");
                    }
                  }
                });
              });
              return context.test("On non-HTTP failure, only the request_error handler fires", function(context) {
                return shred.get({
                  url: "http://localhost:65535/",
                  on: {
                    request_error: function(error) {
                      return context.test("The callback argument is an Error", function() {
                        return assert.equal(error.constructor, Error);
                      });
                    },
                    error: function(response) {
                      return context.fail("generic error handler fired");
                    },
                    response: function(response) {
                      return context.fail("generic response handler fired");
                    }
                  }
                });
              });
            });
            return context.test("Request with timeout set using an Integer", function(context) {
              return context.test("Only the timeout handler fires", function(context) {
                return shred.get({
                  url: "http://localhost:31337/timeout",
                  timeout: 100,
                  on: {
                    request_error: function(error) {
                      return context.fail("request_error handler fired");
                    },
                    error: function(response) {
                      return context.fail("generic error handler fired");
                    },
                    response: function(response) {
                      return context.fail("generic response handler fired");
                    },
                    timeout: function() {
                      return context.pass();
                    }
                  }
                });
              });
            });
          });

        },

        "8d54b30e151e0c43af3ec7bcd718de7b": // from: test/tests.coffee
        function(exports, require, module, __filename, __dirname) {

          require("./content_test");

          require("./headers_test");

          require("./shred_test");

        },

        "c4f9141dbd0d7a4e3dd3d1dc0a64c667": // from: 
        function(exports, require, module, __filename, __dirname) {
          // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
          //
          // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
          //
          // Originally from narwhal.js (http://narwhaljs.org)
          // Copyright (c) 2009 Thomas Robinson <280north.com>
          //
          // Permission is hereby granted, free of charge, to any person obtaining a copy
          // of this software and associated documentation files (the 'Software'), to
          // deal in the Software without restriction, including without limitation the
          // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
          // sell copies of the Software, and to permit persons to whom the Software is
          // furnished to do so, subject to the following conditions:
          //
          // The above copyright notice and this permission notice shall be included in
          // all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
          // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
          // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

          // UTILITY
          var util = require('util');
          var pSlice = Array.prototype.slice;

          // 1. The assert module provides functions that throw
          // AssertionError's when particular conditions are not met. The
          // assert module must conform to the following interface.

          var assert = module.exports = ok;

          // 2. The AssertionError is defined in assert.
          // new assert.AssertionError({ message: message,
          //                             actual: actual,
          //                             expected: expected })

          assert.AssertionError = function AssertionError(options) {
            this.name = 'AssertionError';
            this.message = options.message;
            this.actual = options.actual;
            this.expected = options.expected;
            this.operator = options.operator;
            var stackStartFunction = options.stackStartFunction || fail;

            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, stackStartFunction);
            }
          };

          // assert.AssertionError instanceof Error
          util.inherits(assert.AssertionError, Error);

          function replacer(key, value) {
            if (value === undefined) {
              return '' + value;
            }
            if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
              return value.toString();
            }
            if (typeof value === 'function' || value instanceof RegExp) {
              return value.toString();
            }
            return value;
          }

          function truncate(s, n) {
            if (typeof s == 'string') {
              return s.length < n ? s : s.slice(0, n);
            } else {
              return s;
            }
          }

          assert.AssertionError.prototype.toString = function() {
            if (this.message) {
              return [this.name + ':', this.message].join(' ');
            } else {
              return [
              this.name + ':',
              truncate(JSON.stringify(this.actual, replacer), 128),
              this.operator,
              truncate(JSON.stringify(this.expected, replacer), 128)].join(' ');
            }
          };

          // At present only the three keys mentioned above are used and
          // understood by the spec. Implementations or sub modules can pass
          // other keys to the AssertionError's constructor - they will be
          // ignored.

          // 3. All of the following functions must throw an AssertionError
          // when a corresponding condition is not met, with a message that
          // may be undefined if not provided.  All assertion methods provide
          // both the actual and expected values to the assertion error for
          // display purposes.

          function fail(actual, expected, message, operator, stackStartFunction) {
            throw new assert.AssertionError({
              message: message,
              actual: actual,
              expected: expected,
              operator: operator,
              stackStartFunction: stackStartFunction
            });
          }

          // EXTENSION! allows for well behaved errors defined elsewhere.
          assert.fail = fail;

          // 4. Pure assertion tests whether a value is truthy, as determined
          // by !!guard.
          // assert.ok(guard, message_opt);
          // This statement is equivalent to assert.equal(true, !!guard,
          // message_opt);. To test strictly for the value true, use
          // assert.strictEqual(true, guard, message_opt);.

          function ok(value, message) {
            if ( !! !value) fail(value, true, message, '==', assert.ok);
          }
          assert.ok = ok;

          // 5. The equality assertion tests shallow, coercive equality with
          // ==.
          // assert.equal(actual, expected, message_opt);

          assert.equal = function equal(actual, expected, message) {
            if (actual != expected) fail(actual, expected, message, '==', assert.equal);
          };

          // 6. The non-equality assertion tests for whether two objects are not equal
          // with != assert.notEqual(actual, expected, message_opt);

          assert.notEqual = function notEqual(actual, expected, message) {
            if (actual == expected) {
              fail(actual, expected, message, '!=', assert.notEqual);
            }
          };

          // 7. The equivalence assertion tests a deep equality relation.
          // assert.deepEqual(actual, expected, message_opt);

          assert.deepEqual = function deepEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected)) {
              fail(actual, expected, message, 'deepEqual', assert.deepEqual);
            }
          };

          function _deepEqual(actual, expected) {
            // 7.1. All identical values are equivalent, as determined by ===.
            if (actual === expected) {
              return true;

            } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
              if (actual.length != expected.length) return false;

              for (var i = 0; i < actual.length; i++) {
                if (actual[i] !== expected[i]) return false;
              }

              return true;

              // 7.2. If the expected value is a Date object, the actual value is
              // equivalent if it is also a Date object that refers to the same time.
            } else if (actual instanceof Date && expected instanceof Date) {
              return actual.getTime() === expected.getTime();

              // 7.3 If the expected value is a RegExp object, the actual value is
              // equivalent if it is also a RegExp object with the same source and
              // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
            } else if (actual instanceof RegExp && expected instanceof RegExp) {
              return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

              // 7.4. Other pairs that do not both pass typeof value == 'object',
              // equivalence is determined by ==.
            } else if (typeof actual != 'object' && typeof expected != 'object') {
              return actual == expected;

              // 7.5 For all other Object pairs, including Array objects, equivalence is
              // determined by having the same number of owned properties (as verified
              // with Object.prototype.hasOwnProperty.call), the same set of keys
              // (although not necessarily the same order), equivalent values for every
              // corresponding key, and an identical 'prototype' property. Note: this
              // accounts for both named and indexed properties on Arrays.
            } else {
              return objEquiv(actual, expected);
            }
          }

          function isUndefinedOrNull(value) {
            return value === null || value === undefined;
          }

          function isArguments(object) {
            return Object.prototype.toString.call(object) == '[object Arguments]';
          }

          function objEquiv(a, b) {
            if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
            // an identical 'prototype' property.
            if (a.prototype !== b.prototype) return false;
            //~~~I've managed to break Object.keys through screwy arguments passing.
            //   Converting to array solves the problem.
            if (isArguments(a)) {
              if (!isArguments(b)) {
                return false;
              }
              a = pSlice.call(a);
              b = pSlice.call(b);
              return _deepEqual(a, b);
            }
            try {
              var ka = Object.keys(a),
                kb = Object.keys(b),
                key, i;
            } catch (e) { //happens when one is a string literal and the other isn't
              return false;
            }
            // having the same number of owned properties (keys incorporates
            // hasOwnProperty)
            if (ka.length != kb.length) return false;
            //the same set of keys (although not necessarily the same order),
            ka.sort();
            kb.sort();
            //~~~cheap key test
            for (i = ka.length - 1; i >= 0; i--) {
              if (ka[i] != kb[i]) return false;
            }
            //equivalent values for every corresponding key, and
            //~~~possibly expensive deep test
            for (i = ka.length - 1; i >= 0; i--) {
              key = ka[i];
              if (!_deepEqual(a[key], b[key])) return false;
            }
            return true;
          }

          // 8. The non-equivalence assertion tests for any deep inequality.
          // assert.notDeepEqual(actual, expected, message_opt);

          assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
            if (_deepEqual(actual, expected)) {
              fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
            }
          };

          // 9. The strict equality assertion tests strict equality, as determined by ===.
          // assert.strictEqual(actual, expected, message_opt);

          assert.strictEqual = function strictEqual(actual, expected, message) {
            if (actual !== expected) {
              fail(actual, expected, message, '===', assert.strictEqual);
            }
          };

          // 10. The strict non-equality assertion tests for strict inequality, as
          // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

          assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
            if (actual === expected) {
              fail(actual, expected, message, '!==', assert.notStrictEqual);
            }
          };

          function expectedException(actual, expected) {
            if (!actual || !expected) {
              return false;
            }

            if (expected instanceof RegExp) {
              return expected.test(actual);
            } else if (actual instanceof expected) {
              return true;
            } else if (expected.call({}, actual) === true) {
              return true;
            }

            return false;
          }

          function _throws(shouldThrow, block, expected, message) {
            var actual;

            if (typeof expected === 'string') {
              message = expected;
              expected = null;
            }

            try {
              block();
            } catch (e) {
              actual = e;
            }

            message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

            if (shouldThrow && !actual) {
              fail(actual, expected, 'Missing expected exception' + message);
            }

            if (!shouldThrow && expectedException(actual, expected)) {
              fail(actual, expected, 'Got unwanted exception' + message);
            }

            if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {
              throw actual;
            }
          }

          // 11. Expected to throw an error:
          // assert.throws(block, Error_opt, message_opt);

          assert.throws = function(block, /*optional*/ error, /*optional*/ message) {
            _throws.apply(this, [true].concat(pSlice.call(arguments)));
          };

          // EXTENSION! This is annoying to write outside this module.
          assert.doesNotThrow = function(block, /*optional*/ message) {
            _throws.apply(this, [false].concat(pSlice.call(arguments)));
          };

          assert.ifError = function(err) {
            if (err) {
              throw err;
            }
          };

        },

        "0426b7a6289080ce650637f0ac6e7e0c": // from: 
        function(exports, require, module, __filename, __dirname) {
          exports.spawn = function() {};
          exports.exec = function() {};

        },

        "a8aae685be6eeb8ec844ae9c4f5fd189": // from: 
        function(exports, require, module, __filename, __dirname) {
          // TODO  
        },

        "b499eb63a89b9e6fb99ef1209a65ace6": // from: 
        function(exports, require, module, __filename, __dirname) {
          if (!process.EventEmitter) process.EventEmitter = function() {};

          var EventEmitter = exports.EventEmitter = process.EventEmitter;
          var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(xs) {
              return Object.prototype.toString.call(xs) === '[object Array]'
            };

          // By default EventEmitters will print a warning if more than
          // 10 listeners are added to it. This is a useful default which
          // helps finding memory leaks.
          //
          // Obviously not all Emitters should be limited to 10. This function allows
          // that to be increased. Set to zero for unlimited.
          var defaultMaxListeners = 10;
          EventEmitter.prototype.setMaxListeners = function(n) {
            if (!this._events) this._events = {};
            this._events.maxListeners = n;
          };


          EventEmitter.prototype.emit = function(type) {
            // If there is no 'error' event listener then throw.
            if (type === 'error') {
              if (!this._events || !this._events.error || (isArray(this._events.error) && !this._events.error.length)) {
                if (arguments[1] instanceof Error) {
                  throw arguments[1]; // Unhandled 'error' event
                } else {
                  throw new Error("Uncaught, unspecified 'error' event.");
                }
                return false;
              }
            }

            if (!this._events) return false;
            var handler = this._events[type];
            if (!handler) return false;

            if (typeof handler == 'function') {
              switch (arguments.length) {
                // fast cases
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
                // slower
              default:
                var args = Array.prototype.slice.call(arguments, 1);
                handler.apply(this, args);
              }
              return true;

            } else if (isArray(handler)) {
              var args = Array.prototype.slice.call(arguments, 1);

              var listeners = handler.slice();
              for (var i = 0, l = listeners.length; i < l; i++) {
                listeners[i].apply(this, args);
              }
              return true;

            } else {
              return false;
            }
          };

          // EventEmitter is defined in src/node_events.cc
          // EventEmitter.prototype.emit() is also defined there.
          EventEmitter.prototype.addListener = function(type, listener) {
            if ('function' !== typeof listener) {
              throw new Error('addListener only takes instances of Function');
            }

            if (!this._events) this._events = {};

            // To avoid recursion in the case that type == "newListeners"! Before
            // adding it to the listeners, first emit "newListeners".
            this.emit('newListener', type, listener);

            if (!this._events[type]) {
              // Optimize the case of one listener. Don't need the extra array object.
              this._events[type] = listener;
            } else if (isArray(this._events[type])) {

              // Check for listener leak
              if (!this._events[type].warned) {
                var m;
                if (this._events.maxListeners !== undefined) {
                  m = this._events.maxListeners;
                } else {
                  m = defaultMaxListeners;
                }

                if (m && m > 0 && this._events[type].length > m) {
                  this._events[type].warned = true;
                  console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.',
                  this._events[type].length);
                  console.trace();
                }
              }

              // If we've already got an array, just append.
              this._events[type].push(listener);
            } else {
              // Adding the second element, need to change to array.
              this._events[type] = [this._events[type], listener];
            }

            return this;
          };

          EventEmitter.prototype.on = EventEmitter.prototype.addListener;

          EventEmitter.prototype.once = function(type, listener) {
            var self = this;
            self.on(type, function g() {
              self.removeListener(type, g);
              listener.apply(this, arguments);
            });

            return this;
          };

          EventEmitter.prototype.removeListener = function(type, listener) {
            if ('function' !== typeof listener) {
              throw new Error('removeListener only takes instances of Function');
            }

            // does not use listeners(), so no side effect of creating _events[type]
            if (!this._events || !this._events[type]) return this;

            var list = this._events[type];

            if (isArray(list)) {
              var i = list.indexOf(listener);
              if (i < 0) return this;
              list.splice(i, 1);
              if (list.length == 0) delete this._events[type];
            } else if (this._events[type] === listener) {
              delete this._events[type];
            }

            return this;
          };

          EventEmitter.prototype.removeAllListeners = function(type) {
            // does not use listeners(), so no side effect of creating _events[type]
            if (type && this._events && this._events[type]) this._events[type] = null;
            return this;
          };

          EventEmitter.prototype.listeners = function(type) {
            if (!this._events) this._events = {};
            if (!this._events[type]) this._events[type] = [];
            if (!isArray(this._events[type])) {
              this._events[type] = [this._events[type]];
            }
            return this._events[type];
          };

        },

        "4b089ad1310f754af3510dd2da9a1ff7": // from: 
        function(exports, require, module, __filename, __dirname) {
          var Stat, base64Decode, fs, getFile;

          getFile = function(path) {
            var file, part, parts, _i, _len;
            parts = path.split("/").slice(1);
            file = global.filesystem.root;
            for (_i = 0, _len = parts.length; _i < _len; _i++) {
              part = parts[_i];
              if (!(file = file[part])) {
                throw "File not found at '" + path + "'";
              }
            }
            return file;
          };

          Stat = (function() {

            function Stat(path) {
              this.file = getFile(path);
            }

            Stat.prototype.isDirectory = function() {
              return this.file.__stat.type === "directory";
            };

            Stat.prototype.isFile = function() {
              return this.file.__stat.type === "file";
            };

            Stat.prototype.isSymbolicLink = function() {
              return false;
            };

            return Stat;

          })();

          base64Decode = function(string) {
            return decodeURIComponent(escape(window.atob(string)));
          };

          var fs = {
            readFileSync: function(path, encoding) {
              var file;
              file = getFile(path);
              return global.filesystem.read(file);
            },
            statSync: function(path) {
              return new Stat(path);
            },
            lstatSync: function(path) {
              return this.statSync(path);
            },
            // realpath Sync adapted from Node source
            realpathSync: function realpathSync(p, cache) {

              var isWindows = process.platform === 'win32';

              // Regexp that finds the next partion of a (partial) path
              // result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
              if (isWindows) {
                var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
              } else {
                var nextPartRe = /(.*?)(?:[\/]+|$)/g;
              }

              // Regex to find the device root, including trailing slash. E.g. 'c:\\'.
              if (isWindows) {
                var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
              } else {
                var splitRootRe = /^[\/]*/;
              }

              var pathModule = NativeModule.require("path");
              var normalize = pathModule.normalize;

              // make p is absolute
              p = pathModule.resolve(p);

              if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
                return cache[p];
              }

              var original = p,
                seenLinks = {},
                knownHard = {};

              // current character position in p
              var pos;
              // the partial path so far, including a trailing slash if any
              var current;
              // the partial path without a trailing slash (except when pointing at a root)
              var base;
              // the partial path scanned in the previous round, with slash
              var previous;

              start();

              function start() {
                // Skip over roots
                var m = splitRootRe.exec(p);
                pos = m[0].length;
                current = m[0];
                base = m[0];
                previous = '';

                // On windows, check that the root exists. On unix there is no need.
                if (isWindows && !knownHard[base]) {
                  fs.lstatSync(base);
                  knownHard[base] = true;
                }
              }

              // walk down the path, swapping out linked pathparts for their real
              // values
              // NB: p.length changes.
              while (pos < p.length) {
                // find the next part
                nextPartRe.lastIndex = pos;
                var result = nextPartRe.exec(p);
                previous = current;
                current += result[0];
                base = previous + result[1];
                pos = nextPartRe.lastIndex;

                // continue if not a symlink
                if (knownHard[base] || (cache && cache[base] === base)) {
                  continue;
                }

                var resolvedLink;
                if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
                  // some known symbolic link.  no need to stat again.
                  resolvedLink = cache[base];
                } else {
                  var stat = fs.lstatSync(base);
                  if (!stat.isSymbolicLink()) {
                    knownHard[base] = true;
                    if (cache) cache[base] = base;
                    continue;
                  }

                  // read the link if it wasn't read before
                  // dev/ino always return 0 on windows, so skip the check.
                  var linkTarget = null;
                  if (!isWindows) {
                    var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
                    if (seenLinks.hasOwnProperty(id)) {
                      linkTarget = seenLinks[id];
                    }
                  }
                  if (linkTarget === null) {
                    fs.statSync(base);
                    linkTarget = fs.readlinkSync(base);
                  }
                  resolvedLink = pathModule.resolve(previous, linkTarget);
                  // track this, if given a cache.
                  if (cache) cache[base] = resolvedLink;
                  if (!isWindows) seenLinks[id] = linkTarget;
                }

                // resolve the link, then start over
                p = pathModule.resolve(resolvedLink, p.slice(pos));
                start();
              }

              if (cache) cache[original] = p;

              return p;
            }
          };

          module.exports = fs;
        },

        "5d6e2c2d895132330e91af96bc1409c7": // from: 
        function(exports, require, module, __filename, __dirname) {
          //
          // Adapted from http-browserify
          //


          var http = module.exports;
          var EventEmitter = require('events').EventEmitter;
          var Request;

          http.request = function(params, cb) {
            if (!params) params = {};
            if (!params.host) params.host = window.location.host.split(':')[0];
            if (!params.port) params.port = window.location.port;

            var req = new Request(new xhrHttp, params);
            if (cb) req.on('response', cb);
            return req;
          };

          http.get = function(params, cb) {
            params.method = 'GET';
            var req = http.request(params, cb);
            req.end();
            return req;
          };

          http.Agent = function() {};
          http.Agent.defaultMaxSockets = 4;

          var xhrHttp = (function() {
            if (typeof window === 'undefined') {
              throw new Error('no window object present');
            } else if (window.XMLHttpRequest) {
              return window.XMLHttpRequest;
            } else if (window.ActiveXObject) {
              var axs = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP'];
              for (var i = 0; i < axs.length; i++) {
                try {
                  var ax = new(window.ActiveXObject)(axs[i]);
                  return function() {
                    if (ax) {
                      var ax_ = ax;
                      ax = null;
                      return ax_;
                    } else {
                      return new(window.ActiveXObject)(axs[i]);
                    }
                  };
                } catch (e) {}
              }
              throw new Error('ajax not supported in this browser')
            } else {
              throw new Error('ajax not supported in this browser');
            }
          })();


          Request = (function() {
            var EventEmitter = require('events').EventEmitter;
            var Response;
            var concatStream;

            var Request = function(xhr, params) {
              var self = this;
              self.xhr = xhr;
              self.body = concatStream()

              var uri = params.host + ':' + params.port + (params.path || '/');

              xhr.open(
              params.method || 'GET', (params.scheme || 'http') + '://' + uri,
              true);

              if (params.headers) {
                Object.keys(params.headers).forEach(function(key) {
                  if (!self.isSafeRequestHeader(key)) return;
                  var value = params.headers[key];
                  if (Array.isArray(value)) {
                    value.forEach(function(v) {
                      xhr.setRequestHeader(key, v);
                    });
                  } else xhr.setRequestHeader(key, value)
                });
              }

              var res = new Response(xhr);
              res.on('ready', function() {
                self.emit('response', res);
              });

              xhr.onreadystatechange = function() {
                res.handle(xhr);
              };
            };

            Request.prototype = new EventEmitter;

            Request.prototype.setHeader = function(key, value) {
              if ((Array.isArray && Array.isArray(value)) || value instanceof Array) {
                for (var i = 0; i < value.length; i++) {
                  this.xhr.setRequestHeader(key, value[i]);
                }
              } else {
                this.xhr.setRequestHeader(key, value);
              }
            };

            Request.prototype.write = function(s) {
              this.body.write(s);
            };

            Request.prototype.end = function(s) {
              if (s !== undefined) this.body.write(s);
              this.body.end()
              this.xhr.send(this.body.getBody());
            };

            // Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
            Request.unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "content-transfer-encoding", "date", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];

            Request.prototype.isSafeRequestHeader = function(headerName) {
              if (!headerName) return false;
              return (Request.unsafeHeaders.indexOf(headerName.toLowerCase()) === -1)
            };

            Response = (function() {

              var EventEmitter = require('events').EventEmitter;

              var Response = function(xhr) {
                this.xhr = xhr;
                this.offset = 0;
              };

              Response.prototype = new EventEmitter;

              var capable = {
                streaming: true,
                status2: true
              };

              function parseHeaders(xhr) {
                var lines = xhr.getAllResponseHeaders().split(/\r?\n/);
                var headers = {};
                for (var i = 0; i < lines.length; i++) {
                  var line = lines[i];
                  if (line === '') continue;

                  var m = line.match(/^([^:]+):\s*(.*)/);
                  if (m) {
                    var key = m[1].toLowerCase(),
                      value = m[2];

                    if (headers[key] !== undefined) {
                      if ((Array.isArray && Array.isArray(headers[key])) || headers[key] instanceof Array) {
                        headers[key].push(value);
                      } else {
                        headers[key] = [headers[key], value];
                      }
                    } else {
                      headers[key] = value;
                    }
                  } else {
                    headers[line] = true;
                  }
                }
                return headers;
              }

              Response.prototype.getResponse = function(xhr) {
                var respType = xhr.responseType.toLowerCase();
                if (respType === "blob") return xhr.responseBlob;
                if (respType === "arraybuffer") return xhr.response;
                return xhr.responseText;
              }

              Response.prototype.getHeader = function(key) {
                return this.headers[key.toLowerCase()] || this.xhr.getResponseHeader(key);
              };

              Response.prototype.handle = function(xhr) {
                if (xhr.readyState === 2 && capable.status2) {
                  try {
                    this.statusCode = xhr.status;
                    this.headers = parseHeaders(xhr);
                  } catch (err) {
                    capable.status2 = false;
                  }

                  if (capable.status2) {
                    this.emit('ready');
                  }
                } else if (capable.streaming && xhr.readyState === 3) {
                  try {
                    if (!this.statusCode) {
                      this.statusCode = xhr.status;
                      this.headers = parseHeaders(xhr);
                      this.emit('ready');
                    }
                  } catch (err) {}

                  try {
                    this.write(xhr);
                  } catch (err) {
                    capable.streaming = false;
                  }
                } else if (xhr.readyState === 4) {
                  if (!this.statusCode) {
                    this.statusCode = xhr.status;
                    this.emit('ready');
                  }
                  this.write(xhr);

                  if (xhr.error) {
                    this.emit('error', this.getResponse(xhr));
                  } else this.emit('end');
                }
              };

              Response.prototype.write = function(xhr) {
                var respBody = this.getResponse(xhr);
                if (respBody.toString().match(/ArrayBuffer/)) {
                  this.emit('data', new Uint8Array(respBody, this.offset));
                  this.offset = respBody.byteLength;
                  return;
                }
                if (respBody.length > this.offset) {
                  this.emit('data', respBody.slice(this.offset));
                  this.offset = respBody.length;
                }
              };

              return Response;

            })();

            concatStream = (function() {

              var stream = require('stream')
              var util = require('util')

                function ConcatStream(cb) {
                  stream.Stream.call(this)
                  this.writable = true
                  if (cb) this.cb = cb
                  this.body = []
                  this.on('error', function(err) {
                    if (this.cb) this.cb(err)
                  })
                }

              util.inherits(ConcatStream, stream.Stream)

              ConcatStream.prototype.write = function(chunk) {
                this.body.push(chunk)
              }

              ConcatStream.prototype.destroy = function() {}

              ConcatStream.prototype.arrayConcat = function(arrs) {
                if (arrs.length === 0) return []
                if (arrs.length === 1) return arrs[0]
                return arrs.reduce(function(a, b) {
                  return a.concat(b)
                })
              }

              ConcatStream.prototype.isArray = function(arr) {
                var isArray = Array.isArray(arr)
                var isTypedArray = arr.toString().match(/Array/)
                return isArray || isTypedArray
              }

              ConcatStream.prototype.getBody = function() {
                if (this.body.length === 0) return
                if (typeof(this.body[0]) === "string") return this.body.join('')
                if (this.isArray(this.body[0])) return this.arrayConcat(this.body)
                if (typeof(Buffer) !== "undefined" && Buffer.isBuffer(this.body[0])) {
                  return Buffer.concat(this.body)
                }
                return this.body
              }

              ConcatStream.prototype.end = function() {
                if (this.cb) this.cb(false, this.getBody())
              }

              var exports = function(cb) {
                return new ConcatStream(cb)
              }

              exports.ConcatStream = ConcatStream

              return exports;

            })();

            return Request;

          })();



        },

        "8f99cc2b75044ae1f45cefc6948e42b3": // from: 
        function(exports, require, module, __filename, __dirname) {
          module.exports = require('http');

        },

        "223f09f17e4aff9f2d05493c688f7934": // from: 
        function(exports, require, module, __filename, __dirname) {
          //
          // Adapted from Node source
          //

          var NativeModule = require('native_module');
          var Script = process.binding('evals').NodeScript;
          var runInThisContext = Script.runInThisContext;
          var runInNewContext = Script.runInNewContext;
          var assert = require('assert').ok;


          // If obj.hasOwnProperty has been overridden, then calling
          // obj.hasOwnProperty(prop) will break.
          // See: https://github.com/joyent/node/issues/1707
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }


          function Module(id, parent) {
            this.id = id;
            this.exports = {};
            this.parent = parent;
            if (parent && parent.children) {
              parent.children.push(this);
            }

            this.filename = null;
            this.loaded = false;
            this.children = [];
          }
          module.exports = Module;

          // Set the environ variable NODE_MODULE_CONTEXTS=1 to make node load all
          // modules in thier own context.
          Module._contextLoad = (+process.env['NODE_MODULE_CONTEXTS'] > 0);
          Module._cache = {};
          Module._pathCache = {};
          Module._extensions = {};
          var modulePaths = [];
          Module.globalPaths = [];

          Module.wrapper = NativeModule.wrapper;
          Module.wrap = NativeModule.wrap;

          var path = NativeModule.require('path');

          Module._debug = function() {};
          if (process.env.NODE_DEBUG && /module/.test(process.env.NODE_DEBUG)) {
            Module._debug = function(x) {
              console.error(x);
            };
          }


          // We use this alias for the preprocessor that filters it out
          var debug = Module._debug;


          // given a module name, and a list of paths to test, returns the first
          // matching file in the following precedence.
          //
          // require("a.<ext>")
          //   -> a.<ext>
          //
          // require("a")
          //   -> a
          //   -> a.<ext>
          //   -> a/index.<ext>

          function statPath(path) {
            var fs = NativeModule.require('fs');
            try {
              return fs.statSync(path);
            } catch (ex) {}
            return false;
          }

          // check if the directory is a package.json dir
          var packageCache = {};

          function readPackage(requestPath) {
            if (hasOwnProperty(packageCache, requestPath)) {
              return packageCache[requestPath];
            }

            var fs = NativeModule.require('fs');
            try {
              var jsonPath = path.resolve(requestPath, 'package.json');
              var json = fs.readFileSync(jsonPath, 'utf8');
            } catch (e) {
              return false;
            }

            try {
              var pkg = packageCache[requestPath] = JSON.parse(json);
            } catch (e) {
              e.path = jsonPath;
              e.message = 'Error parsing ' + jsonPath + ': ' + e.message;
              throw e;
            }
            return pkg;
          }

          function tryPackage(requestPath, exts) {
            var pkg = readPackage(requestPath);

            if (!pkg || !pkg.main) return false;

            var filename = path.resolve(requestPath, pkg.main);
            return tryFile(filename) || tryExtensions(filename, exts) || tryExtensions(path.resolve(filename, 'index'), exts);
          }

          // In order to minimize unnecessary lstat() calls,
          // this cache is a list of known-real paths.
          // Set to an empty object to reset.
          Module._realpathCache = {};

          // check if the file exists and is not a directory
          function tryFile(requestPath) {
            var fs = NativeModule.require('fs');
            var stats = statPath(requestPath);
            if (stats && !stats.isDirectory()) {
              return fs.realpathSync(requestPath, Module._realpathCache);
            }
            return false;
          }

          // given a path check a the file exists with any of the set extensions
          function tryExtensions(p, exts) {
            for (var i = 0, EL = exts.length; i < EL; i++) {
              var filename = tryFile(p + exts[i]);

              if (filename) {
                return filename;
              }
            }
            return false;
          }


          Module._findPath = function(request, paths) {
            var exts = Object.keys(Module._extensions);

            if (request.charAt(0) === '/') {
              paths = [''];
            }

            var trailingSlash = (request.slice(-1) === '/');

            var cacheKey = JSON.stringify({
              request: request,
              paths: paths
            });
            if (Module._pathCache[cacheKey]) {
              return Module._pathCache[cacheKey];
            }

            // For each path
            for (var i = 0, PL = paths.length; i < PL; i++) {
              var basePath = path.resolve(paths[i], request);
              var filename;

              if (!trailingSlash) {
                // try to join the request to the path
                filename = tryFile(basePath);

                if (!filename && !trailingSlash) {
                  // try it with each of the extensions
                  filename = tryExtensions(basePath, exts);
                }
              }

              if (!filename) {
                filename = tryPackage(basePath, exts);
              }

              if (!filename) {
                // try it with each of the extensions at "index"
                filename = tryExtensions(path.resolve(basePath, 'index'), exts);
              }

              if (filename) {
                Module._pathCache[cacheKey] = filename;
                return filename;
              }
            }
            return false;
          };

          // 'from' is the __dirname of the module.
          Module._nodeModulePaths = function(from) {
            // guarantee that 'from' is absolute.
            from = path.resolve(from);

            // note: this approach *only* works when the path is guaranteed
            // to be absolute.  Doing a fully-edge-case-correct path.split
            // that works on both Windows and Posix is non-trivial.
            var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\//;
            // yes, '/' works on both, but let's be a little canonical.
            var joiner = process.platform === 'win32' ? '\\' : '/';
            var paths = [];
            var parts = from.split(splitRe);

            for (var tip = parts.length - 1; tip >= 0; tip--) {
              // don't search in .../node_modules/node_modules
              if (parts[tip] === 'node_modules') continue;
              var dir = parts.slice(0, tip + 1).concat('node_modules').join(joiner);
              paths.push(dir);
            }

            return paths;
          };


          Module._resolveLookupPaths = function(request, parent) {
            if (NativeModule.exists(request)) {
              return [request, []];
            }

            var start = request.substring(0, 2);
            if (start !== './' && start !== '..') {
              var paths = modulePaths;
              if (parent) {
                if (!parent.paths) parent.paths = [];
                paths = parent.paths.concat(paths);
              }
              return [request, paths];
            }

            // with --eval, parent.id is not set and parent.filename is null
            if (!parent || !parent.id || !parent.filename) {
              // make require('./path/to/foo') work - normally the path is taken
              // from realpath(__filename) but with eval there is no filename
              var mainPaths = ['.'].concat(modulePaths);
              mainPaths = Module._nodeModulePaths('.').concat(mainPaths);
              return [request, mainPaths];
            }

            // Is the parent an index module?
            // We can assume the parent has a valid extension,
            // as it already has been accepted as a module.
            var isIndex = /^index\.\w+?$/.test(path.basename(parent.filename));
            var parentIdPath = isIndex ? parent.id : path.dirname(parent.id);
            var id = path.resolve(parentIdPath, request);

            // make sure require('./path') and require('path') get distinct ids, even
            // when called from the toplevel js file
            if (parentIdPath === '.' && id.indexOf('/') === -1) {
              id = './' + id;
            }

            debug('RELATIVE: requested:' + request + ' set ID to: ' + id + ' from ' + parent.id);

            return [id, [path.dirname(parent.filename)]];
          };


          Module._load = function(request, parent, isMain) {
            if (parent) {
              debug('Module._load REQUEST  ' + (request) + ' parent: ' + parent.id);
            }

            var filename = Module._resolveFilename(request, parent);

            var cachedModule = Module._cache[filename];
            if (cachedModule) {
              return cachedModule.exports;
            }

            if (NativeModule.exists(filename)) {
              // REPL is a special case, because it needs the real require.
              if (filename == 'repl') {
                var replModule = new Module('repl');
                replModule._compile(NativeModule.getSource('repl'), 'repl.js');
                NativeModule._cache.repl = replModule;
                return replModule.exports;
              }

              debug('load native module ' + request);
              return NativeModule.require(filename);
            }

            var module = new Module(filename, parent);

            if (isMain) {
              process.mainModule = module;
              module.id = '.';
            }

            Module._cache[filename] = module;

            var hadException = true;

            try {
              module.load(filename);
              hadException = false;
            } finally {
              if (hadException) {
                delete Module._cache[filename];
              }
            }

            return module.exports;
          };

          Module._resolveFilename = function(request, parent) {
            if (NativeModule.exists(request)) {
              return request;
            }

            var resolvedModule = Module._resolveLookupPaths(request, parent);
            var id = resolvedModule[0];
            var paths = resolvedModule[1];

            // look up the filename first, since that's the cache key.
            debug('looking for ' + JSON.stringify(id) + ' in ' + JSON.stringify(paths));

            var filename = Module._findPath(request, paths);
            if (!filename) {
              var err = new Error("Cannot find module '" + request + "'");
              err.code = 'MODULE_NOT_FOUND';
              throw err;
            }
            return filename;
          };


          Module.prototype.load = function(filename) {
            debug('load ' + JSON.stringify(filename) + ' for module ' + JSON.stringify(this.id));

            assert(!this.loaded);
            this.filename = filename;
            this.paths = Module._nodeModulePaths(path.dirname(filename));

            var extension = path.extname(filename) || '.js';
            if (!Module._extensions[extension]) extension = '.js';
            Module._extensions[extension](this, filename);
            this.loaded = true;
          };


          Module.prototype.require = function(path) {
            return Module._load(path, this);
          };


          // Resolved path to process.argv[1] will be lazily placed here
          // (needed for setting breakpoint when called with --debug-brk)
          var resolvedArgv;


          // Returns exception if any
          Module.prototype._compile = function(content, filename) {
            var self = this;
            // remove shebang
            content = content.replace(/^\#\!.*/, '');

            function require(path) {
              return self.require(path);
            }

            require.resolve = function(request) {
              return Module._resolveFilename(request, self);
            };

            Object.defineProperty(require, 'paths', {
              get: function() {
                throw new Error('require.paths is removed. Use ' + 'node_modules folders, or the NODE_PATH ' + 'environment variable instead.');
              }
            });

            require.main = process.mainModule;

            // Enable support to add extra extension types
            require.extensions = Module._extensions;
            require.registerExtension = function() {
              throw new Error('require.registerExtension() removed. Use ' + 'require.extensions instead.');
            };

            require.cache = Module._cache;

            var dirname = path.dirname(filename);

            if (Module._contextLoad) {
              if (self.id !== '.') {
                debug('load submodule');
                // not root module
                var sandbox = {};
                for (var k in global) {
                  sandbox[k] = global[k];
                }
                sandbox.require = require;
                sandbox.exports = self.exports;
                sandbox.__filename = filename;
                sandbox.__dirname = dirname;
                sandbox.module = self;
                sandbox.global = sandbox;
                sandbox.root = root;

                return runInNewContext(content, sandbox, filename, true);
              }

              debug('load root module');
              // root module
              global.require = require;
              global.exports = self.exports;
              global.__filename = filename;
              global.__dirname = dirname;
              global.module = self;

              return runInThisContext(content, filename, true);
            }

            // create wrapper function
            var wrapper = Module.wrap(content);

            var compiledWrapper = runInThisContext(wrapper, filename, true);
            if (global.v8debug) {
              if (!resolvedArgv) {
                // we enter the repl if we're not given a filename argument.
                if (process.argv[1]) {
                  resolvedArg = Module._resolveFilename(process.argv[1], null);
                } else {
                  resolvedArg = 'repl';
                }
              }

              // Set breakpoint on module start
              if (filename === resolvedArgv) {
                global.v8debug.Debug.setBreakPoint(compiledWrapper, 0, 0);
              }
            }
            var args = [self.exports, require, self, filename, dirname];
            return compiledWrapper.apply(self.exports, args);
          };


          function stripBOM(content) {
            // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
            // because the buffer-to-string conversion in `fs.readFileSync()`
            // translates it to FEFF, the UTF-16 BOM.
            if (content.charCodeAt(0) === 0xFEFF) {
              content = content.slice(1);
            }
            return content;
          }


          // Native extension for .js
          Module._extensions['.js'] = function(module, filename) {
            var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
            module._compile(stripBOM(content), filename);
          };

          // We've already pre-compiled the CoffeeScript so we can embed the source and
          // have it show up in the debugger
          Module._extensions['.coffee'] = Module._extensions['.js']


          // Native extension for .json
          Module._extensions['.json'] = function(module, filename) {
            var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
            try {
              module.exports = JSON.parse(stripBOM(content));
            } catch (err) {
              err.message = filename + ': ' + err.message;
              throw err;
            }
          };


          //Native extension for .node
          Module._extensions['.node'] = function(module, filename) {
            process.dlopen(filename, module.exports);
          };


          // bootstrap main module.
          Module.runMain = function() {
            // Load the main module--the command line argument.
            Module._load(process.argv[1], null, true);
          };

          Module._initPaths = function() {
            var paths = [path.resolve(process.execPath, '..', '..', 'lib', 'node')];

            if (process.env['HOME']) {
              paths.unshift(path.resolve(process.env['HOME'], '.node_libraries'));
              paths.unshift(path.resolve(process.env['HOME'], '.node_modules'));
            }

            if (process.env['NODE_PATH']) {
              var splitter = process.platform === 'win32' ? ';' : ':';
              paths = process.env['NODE_PATH'].split(splitter).concat(paths);
            }

            modulePaths = paths;

            // clone as a read-only copy, for introspection.
            Module.globalPaths = modulePaths.slice(0);
          };

          // bootstrap repl
          Module.requireRepl = function() {
            return Module._load('repl', '.');
          };

          Module._initPaths();

          // backwards compatibility
          Module.Module = Module;

        },

        "7b51c3f0555ccb0c0f1fcd91d389ea1a": // from: 
        function(exports, require, module, __filename, __dirname) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.


          var isWindows = process.platform === 'win32';
          var util = require('util');


          // resolves . and .. elements in a path array with directory names there
          // must be no slashes, empty elements, or device names (c:\) in the array
          // (so also no leading and trailing slashes - it does not distinguish
          // relative and absolute paths)
          function normalizeArray(parts, allowAboveRoot) {
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === '.') {
                parts.splice(i, 1);
              } else if (last === '..') {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift('..');
              }
            }

            return parts;
          }


          if (isWindows) {
            // Regex to split a windows path into three parts: [*, device, slash,
            // tail] windows-only
            var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?([\\\/])?([\s\S]*?)$/;

            // Regex to split the tail part of the above into [*, dir, basename, ext]
            var splitTailRe = /^([\s\S]+[\\\/](?!$)|[\\\/])?((?:\.{1,2}$|[\s\S]+?)?(\.[^.\/\\]*)?)$/;

            // Function to split a filename into [root, dir, basename, ext]
            // windows version
            var splitPath = function(filename) {
              // Separate device+slash from tail
              var result = splitDeviceRe.exec(filename),
                device = (result[1] || '') + (result[2] || ''),
                tail = result[3] || '';
              // Split the tail into dir, basename and extension
              var result2 = splitTailRe.exec(tail),
                dir = result2[1] || '',
                basename = result2[2] || '',
                ext = result2[3] || '';
              return [device, dir, basename, ext];
            };

            // path.resolve([from ...], to)
            // windows version
            exports.resolve = function() {
              var resolvedDevice = '',
                resolvedTail = '',
                resolvedAbsolute = false;

              for (var i = arguments.length - 1; i >= -1; i--) {
                var path;
                if (i >= 0) {
                  path = arguments[i];
                } else if (!resolvedDevice) {
                  path = process.cwd();
                } else {
                  // Windows has the concept of drive-specific current working
                  // directories. If we've resolved a drive letter but not yet an
                  // absolute path, get cwd for that drive. We're sure the device is not
                  // an unc path at this points, because unc paths are always absolute.
                  path = process.env['=' + resolvedDevice];
                  // Verify that a drive-local cwd was found and that it actually points
                  // to our drive. If not, default to the drive's root.
                  if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\') {
                    path = resolvedDevice + '\\';
                  }
                }

                // Skip empty and invalid entries
                if (typeof path !== 'string' || !path) {
                  continue;
                }

                var result = splitDeviceRe.exec(path),
                  device = result[1] || '',
                  isUnc = device && device.charAt(1) !== ':',
                  isAbsolute = !! result[2] || isUnc, // UNC paths are always absolute
                  tail = result[3];

                if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                  // This path points to another device so it is not applicable
                  continue;
                }

                if (!resolvedDevice) {
                  resolvedDevice = device;
                }
                if (!resolvedAbsolute) {
                  resolvedTail = tail + '\\' + resolvedTail;
                  resolvedAbsolute = isAbsolute;
                }

                if (resolvedDevice && resolvedAbsolute) {
                  break;
                }
              }

              // Replace slashes (in UNC share name) by backslashes
              resolvedDevice = resolvedDevice.replace(/\//g, '\\');

              // At this point the path should be resolved to a full absolute path,
              // but handle relative paths to be safe (might happen when process.cwd()
              // fails)

              // Normalize the tail path

              function f(p) {
                return !!p;
              }

              resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f), !resolvedAbsolute).join('\\');

              return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) || '.';
            };

            // windows version
            exports.normalize = function(path) {
              var result = splitDeviceRe.exec(path),
                device = result[1] || '',
                isUnc = device && device.charAt(1) !== ':',
                isAbsolute = !! result[2] || isUnc, // UNC paths are always absolute
                tail = result[3],
                trailingSlash = /[\\\/]$/.test(tail);

              // Normalize the tail path
              tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
                return !!p;
              }), !isAbsolute).join('\\');

              if (!tail && !isAbsolute) {
                tail = '.';
              }
              if (tail && trailingSlash) {
                tail += '\\';
              }

              // Convert slashes to backslashes when `device` points to an UNC root.
              device = device.replace(/\//g, '\\');

              return device + (isAbsolute ? '\\' : '') + tail;
            };

            // windows version
            exports.join = function() {
              function f(p) {
                return p && typeof p === 'string';
              }

              var paths = Array.prototype.filter.call(arguments, f);
              var joined = paths.join('\\');

              // Make sure that the joined path doesn't start with two slashes
              // - it will be mistaken for an unc path by normalize() -
              // unless the paths[0] also starts with two slashes
              if (/^[\\\/]{2}/.test(joined) && !/^[\\\/]{2}/.test(paths[0])) {
                joined = joined.substr(1);
              }

              return exports.normalize(joined);
            };

            // path.relative(from, to)
            // it will solve the relative path from 'from' to 'to', for instance:
            // from = 'C:\\orandea\\test\\aaa'
            // to = 'C:\\orandea\\impl\\bbb'
            // The output of the function should be: '..\\..\\impl\\bbb'
            // windows version
            exports.relative = function(from, to) {
              from = exports.resolve(from);
              to = exports.resolve(to);

              // windows is not case sensitive
              var lowerFrom = from.toLowerCase();
              var lowerTo = to.toLowerCase();

              function trim(arr) {
                var start = 0;
                for (; start < arr.length; start++) {
                  if (arr[start] !== '') break;
                }

                var end = arr.length - 1;
                for (; end >= 0; end--) {
                  if (arr[end] !== '') break;
                }

                if (start > end) return [];
                return arr.slice(start, end - start + 1);
              }

              var toParts = trim(to.split('\\'));

              var lowerFromParts = trim(lowerFrom.split('\\'));
              var lowerToParts = trim(lowerTo.split('\\'));

              var length = Math.min(lowerFromParts.length, lowerToParts.length);
              var samePartsLength = length;
              for (var i = 0; i < length; i++) {
                if (lowerFromParts[i] !== lowerToParts[i]) {
                  samePartsLength = i;
                  break;
                }
              }

              if (samePartsLength == 0) {
                return to;
              }

              var outputParts = [];
              for (var i = samePartsLength; i < lowerFromParts.length; i++) {
                outputParts.push('..');
              }

              outputParts = outputParts.concat(toParts.slice(samePartsLength));

              return outputParts.join('\\');
            };

            exports.sep = '\\';

          } else /* posix */
          {

            // Split a filename into [root, dir, basename, ext], unix version
            // 'root' is just a slash, or nothing.
            var splitPathRe = /^(\/?)([\s\S]+\/(?!$)|\/)?((?:\.{1,2}$|[\s\S]+?)?(\.[^.\/]*)?)$/;
            var splitPath = function(filename) {
              var result = splitPathRe.exec(filename);
              return [result[1] || '', result[2] || '', result[3] || '', result[4] || ''];
            };

            // path.resolve([from ...], to)
            // posix version
            exports.resolve = function() {
              var resolvedPath = '',
                resolvedAbsolute = false;

              for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path = (i >= 0) ? arguments[i] : process.cwd();

                // Skip empty and invalid entries
                if (typeof path !== 'string' || !path) {
                  continue;
                }

                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charAt(0) === '/';
              }

              // At this point the path should be resolved to a full absolute path, but
              // handle relative paths to be safe (might happen when process.cwd() fails)

              // Normalize the path
              resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
                return !!p;
              }), !resolvedAbsolute).join('/');

              return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
            };

            // path.normalize(path)
            // posix version
            exports.normalize = function(path) {
              var isAbsolute = path.charAt(0) === '/',
                trailingSlash = path.substr(-1) === '/';

              // Normalize the path
              path = normalizeArray(path.split('/').filter(function(p) {
                return !!p;
              }), !isAbsolute).join('/');

              if (!path && !isAbsolute) {
                path = '.';
              }
              if (path && trailingSlash) {
                path += '/';
              }

              return (isAbsolute ? '/' : '') + path;
            };


            // posix version
            exports.join = function() {
              var paths = Array.prototype.slice.call(arguments, 0);
              return exports.normalize(paths.filter(function(p, index) {
                return p && typeof p === 'string';
              }).join('/'));
            };


            // path.relative(from, to)
            // posix version
            exports.relative = function(from, to) {
              from = exports.resolve(from).substr(1);
              to = exports.resolve(to).substr(1);

              function trim(arr) {
                var start = 0;
                for (; start < arr.length; start++) {
                  if (arr[start] !== '') break;
                }

                var end = arr.length - 1;
                for (; end >= 0; end--) {
                  if (arr[end] !== '') break;
                }

                if (start > end) return [];
                return arr.slice(start, end - start + 1);
              }

              var fromParts = trim(from.split('/'));
              var toParts = trim(to.split('/'));

              var length = Math.min(fromParts.length, toParts.length);
              var samePartsLength = length;
              for (var i = 0; i < length; i++) {
                if (fromParts[i] !== toParts[i]) {
                  samePartsLength = i;
                  break;
                }
              }

              var outputParts = [];
              for (var i = samePartsLength; i < fromParts.length; i++) {
                outputParts.push('..');
              }

              outputParts = outputParts.concat(toParts.slice(samePartsLength));

              return outputParts.join('/');
            };

            exports.sep = '/';
          }


          exports.dirname = function(path) {
            var result = splitPath(path),
              root = result[0],
              dir = result[1];

            if (!root && !dir) {
              // No dirname whatsoever
              return '.';
            }

            if (dir) {
              // It has a dirname, strip trailing slash
              dir = dir.substr(0, dir.length - 1);
            }

            return root + dir;
          };


          exports.basename = function(path, ext) {
            var f = splitPath(path)[2];
            // TODO: make this comparison case-insensitive on windows?
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };


          exports.extname = function(path) {
            return splitPath(path)[3];
          };


          exports.exists = util.deprecate(function(path, callback) {
            require('fs').exists(path, callback);
          }, 'path.exists is now called `fs.exists`.');


          exports.existsSync = util.deprecate(function(path) {
            return require('fs').existsSync(path);
          }, 'path.existsSync is now called `fs.existsSync`.');


          if (isWindows) {
            exports._makeLong = function(path) {
              path = '' + path;
              if (!path) {
                return '';
              }

              var resolvedPath = exports.resolve(path);

              if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
                // path is local filesystem path, which needs to be converted
                // to long UNC path.
                return '\\\\?\\' + resolvedPath;
              } else if (/^\\\\[^?.]/.test(resolvedPath)) {
                // path is network UNC path, which needs to be converted
                // to long UNC path.
                return '\\\\?\\UNC\\' + resolvedPath.substring(2);
              }

              return path;
            };
          } else {
            exports._makeLong = function(path) {
              return path;
            };
          }

        },

        "54c69a095dc8e4a9173bd8284c4e8ad7": // from: 
        function(exports, require, module, __filename, __dirname) {
          var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(xs) {
              return Object.prototype.toString.call(xs) === '[object Array]'
            };

          var objectKeys = Object.keys || function objectKeys(object) {
              if (object !== Object(object)) throw new TypeError('Invalid object');
              var keys = [];
              for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
              return keys;
            }


            /*!
             * querystring
             * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
             * MIT Licensed
             */

            /**
             * Library version.
             */

            exports.version = '0.3.1';

          /**
           * Object#toString() ref for stringify().
           */

          var toString = Object.prototype.toString;

          /**
           * Cache non-integer test regexp.
           */

          var notint = /[^0-9]/;

          /**
           * Parse the given query `str`, returning an object.
           *
           * @param {String} str
           * @return {Object}
           * @api public
           */

          exports.parse = function(str) {
            if (null == str || '' == str) return {};

            function promote(parent, key) {
              if (parent[key].length == 0) return parent[key] = {};
              var t = {};
              for (var i in parent[key]) t[i] = parent[key][i];
              parent[key] = t;
              return t;
            }

            return String(str).split('&').reduce(function(ret, pair) {
              try {
                pair = decodeURIComponent(pair.replace(/\+/g, ' '));
              } catch (e) {
                // ignore
              }

              var eql = pair.indexOf('='),
                brace = lastBraceInKey(pair),
                key = pair.substr(0, brace || eql),
                val = pair.substr(brace || eql, pair.length),
                val = val.substr(val.indexOf('=') + 1, val.length),
                parent = ret;

              // ?foo
              if ('' == key) key = pair, val = '';

              // nested
              if (~key.indexOf(']')) {
                var parts = key.split('['),
                  len = parts.length,
                  last = len - 1;

                function parse(parts, parent, key) {
                  var part = parts.shift();

                  // end
                  if (!part) {
                    if (isArray(parent[key])) {
                      parent[key].push(val);
                    } else if ('object' == typeof parent[key]) {
                      parent[key] = val;
                    } else if ('undefined' == typeof parent[key]) {
                      parent[key] = val;
                    } else {
                      parent[key] = [parent[key], val];
                    }
                    // array
                  } else {
                    obj = parent[key] = parent[key] || [];
                    if (']' == part) {
                      if (isArray(obj)) {
                        if ('' != val) obj.push(val);
                      } else if ('object' == typeof obj) {
                        obj[objectKeys(obj).length] = val;
                      } else {
                        obj = parent[key] = [parent[key], val];
                      }
                      // prop
                    } else if (~part.indexOf(']')) {
                      part = part.substr(0, part.length - 1);
                      if (notint.test(part) && isArray(obj)) obj = promote(parent, key);
                      parse(parts, obj, part);
                      // key
                    } else {
                      if (notint.test(part) && isArray(obj)) obj = promote(parent, key);
                      parse(parts, obj, part);
                    }
                  }
                }

                parse(parts, parent, 'base');
                // optimize
              } else {
                if (notint.test(key) && isArray(parent.base)) {
                  var t = {};
                  for (var k in parent.base) t[k] = parent.base[k];
                  parent.base = t;
                }
                set(parent.base, key, val);
              }

              return ret;
            }, {
              base: {}
            }).base;
          };

          /**
           * Turn the given `obj` into a query string
           *
           * @param {Object} obj
           * @return {String}
           * @api public
           */

          var stringify = exports.stringify = function(obj, prefix) {
            if (isArray(obj)) {
              return stringifyArray(obj, prefix);
            } else if ('[object Object]' == toString.call(obj)) {
              return stringifyObject(obj, prefix);
            } else if ('string' == typeof obj) {
              return stringifyString(obj, prefix);
            } else {
              return prefix;
            }
          };

          /**
           * Stringify the given `str`.
           *
           * @param {String} str
           * @param {String} prefix
           * @return {String}
           * @api private
           */

          function stringifyString(str, prefix) {
            if (!prefix) throw new TypeError('stringify expects an object');
            return prefix + '=' + encodeURIComponent(str);
          }

          /**
           * Stringify the given `arr`.
           *
           * @param {Array} arr
           * @param {String} prefix
           * @return {String}
           * @api private
           */

          function stringifyArray(arr, prefix) {
            var ret = [];
            if (!prefix) throw new TypeError('stringify expects an object');
            for (var i = 0; i < arr.length; i++) {
              ret.push(stringify(arr[i], prefix + '[]'));
            }
            return ret.join('&');
          }

          /**
           * Stringify the given `obj`.
           *
           * @param {Object} obj
           * @param {String} prefix
           * @return {String}
           * @api private
           */

          function stringifyObject(obj, prefix) {
            var ret = [],
              keys = objectKeys(obj),
              key;
            for (var i = 0, len = keys.length; i < len; ++i) {
              key = keys[i];
              ret.push(stringify(obj[key], prefix ? prefix + '[' + encodeURIComponent(key) + ']' : encodeURIComponent(key)));
            }
            return ret.join('&');
          }

          /**
           * Set `obj`'s `key` to `val` respecting
           * the weird and wonderful syntax of a qs,
           * where "foo=bar&foo=baz" becomes an array.
           *
           * @param {Object} obj
           * @param {String} key
           * @param {String} val
           * @api private
           */

          function set(obj, key, val) {
            var v = obj[key];
            if (undefined === v) {
              obj[key] = val;
            } else if (isArray(v)) {
              v.push(val);
            } else {
              obj[key] = [v, val];
            }
          }

          /**
           * Locate last brace in `str` within the key.
           *
           * @param {String} str
           * @return {Number}
           * @api private
           */

          function lastBraceInKey(str) {
            var len = str.length,
              brace, c;
            for (var i = 0; i < len; ++i) {
              c = str[i];
              if (']' == c) brace = false;
              if ('[' == c) brace = true;
              if ('=' == c && !brace) return i;
            }
          }

        },

        "f0d5935f094eb3d9fb70c67795bd4caf": // from: 
        function(exports, require, module, __filename, __dirname) {
          var events = require('events');
          var util = require('util');

          function Stream() {
            events.EventEmitter.call(this);
          }
          util.inherits(Stream, events.EventEmitter);
          module.exports = Stream;
          // Backwards-compat with node 0.4.x
          Stream.Stream = Stream;

          Stream.prototype.pipe = function(dest, options) {
            var source = this;

            function ondata(chunk) {
              if (dest.writable) {
                if (false === dest.write(chunk) && source.pause) {
                  source.pause();
                }
              }
            }

            source.on('data', ondata);

            function ondrain() {
              if (source.readable && source.resume) {
                source.resume();
              }
            }

            dest.on('drain', ondrain);

            // If the 'end' option is not supplied, dest.end() will be called when
            // source gets the 'end' or 'close' events.  Only dest.end() once, and
            // only when all sources have ended.
            if (!dest._isStdio && (!options || options.end !== false)) {
              dest._pipeCount = dest._pipeCount || 0;
              dest._pipeCount++;

              source.on('end', onend);
              source.on('close', onclose);
            }

            var didOnEnd = false;

            function onend() {
              if (didOnEnd) return;
              didOnEnd = true;

              dest._pipeCount--;

              // remove the listeners
              cleanup();

              if (dest._pipeCount > 0) {
                // waiting for other incoming streams to end.
                return;
              }

              dest.end();
            }


            function onclose() {
              if (didOnEnd) return;
              didOnEnd = true;

              dest._pipeCount--;

              // remove the listeners
              cleanup();

              if (dest._pipeCount > 0) {
                // waiting for other incoming streams to end.
                return;
              }

              dest.destroy();
            }

            // don't leave dangling pipes when there are errors.
            function onerror(er) {
              cleanup();
              if (this.listeners('error').length === 0) {
                throw er; // Unhandled stream error in pipe.
              }
            }

            source.on('error', onerror);
            dest.on('error', onerror);

            // remove all the event listeners that were added.
            function cleanup() {
              source.removeListener('data', ondata);
              dest.removeListener('drain', ondrain);

              source.removeListener('end', onend);
              source.removeListener('close', onclose);

              source.removeListener('error', onerror);
              dest.removeListener('error', onerror);

              source.removeListener('end', cleanup);
              source.removeListener('close', cleanup);

              dest.removeListener('end', cleanup);
              dest.removeListener('close', cleanup);
            }

            source.on('end', cleanup);
            source.on('close', cleanup);

            dest.on('end', cleanup);
            dest.on('close', cleanup);

            dest.emit('pipe', source);

            // Allow for unix-like usage: A.pipe(B).pipe(C)
            return dest;
          };

        },

        "4e0d787840f05b0c47b10d63b6f3898f": // from: 
        function(exports, require, module, __filename, __dirname) {
          module.exports = require('util');

        },

        "12124e45d125f26e20242c0e81a80f19": // from: 
        function(exports, require, module, __filename, __dirname) {
          exports.isatty = function() {};
          exports.setRawMode = function() {};

        },

        "d0c9d6cc2490c964b789d43ae4803b7b": // from: 
        function(exports, require, module, __filename, __dirname) {
          var punycode = {
            encode: function(s) {
              return s
            }
          };

          exports.parse = urlParse;
          exports.resolve = urlResolve;
          exports.resolveObject = urlResolveObject;
          exports.format = urlFormat;

          function arrayIndexOf(array, subject) {
            for (var i = 0, j = array.length; i < j; i++) {
              if (array[i] == subject) return i;
            }
            return -1;
          }

          var objectKeys = Object.keys || function objectKeys(object) {
              if (object !== Object(object)) throw new TypeError('Invalid object');
              var keys = [];
              for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
              return keys;
            }

            // Reference: RFC 3986, RFC 1808, RFC 2396

            // define these here so at least they only have to be
            // compiled once on the first module load.
          var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]+$/,
            // RFC 2396: characters reserved for delimiting URLs.
            delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
            // RFC 2396: characters not allowed for various reasons.
            unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
            // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
            autoEscape = ['\''],
            // Characters that are never ever allowed in a hostname.
            // Note that any invalid chars are also handled, but these
            // are the ones that are *expected* to be seen, so we fast-path
            // them.
            nonHostChars = ['%', '/', '?', ';', '#'].concat(unwise).concat(autoEscape),
            nonAuthChars = ['/', '@', '?', '#'].concat(delims),
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
            hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
            // protocols that can allow "unsafe" and "unwise" chars.
            unsafeProtocol = {
              'javascript': true,
              'javascript:': true
            },
            // protocols that never have a hostname.
            hostlessProtocol = {
              'javascript': true,
              'javascript:': true
            },
            // protocols that always have a path component.
            pathedProtocol = {
              'http': true,
              'https': true,
              'ftp': true,
              'gopher': true,
              'file': true,
              'http:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true
            },
            // protocols that always contain a // bit.
            slashedProtocol = {
              'http': true,
              'https': true,
              'ftp': true,
              'gopher': true,
              'file': true,
              'http:': true,
              'https:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true
            },
            querystring = require('querystring');

          function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && typeof(url) === 'object' && url.href) return url;

            if (typeof url !== 'string') {
              throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
            }

            var out = {},
            rest = url;

            // cut off any delimiters.
            // This is to support parse stuff like "<http://foo.com>"
            for (var i = 0, l = rest.length; i < l; i++) {
              if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;
            }
            if (i !== 0) rest = rest.substr(i);


            var proto = protocolPattern.exec(rest);
            if (proto) {
              proto = proto[0];
              var lowerProto = proto.toLowerCase();
              out.protocol = lowerProto;
              rest = rest.substr(proto.length);
            }

            // figure out if it's got a host
            // user@server is *always* interpreted as a hostname, and url
            // resolution will treat //foo/bar as host=foo,path=bar because that's
            // how the browser resolves relative URLs.
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
              var slashes = rest.substr(0, 2) === '//';
              if (slashes && !(proto && hostlessProtocol[proto])) {
                rest = rest.substr(2);
                out.slashes = true;
              }
            }

            if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
              // there's a hostname.
              // the first instance of /, ?, ;, or # ends the host.
              // don't enforce full RFC correctness, just be unstupid about it.

              // If there is an @ in the hostname, then non-host chars *are* allowed
              // to the left of the first @ sign, unless some non-auth character
              // comes *before* the @-sign.
              // URLs are obnoxious.
              var atSign = arrayIndexOf(rest, '@');
              if (atSign !== -1) {
                // there *may be* an auth
                var hasAuth = true;
                for (var i = 0, l = nonAuthChars.length; i < l; i++) {
                  var index = arrayIndexOf(rest, nonAuthChars[i]);
                  if (index !== -1 && index < atSign) {
                    // not a valid auth.  Something like http://foo.com/bar@baz/
                    hasAuth = false;
                    break;
                  }
                }
                if (hasAuth) {
                  // pluck off the auth portion.
                  out.auth = rest.substr(0, atSign);
                  rest = rest.substr(atSign + 1);
                }
              }

              var firstNonHost = -1;
              for (var i = 0, l = nonHostChars.length; i < l; i++) {
                var index = arrayIndexOf(rest, nonHostChars[i]);
                if (index !== -1 && (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
              }

              if (firstNonHost !== -1) {
                out.host = rest.substr(0, firstNonHost);
                rest = rest.substr(firstNonHost);
              } else {
                out.host = rest;
                rest = '';
              }

              // pull out port.
              var p = parseHost(out.host);
              var keys = objectKeys(p);
              for (var i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                out[key] = p[key];
              }

              // we've indicated that there is a hostname,
              // so even if it's empty, it has to be present.
              out.hostname = out.hostname || '';

              // validate a little.
              if (out.hostname.length > hostnameMaxLen) {
                out.hostname = '';
              } else {
                var hostparts = out.hostname.split(/\./);
                for (var i = 0, l = hostparts.length; i < l; i++) {
                  var part = hostparts[i];
                  if (!part) continue;
                  if (!part.match(hostnamePartPattern)) {
                    var newpart = '';
                    for (var j = 0, k = part.length; j < k; j++) {
                      if (part.charCodeAt(j) > 127) {
                        // we replace non-ASCII char with a temporary placeholder
                        // we need this to make sure size of hostname is not
                        // broken by replacing non-ASCII by nothing
                        newpart += 'x';
                      } else {
                        newpart += part[j];
                      }
                    }
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                      var validParts = hostparts.slice(0, i);
                      var notHost = hostparts.slice(i + 1);
                      var bit = part.match(hostnamePartStart);
                      if (bit) {
                        validParts.push(bit[1]);
                        notHost.unshift(bit[2]);
                      }
                      if (notHost.length) {
                        rest = '/' + notHost.join('.') + rest;
                      }
                      out.hostname = validParts.join('.');
                      break;
                    }
                  }
                }
              }

              // hostnames are always lower case.
              out.hostname = out.hostname.toLowerCase();

              // IDNA Support: Returns a puny coded representation of "domain".
              // It only converts the part of the domain name that
              // has non ASCII characters. I.e. it dosent matter if
              // you call it with a domain that already is in ASCII.
              var domainArray = out.hostname.split('.');
              var newOut = [];
              for (var i = 0; i < domainArray.length; ++i) {
                var s = domainArray[i];
                newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
              }
              out.hostname = newOut.join('.');

              out.host = (out.hostname || '') + ((out.port) ? ':' + out.port : '');
              out.href += out.host;
            }

            // now rest is set to the post-host stuff.
            // chop off any delim chars.
            if (!unsafeProtocol[lowerProto]) {

              // First, make 100% sure that any "autoEscape" chars get
              // escaped, even if encodeURIComponent doesn't think they
              // need to be.
              for (var i = 0, l = autoEscape.length; i < l; i++) {
                var ae = autoEscape[i];
                var esc = encodeURIComponent(ae);
                if (esc === ae) {
                  esc = escape(ae);
                }
                rest = rest.split(ae).join(esc);
              }

              // Now make sure that delims never appear in a url.
              var chop = rest.length;
              for (var i = 0, l = delims.length; i < l; i++) {
                var c = arrayIndexOf(rest, delims[i]);
                if (c !== -1) {
                  chop = Math.min(c, chop);
                }
              }
              rest = rest.substr(0, chop);
            }


            // chop off from the tail first.
            var hash = arrayIndexOf(rest, '#');
            if (hash !== -1) {
              // got a fragment string.
              out.hash = rest.substr(hash);
              rest = rest.slice(0, hash);
            }
            var qm = arrayIndexOf(rest, '?');
            if (qm !== -1) {
              out.search = rest.substr(qm);
              out.query = rest.substr(qm + 1);
              if (parseQueryString) {
                out.query = querystring.parse(out.query);
              }
              rest = rest.slice(0, qm);
            } else if (parseQueryString) {
              // no query string, but parseQueryString still requested
              out.search = '';
              out.query = {};
            }
            if (rest) out.pathname = rest;
            if (slashedProtocol[proto] && out.hostname && !out.pathname) {
              out.pathname = '/';
            }

            //to support http.request
            if (out.pathname || out.search) {
              out.path = (out.pathname ? out.pathname : '') + (out.search ? out.search : '');
            }

            // finally, reconstruct the href based on what has been validated.
            out.href = urlFormat(out);
            return out;
          }

          // format a parsed object into a url string
          function urlFormat(obj) {
            // ensure it's an object, and not a string url.
            // If it's an obj, this is a no-op.
            // this way, you can call url_format() on strings
            // to clean up potentially wonky urls.
            if (typeof(obj) === 'string') obj = urlParse(obj);

            var auth = obj.auth || '';
            if (auth) {
              auth = auth.split('@').join('%40');
              for (var i = 0, l = nonAuthChars.length; i < l; i++) {
                var nAC = nonAuthChars[i];
                auth = auth.split(nAC).join(encodeURIComponent(nAC));
              }
              auth += '@';
            }

            var protocol = obj.protocol || '',
              host = (obj.host !== undefined) ? auth + obj.host : obj.hostname !== undefined ? (
              auth + obj.hostname + (obj.port ? ':' + obj.port : '')) : false,
              pathname = obj.pathname || '',
              query = obj.query && ((typeof obj.query === 'object' && objectKeys(obj.query).length) ? querystring.stringify(obj.query) : '') || '',
              search = obj.search || (query && ('?' + query)) || '',
              hash = obj.hash || '';

            if (protocol && protocol.substr(-1) !== ':') protocol += ':';

            // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
            // unless they had them to begin with.
            if (obj.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
              host = '//' + (host || '');
              if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
            } else if (!host) {
              host = '';
            }

            if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
            if (search && search.charAt(0) !== '?') search = '?' + search;

            return protocol + host + pathname + search + hash;
          }

          function urlResolve(source, relative) {
            return urlFormat(urlResolveObject(source, relative));
          }

          function urlResolveObject(source, relative) {
            if (!source) return relative;

            source = urlParse(urlFormat(source), false, true);
            relative = urlParse(urlFormat(relative), false, true);

            // hash is always overridden, no matter what.
            source.hash = relative.hash;

            if (relative.href === '') {
              source.href = urlFormat(source);
              return source;
            }

            // hrefs like //foo/bar always cut to the protocol.
            if (relative.slashes && !relative.protocol) {
              relative.protocol = source.protocol;
              //urlParse appends trailing / to urls like http://www.example.com
              if (slashedProtocol[relative.protocol] && relative.hostname && !relative.pathname) {
                relative.path = relative.pathname = '/';
              }
              relative.href = urlFormat(relative);
              return relative;
            }

            if (relative.protocol && relative.protocol !== source.protocol) {
              // if it's a known url protocol, then changing
              // the protocol does weird things
              // first, if it's not file:, then we MUST have a host,
              // and if there was a path
              // to begin with, then we MUST have a path.
              // if it is file:, then the host is dropped,
              // because that's known to be hostless.
              // anything else is assumed to be absolute.
              if (!slashedProtocol[relative.protocol]) {
                relative.href = urlFormat(relative);
                return relative;
              }
              source.protocol = relative.protocol;
              if (!relative.host && !hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || '').split('/');
                while (relPath.length && !(relative.host = relPath.shift()));
                if (!relative.host) relative.host = '';
                if (!relative.hostname) relative.hostname = '';
                if (relPath[0] !== '') relPath.unshift('');
                if (relPath.length < 2) relPath.unshift('');
                relative.pathname = relPath.join('/');
              }
              source.pathname = relative.pathname;
              source.search = relative.search;
              source.query = relative.query;
              source.host = relative.host || '';
              source.auth = relative.auth;
              source.hostname = relative.hostname || relative.host;
              source.port = relative.port;
              //to support http.request
              if (source.pathname !== undefined || source.search !== undefined) {
                source.path = (source.pathname ? source.pathname : '') + (source.search ? source.search : '');
              }
              source.slashes = source.slashes || relative.slashes;
              source.href = urlFormat(source);
              return source;
            }

            var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
              isRelAbs = (
              relative.host !== undefined || relative.pathname && relative.pathname.charAt(0) === '/'),
              mustEndAbs = (isRelAbs || isSourceAbs || (source.host && relative.pathname)),
              removeAllDots = mustEndAbs,
              srcPath = source.pathname && source.pathname.split('/') || [],
              relPath = relative.pathname && relative.pathname.split('/') || [],
              psychotic = source.protocol && !slashedProtocol[source.protocol];

            // if the url is a non-slashed url, then relative
            // links like ../.. should be able
            // to crawl up to the hostname, as well.  This is strange.
            // source.protocol has already been set by now.
            // Later on, put the first path part into the host field.
            if (psychotic) {

              delete source.hostname;
              delete source.port;
              if (source.host) {
                if (srcPath[0] === '') srcPath[0] = source.host;
                else srcPath.unshift(source.host);
              }
              delete source.host;
              if (relative.protocol) {
                delete relative.hostname;
                delete relative.port;
                if (relative.host) {
                  if (relPath[0] === '') relPath[0] = relative.host;
                  else relPath.unshift(relative.host);
                }
                delete relative.host;
              }
              mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
            }

            if (isRelAbs) {
              // it's absolute.
              source.host = (relative.host || relative.host === '') ? relative.host : source.host;
              source.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : source.hostname;
              source.search = relative.search;
              source.query = relative.query;
              srcPath = relPath;
              // fall through to the dot-handling below.
            } else if (relPath.length) {
              // it's relative
              // throw away the existing file, and take the new path instead.
              if (!srcPath) srcPath = [];
              srcPath.pop();
              srcPath = srcPath.concat(relPath);
              source.search = relative.search;
              source.query = relative.query;
            } else if ('search' in relative) {
              // just pull out the search.
              // like href='?foo'.
              // Put this after the other two cases because it simplifies the booleans
              if (psychotic) {
                source.hostname = source.host = srcPath.shift();
                //occationaly the auth can get stuck only in host
                //this especialy happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ? source.host.split('@') : false;
                if (authInHost) {
                  source.auth = authInHost.shift();
                  source.host = source.hostname = authInHost.shift();
                }
              }
              source.search = relative.search;
              source.query = relative.query;
              //to support http.request
              if (source.pathname !== undefined || source.search !== undefined) {
                source.path = (source.pathname ? source.pathname : '') + (source.search ? source.search : '');
              }
              source.href = urlFormat(source);
              return source;
            }
            if (!srcPath.length) {
              // no path at all.  easy.
              // we've already handled the other stuff above.
              delete source.pathname;
              //to support http.request
              if (!source.search) {
                source.path = '/' + source.search;
              } else {
                delete source.path;
              }
              source.href = urlFormat(source);
              return source;
            }
            // if a url ENDs in . or .., then it must get a trailing slash.
            // however, if it ends in anything else non-slashy,
            // then it must NOT get a trailing slash.
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = (
            (source.host || relative.host) && (last === '.' || last === '..') || last === '');

            // strip single dots, resolve double dots to parent dir
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
              last = srcPath[i];
              if (last == '.') {
                srcPath.splice(i, 1);
              } else if (last === '..') {
                srcPath.splice(i, 1);
                up++;
              } else if (up) {
                srcPath.splice(i, 1);
                up--;
              }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (!mustEndAbs && !removeAllDots) {
              for (; up--; up) {
                srcPath.unshift('..');
              }
            }

            if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
              srcPath.unshift('');
            }

            if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
              srcPath.push('');
            }

            var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

            // put the host back
            if (psychotic) {
              source.hostname = source.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
              //occationaly the auth can get stuck only in host
              //this especialy happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ? source.host.split('@') : false;
              if (authInHost) {
                source.auth = authInHost.shift();
                source.host = source.hostname = authInHost.shift();
              }
            }

            mustEndAbs = mustEndAbs || (source.host && srcPath.length);

            if (mustEndAbs && !isAbsolute) {
              srcPath.unshift('');
            }

            source.pathname = srcPath.join('/');
            //to support request.http
            if (source.pathname !== undefined || source.search !== undefined) {
              source.path = (source.pathname ? source.pathname : '') + (source.search ? source.search : '');
            }
            source.auth = relative.auth || source.auth;
            source.slashes = source.slashes || relative.slashes;
            source.href = urlFormat(source);
            return source;
          }

          function parseHost(host) {
            var out = {};
            var port = portPattern.exec(host);
            if (port) {
              port = port[0];
              out.port = port.substr(1);
              host = host.substr(0, host.length - port.length);
            }
            if (host) out.hostname = host;
            return out;
          }

        },

        "ddeff58ff67e5d2d686891fc66ebb2b7": // from: 
        function(exports, require, module, __filename, __dirname) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var formatRegExp = /%[sdj%]/g;
          exports.format = function(f) {
            if (typeof f !== 'string') {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
              if (x === '%') return '%';
              if (i >= len) return x;
              switch (x) {
              case '%s':
                return String(args[i++]);
              case '%d':
                return Number(args[i++]);
              case '%j':
                return JSON.stringify(args[i++]);
              default:
                return x;
              }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (x === null || typeof x !== 'object') {
                str += ' ' + x;
              } else {
                str += ' ' + inspect(x);
              }
            }
            return str;
          };


          // Mark that a method should not be used.
          // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.
          exports.deprecate = function(fn, msg) {
            if (process.noDeprecation === true) {
              return fn;
            }

            var warned = false;

            function deprecated() {
              if (!warned) {
                if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }

            return deprecated;
          };


          exports.print = function() {
            for (var i = 0, len = arguments.length; i < len; ++i) {
              process.stdout.write(String(arguments[i]));
            }
          };


          exports.puts = function() {
            for (var i = 0, len = arguments.length; i < len; ++i) {
              process.stdout.write(arguments[i] + '\n');
            }
          };


          exports.debug = function(x) {
            process.stderr.write('DEBUG: ' + x + '\n');
          };


          var error = exports.error = function(x) {
            for (var i = 0, len = arguments.length; i < len; ++i) {
              process.stderr.write(arguments[i] + '\n');
            }
          };


          /**
           * Echos the value of a value. Trys to print the value out
           * in the best way possible given the different types.
           *
           * @param {Object} obj The object to print out.
           * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
           *    properties of objects.
           * @param {Number} depth Depth in which to descend in object. Default is 2.
           * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
           *    output. Default is false (no coloring).
           */
          function inspect(obj, showHidden, depth, colors) {
            var ctx = {
              showHidden: showHidden,
              seen: [],
              stylize: colors ? stylizeWithColor : stylizeNoColor
            };
            return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
          }
          exports.inspect = inspect;


          // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
          inspect.colors = {
            'bold': [1, 22],
            'italic': [3, 23],
            'underline': [4, 24],
            'inverse': [7, 27],
            'white': [37, 39],
            'grey': [90, 39],
            'black': [30, 39],
            'blue': [34, 39],
            'cyan': [36, 39],
            'green': [32, 39],
            'magenta': [35, 39],
            'red': [31, 39],
            'yellow': [33, 39]
          };

          // Don't use 'blue' not visible on cmd.exe
          inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red'
          };


          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
              return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
              return str;
            }
          }


          function stylizeNoColor(str, styleType) {
            return str;
          }


          function arrayToHash(array) {
            var hash = {};

            array.forEach(function(val, idx) {
              hash[val] = true;
            });

            return hash;
          }


          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (value && typeof value.inspect === 'function' &&
            // Filter out the util module, it's inspect function is special
            value.inspect !== exports.inspect &&
            // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
              return String(value.inspect(recurseTimes));
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
              if (typeof value === 'function') {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
              }
              if (isError(value)) {
                return formatError(value);
              }
            }

            var base = '',
              array = false,
              braces = ['{', '}'];

            // Make Array say that they are Array
            if (isArray(value)) {
              array = true;
              braces = ['[', ']'];
            }

            // Make functions say that they are functions
            if (typeof value === 'function') {
              var n = value.name ? ': ' + value.name : '';
              base = ' [Function' + n + ']';
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
              base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              } else {
                return ctx.stylize('[Object]', 'special');
              }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function(key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
          }


          function formatPrimitive(ctx, value) {
            switch (typeof value) {
            case 'undefined':
              return ctx.stylize('undefined', 'undefined');

            case 'string':
              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
              return ctx.stylize(simple, 'string');

            case 'number':
              return ctx.stylize('' + value, 'number');

            case 'boolean':
              return ctx.stylize('' + value, 'boolean');
            }
            // For some reason typeof null is "object", so special case here.
            if (value === null) {
              return ctx.stylize('null', 'null');
            }
          }


          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
          }


          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                String(i), true));
              } else {
                output.push('');
              }
            }
            keys.forEach(function(key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                key, true));
              }
            });
            return output;
          }


          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {
              value: value[key]
            };
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
              } else {
                str = ctx.stylize('[Getter]', 'special');
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']';
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (recurseTimes === null) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str.split('\n').map(function(line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + str.split('\n').map(function(line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special');
              }
            }
            if (typeof name === 'undefined') {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify('' + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, 'name');
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, 'string');
              }
            }

            return name + ': ' + str;
          }


          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
              numLinesEst++;
              if (cur.indexOf('\n') >= 0) numLinesEst++;
              return prev + cur.length + 1;
            }, 0);

            if (length > 60) {
              return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          }


          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          function isArray(ar) {
            return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
          }
          exports.isArray = isArray;


          function isRegExp(re) {
            return typeof re === 'object' && objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;


          function isDate(d) {
            return typeof d === 'object' && objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;


          function isError(e) {
            return typeof e === 'object' && objectToString(e) === '[object Error]';
          }
          exports.isError = isError;


          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }


          exports.p = exports.deprecate(function() {
            for (var i = 0, len = arguments.length; i < len; ++i) {
              error(exports.inspect(arguments[i]));
            }
          }, 'util.p: Use console.error() instead.');


          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
          }


          var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

          // 26 Feb 16:19:34
          function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()),
            pad(d.getMinutes()),
            pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
          }


          exports.log = function(msg) {
            exports.puts(timestamp() + ' - ' + msg.toString());
          };


          exports.exec = exports.deprecate(function() {
            return require('child_process').exec.apply(this, arguments);
          }, 'util.exec is now called `child_process.exec`.');


          function pump(readStream, writeStream, callback) {
            var callbackCalled = false;

            function call(a, b, c) {
              if (callback && !callbackCalled) {
                callback(a, b, c);
                callbackCalled = true;
              }
            }

            readStream.addListener('data', function(chunk) {
              if (writeStream.write(chunk) === false) readStream.pause();
            });

            writeStream.addListener('drain', function() {
              readStream.resume();
            });

            readStream.addListener('end', function() {
              writeStream.end();
            });

            readStream.addListener('close', function() {
              call();
            });

            readStream.addListener('error', function(err) {
              writeStream.end();
              call(err);
            });

            writeStream.addListener('error', function(err) {
              readStream.destroy();
              call(err);
            });
          }
          exports.pump = exports.deprecate(pump, 'util.pump() is deprecated. Use ReadableStream.prototype.pump() instead.');


          /**
           * Inherit the prototype methods from one constructor into another.
           *
           * The Function.prototype.inherits from lang.js rewritten as a standalone
           * function (not on Function.prototype). NOTE: If this file is to be loaded
           * during bootstrapping this function needs to be rewritten using some native
           * functions as prototype setup using normal JavaScript does not work as
           * expected during bootstrapping (see mirror.js in r114903).
           *
           * @param {function} ctor Constructor function which needs to inherit the
           *     prototype.
           * @param {function} superCtor Constructor function to inherit prototype from.
           */
          exports.inherits = function(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };

          exports._extend = function(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || typeof add !== 'object') return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };

          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }

        },

      },
      read: function(reference) {
        if (reference.__ref != null) {
          reference = reference.__ref;
        }
        return base64Decode(global.filesystem.content[reference]);
      }
    }
  };
})();

var process = (function() {
  var scopes;
  scopes = {
    evals: {
      NodeScript: {
        runInThisContext: function(source, filename, returnResult) {
          return global.filesystem.module_functions[source];
        },
        runInNewContext: function(source, filename, returnResult) {
          console.log("WARNING: runInNewContext doesn't work in the browser.");
          return global.filesystem.module_functions[source];
        }
      }
    }
  };
  return {
    platform: "browser",
    moduleLoadList: [],
    env: {},
    argv: ["node", "/"],
    binding: function(scope) {
      return scopes[scope];
    },
    cwd: function() {
      return "/";
    }
  };
})();

var NativeModule = (function() {
  var name, ref, runInThisContext, _ref;
  runInThisContext = process.binding('evals').NodeScript.runInThisContext;

  function NativeModule(id) {
    this.filename = id + '.js';
    this.id = id;
    this.exports = {};
    this.loaded = false;
  }

  NativeModule._source = {}
  NativeModule._cache = {};

  NativeModule.require = function(id) {
    if (id == 'native_module') {
      return NativeModule;
    }

    var cached = NativeModule.getCached(id);
    if (cached) {
      return cached.exports;
    }

    if (!NativeModule.exists(id)) {
      throw new Error('No such native module ' + id);
    }

    process.moduleLoadList.push('NativeModule ' + id);

    var nativeModule = new NativeModule(id);

    nativeModule.compile();
    nativeModule.cache();

    return nativeModule.exports;
  };

  NativeModule.getCached = function(id) {
    return NativeModule._cache[id];
  }

  NativeModule.exists = function(id) {
    return NativeModule._source.hasOwnProperty(id);
  }

  NativeModule.getSource = function(id) {
    return NativeModule._source[id];
  }

  NativeModule.wrap = function(script) {
    // return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];
    return script;
  };

  // NativeModule.wrapper = [
  //   '(function (exports, require, module, __filename, __dirname) { ',
  //   '\n});'
  // ];

  NativeModule.prototype.compile = function() {
    var source = NativeModule.getSource(this.id);
    source = NativeModule.wrap(source);
    var fn = runInThisContext(source, this.filename, true);
    fn(this.exports, NativeModule.require, this, this.filename);

    this.loaded = true;
  };

  NativeModule.prototype.cache = function() {
    NativeModule._cache[this.id] = this;
  };;

  _ref = global.filesystem.native_modules;
  for (name in _ref) {
    ref = _ref[name];
    NativeModule._source[name] = global.filesystem.read(ref);
  }
  return NativeModule;
})();

NativeModule.require("module").runMain();
